{"version":3,"sources":["../src/constants/env.constants.ts","../src/global/A-Feature/A-Feature.types.ts","../src/global/A-Meta/A-Meta.class.ts","../src/global/A-Entity/A-Entity.constants.ts","../src/global/A-Container/A-Container.constants.ts","../src/global/A-Component/A-Component.constants.ts","../src/global/A-Component/A-Component.meta.ts","../src/global/A-Container/A-Container.class.ts","../src/global/A-Container/A-Container.meta.ts","../src/helpers/A_Formatter.helper.ts","../src/helpers/A_Identity.helper.ts","../src/global/A-Error/A_Error.constants.ts","../src/global/A-Error/A_Error.class.ts","../src/global/ASEID/ASEID.error.ts","../src/global/ASEID/ASEID.class.ts","../src/global/A-Entity/A-Entity.error.ts","../src/global/A-Entity/A-Entity.class.ts","../src/global/A-Entity/A-Entity.meta.ts","../src/global/A-Fragment/A-Fragment.class.ts","../src/helpers/A_Common.helper.ts","../src/global/A-Scope/A-Scope.error.ts","../src/global/A-Scope/A-Scope.class.ts","../src/global/A-Caller/A_Caller.error.ts","../src/global/A-Caller/A_Caller.class.ts","../src/helpers/A_TypeGuards.helper.ts","../src/global/A-Feature/A-Feature.error.ts","../src/global/A-Feature/A-Feature-Define.decorator.ts","../src/global/A-Feature/A-Feature-Extend.decorator.ts","../src/global/A-Stage/A-Stage.types.ts","../src/global/A-Stage/A-Stage.error.ts","../src/global/A-Stage/A-Stage.class.ts","../src/global/A-StepManager/A-StepManager.error.ts","../src/global/A-StepManager/A-StepManager.class.ts","../src/global/A-Feature/A-Feature.class.ts","../src/global/A-Component/A-Component.class.ts","../src/global/A-Context/A-Context.error.ts","../src/global/A-Context/A-Context.class.ts","../src/global/A-Abstraction/A-Abstraction.error.ts","../src/global/A-Abstraction/A-Abstraction-Extend.decorator.ts","../src/global/A-Abstraction/A-Abstraction.class.ts","../src/global/A-Concept/A-Concept.constants.ts","../src/global/A-Concept/A-Concept.class.ts","../src/global/A-Concept/A-Concept.meta.ts","../src/global/A-Dependency/A-Dependency.error.ts","../src/global/A-Dependency/A-Dependency-Default.decorator.ts","../src/global/A-Dependency/A-Dependency-Flat.decorator.ts","../src/global/A-Dependency/A-Dependency-Load.decorator.ts","../src/global/A-Dependency/A-Dependency-Parent.decorator.ts","../src/global/A-Dependency/A-Dependency-Require.decorator.ts","../src/global/A-Dependency/A-Dependency.class.ts","../src/global/A-Inject/A-Inject.error.ts","../src/global/A-Inject/A-Inject.decorator.ts"],"names":["A_CONSTANTS__DEFAULT_ENV_VARIABLES","A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY","A_TYPES__FeatureState","_A_Meta","iterator","__name","meta","key","value","inheritedValue","name","results","regex","obj","k","v","item","res","json","A_Meta","A_TYPES__EntityMetaKey","A_TYPES__EntityFeatures","A_TYPES__ContainerMetaKey","A_TYPES__ComponentMetaKey","_A_ComponentMeta","handler","feature","steps","extensions","extension","abstraction","abstractions","injections","args","A_ComponentMeta","_A_Container","A_Context","config","scope","A_Feature","A_Container","_A_ContainerMeta","A_ContainerMeta","_A_FormatterHelper","str","part","index","A_FormatterHelper","_A_IdentityHelper","parts","time","random","id","timePart","randomPart","number","maxZeros","formattedNumber","A_IdentityHelper","A_CONSTANTS__ERROR_CODES","A_CONSTANTS__ERROR_DESCRIPTION","_A_Error","param1","param2","A_TypeGuards","error","ASEID","message","serialized","title","description","params","rootError","A_Error","_ASEID_Error","ASEID_Error","_ASEID","identity","concept","body","version","entity","idCandidate","shard","_A_EntityError","A_EntityError","_A_Entity","props","x","override","aseid","newEntity","A_Entity","_A_EntityMeta","A_EntityMeta","_A_Fragment","A_Fragment","_A_CommonHelper","resolve","childClass","parentClass","current","parents","chain","input","paths","result","removeProperties","target","currPath","currKey","path","pathKeys","source","visited","clone","component","UNKNOWN","ANONYMOUS","fnAny","match","objAny","s","A_CommonHelper","_A_ScopeError","A_ScopeError","_A_Scope","currentParent","layerOffset","parentScope","_components","_errors","_entities","ent","_fragments","_meta","fragment","param","parent","circularCheck","ctor","found","c","f","e","anotherScope","currentResults","parentResults","instance","instances","instructions","componentName","values","issuer","query","count","fragmentInstancePresented","el","resolvedArgs","arg","flat","dependency","require","create","defaultArgs","targetParent","newComponent","A_Component","acc","inheritanceChain","A_Scope","_A_CallerError","A_CallerError","_A_Caller","A_Caller","_A_TypeGuards","_A_FeatureError","A_FeatureError","A_Feature_Define","propertyKey","descriptor","metaKey","existedMeta","invoke","originalMethod","A_Feature_Extend","targetRegexp","behavior","before","after","include","exclude","throwOnError","buildTargetRegexp","existedDefinitions","existedMetaValue","existedIndex","includePart","excludePart","pattern","A_TYPES__A_Stage_Status","_A_StageError","A_StageError","_A_Stage","step","resolverConstructor","targetScope","newDependency","callArgs","reject","wrappedError","A_Stage","_A_StepManagerError","A_StepManagerError","_A_StepsManager","entities","i","self","entityId","node","neighbor","A_StepsManager","_A_Feature","componentScope","externalScope","template","stage","stageIndex","reason","param3","featureScope","_A_Component","_A_ContextError","A_ContextError","_A_Context","testEnvironment","importing","newScope","property","metaType","inheritMeta","callNames","callName","cmp","declaration","items","currentClass","other","otherClass","_A_AbstractionError","A_AbstractionError","A_Abstraction_Extend","setName","_A_Abstraction","container","A_Abstraction","A_TYPES__ConceptAbstractions","A_TYPES__ConceptMetaKey","_A_Concept","method","A_Concept","_A_ConceptMeta","containers","A_ConceptMeta","_A_DependencyError","A_DependencyError","A_Dependency_Default","methodName","parameterIndex","paramsArray","A_Dependency_Flat","A_Dependency_Load","A_Dependency_Parent","A_Dependency_Require","_A_Dependency","A_Dependency","_A_InjectError","A_InjectError","A_Inject"],"mappings":"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","file":"index.cjs","sourcesContent":["export const A_CONSTANTS__DEFAULT_ENV_VARIABLES = {\n    // ----------------------------------------------------------\n    // A-Concept Core Environment Variables\n    // ----------------------------------------------------------\n    // These environment variables are used by A-Concept core to configure the application\n    // ----------------------------------------------------------\n    /**\n     * Name of the application\n     * \n     * DEFAULT value is 'a-concept'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_NAME: 'A_CONCEPT_NAME',\n    /**\n     * Root scope of the application\n     * \n     * DEFAULT value is 'root'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_ROOT_SCOPE: 'A_CONCEPT_ROOT_SCOPE',\n    /**\n     * Environment of the application e.g. development, production, staging\n     */\n    A_CONCEPT_ENVIRONMENT: 'A_CONCEPT_ENVIRONMENT',\n    /**\n     * Root folder of the application\n     * [!] Automatically set by A-Concept when the application starts\n     */\n    A_CONCEPT_ROOT_FOLDER: 'A_CONCEPT_ROOT_FOLDER',\n    /**\n     * Allows to define a default error description for errors thrown without a description\n     */\n    A_ERROR_DEFAULT_DESCRIPTION: 'A_ERROR_DEFAULT_DESCRIPTION',\n} as const\n\n\n//should be an array\nexport type A_TYPES__ConceptENVVariables = (typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES)[keyof typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES][];\n\n\nexport const A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY = [\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_NAME,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ENVIRONMENT,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_FOLDER,\n\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_ERROR_DEFAULT_DESCRIPTION,\n] as const;\n\n","import { A_TYPES__A_StageStep, A_TYPES_StageExecutionBehavior } from \"../A-Stage/A-Stage.types\"\nimport { A_Fragment } from \"../A-Fragment/A-Fragment.class\"\nimport { A_Entity } from \"@adaas/a-concept/global/A-Entity/A-Entity.class\"\nimport { A_Container } from \"../A-Container/A-Container.class\"\nimport { A_Component } from \"../A-Component/A-Component.class\"\nimport { A_TYPES__Component_Constructor } from \"../A-Component/A-Component.types\"\nimport { A_TYPES__Container_Constructor } from \"../A-Container/A-Container.types\"\nimport { A_TYPES__Entity_Constructor } from \"../A-Entity/A-Entity.types\"\nimport { A_Feature } from \"./A-Feature.class\"\nimport { A_TYPES__Required } from \"@adaas/a-concept/types/A_Common.types\"\nimport { A_Scope } from \"../A-Scope/A-Scope.class\"\nimport { A_Stage } from \"../A-Stage/A-Stage.class\"\nimport { A_TYPES__Error_Init } from \"../A-Error/A_Error.types\"\n\n\n// ============================================================================\n// --------------------------- Primary Types ----------------------------------\n// ============================================================================\n/**\n * Feature constructor type\n * Uses the generic type T to specify the type of the feature\n */\nexport type A_TYPES__Feature_Constructor<T = A_Feature> = new (...args: any[]) => T;\n/**\n * Feature initialization type\n */\nexport type A_TYPES__Feature_Init<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = A_TYPES__Feature_InitWithComponent<T> | A_TYPES__Feature_InitWithTemplate<T>\n/**\n * Feature initialization type using component\n */\nexport type A_TYPES__Feature_InitWithComponent<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component: T,\n\n    /**\n     * In case when Entity is not attached to the scope can be used to transparently show dependencies\n     * \n     * \n     */\n    scope?: A_Scope\n}\n/**\n * Feature initialization type using template\n */\nexport type A_TYPES__Feature_InitWithTemplate<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The scope from where to retrieve dependent components, entities and containers. \n     * \n     * [!] Important for proper scoping. \n     */\n    scope: A_Scope\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component?: T,\n    /**\n     * Optional Feature template to be used instead of building it from decorators\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n\n/**\n * Feature serialized type\n */\nexport type A_TYPES__Feature_Serialized = {}\n\n\n/**\n * Feature lifecycle states\n */\nexport enum A_TYPES__FeatureState {\n    /**\n     * The feature has been initialized\n     */\n    INITIALIZED = \"INITIALIZED\",\n    /**\n     * The feature is currently being processed\n     */\n    PROCESSING = \"PROCESSING\",\n    /**\n     * The feature has been completed\n     */\n    COMPLETED = \"COMPLETED\",\n    /**\n     * The feature has been interrupted\n     */\n    INTERRUPTED = \"INTERRUPTED\",\n    /**\n     * The feature has failed\n     */\n    FAILED = \"FAILED\"\n}\n\n// ===========================================================================\n// --------------------------- Error Types ------------------------------------\n// ===========================================================================\n\nexport type A_TYPES__FeatureError_Init = {\n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n} & A_TYPES__Error_Init\n\n\n\n// ===========================================================================-\n// --------------------------- Available Types -------------------------------\n// ===========================================================================\n\n/**\n * A list of component where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableComponents = InstanceType<A_TYPES__FeatureAvailableConstructors>\n/**\n * A list of constructors where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableConstructors = A_TYPES__Component_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Container_Constructor\n\n\n\n// ===========================================================================\n// --------------------------- Decorator Types -------------------------------\n// ===========================================================================\n// ---------------------------------------------------------------------------\n// --------------------Feature Define Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Indicates a type of Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorDescriptor =\n    TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n/**\n * Describes additional configuration properties to be used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorConfig = {\n    /**\n     * Feature name\n     * \n     * [!] By default uses the method name\n     */\n    name: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n/**\n * Describes a single template item used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorTemplateItem = A_TYPES__Required<Partial<A_TYPES__A_StageStep>, ['name', 'handler', 'component']>\n/**\n * Describes a target where Feature Define decorator can be applied\n * \n * [!] The feature can be defined on Container, Entity, Component or Command\n */\nexport type A_TYPES__FeatureDefineDecoratorTarget = A_Container\n    | A_Entity\n    | A_Component\n/**\n * A type of Meta information stored by Feature Define decorator\n * This information then uses by A-Context to build a proper feature template\n */\nexport type A_TYPES__FeatureDefineDecoratorMeta = {\n    /**\n     * Feature name\n     * mainly it's a unique combination of the class name and method name\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__A_StageStep>\n}\n// ---------------------------------------------------------------------------\n// --------------------Feature Extend Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Descriptor type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorDescriptor =\n    TypedPropertyDescriptor<() => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<() => Promise<any>>\n/**\n * Target type for A_Extend decorator\n * \n * [!] Can be applied only on A-Components\n */\nexport type A_TYPES__FeatureExtendDecoratorTarget = A_Component | A_Container | A_Entity\n\n/**\n * Configuration type for A_Extend decorator\n * \n * This is an INPUT parameter provided by the user\n */\nexport type A_TYPES__FeatureExtendDecoratorConfig = {\n    /**\n     * Name of the container Lifecycle method to be extended.\n     * \n     * [!] If not provided will be used the name of the method.\n     * [!!] If name contains \".\" dot it will be considered as a path to the method.\n     */\n    name: string,\n    /**\n     * Container class or container name uses to identify the proper container in case when the name is not unique.\n     * \n     * [!] If not provided will be applied to all containers with the same name.\n     * [!!] By default uses OR to join all provided items. If you need more complex Logic, please use Regexp instead\n     * \n     * [!!!] In case if you need to exclude some containers, entities or components, please use \"exclude\" property\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      scope: {\n     *          include: [A_Container1, A_Entity1],\n     *          exclude: [A_Component1]\n     *      }\n     *  })\n     * ```\n     */\n    scope: Array<A_TYPES__FeatureExtendDecoratorScopeItem> | Partial<A_TYPES__FeatureExtendDecoratorScopeConfig>,\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: /Component2\\..+/\n     *  })\n     * ```\n     */\n    before: Array<string> | RegExp\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: /Component2\\..+/\n     *  })\n     * ```\n     * \n     */\n    after: Array<string> | RegExp\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: Array<string> | RegExp\n}\n/**\n * Scope item that can be used in A_Extend decorator configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeConfig = {\n    /**\n     * A list of components, entities or containers to include in the scope of the extension\n     */\n    include?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>,\n    /**\n     * A list of components, entities or containers to exclude from the scope of the extension\n     */\n    exclude?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>\n}\n/**\n * A single item that can be used in scope configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeItem = A_TYPES__Container_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Component_Constructor\n\n\n\n// =======================================================================\n// --------------------------META TYPES-----------------------------------\n// =======================================================================\n/**\n * Meta type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorMeta = {\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean,\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: string\n}\n\n\n","/**\n * A Meta is an entity that stores all the metadata for the specific entity like container, component, feature, etc. \n * \n * [!] Meta can be different depending on the type of input data\n */\nexport class A_Meta<\n    _StorageItems extends Record<string, any> = any,\n    _SerializedType extends Record<string, any> = Record<string, any>\n> implements Iterable<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n\n    protected meta: Map<keyof _StorageItems, _StorageItems[keyof _StorageItems]> = new Map();\n\n\n    /**\n     * Method to get the iterator for the meta object\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const iterator = this.meta.entries();\n        return {\n            next: () => iterator.next()\n        };\n    }\n\n\n\n    // ===================================================================================================\n    // ================================ META OPERATIONS ==================================================\n    // ===================================================================================================\n    /**\n     * Allows to replicate received meta object by replacing internal meta to the received one\n     * \n     * @param meta \n     * @returns \n     */\n    from(\n        meta: A_Meta<_StorageItems>\n    ): A_Meta<_StorageItems> {\n        this.meta = new Map(meta.meta);\n\n        return this;\n    }\n\n\n    /**\n     * Method to set values in the map\n     * \n     * @param key \n     * @param value \n     */\n    set<K extends keyof _StorageItems>(key: K, value: _StorageItems[K]) {\n\n        const inheritedValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? []\n            : (value as any) instanceof Map\n                ? new Map()\n                : {};\n        const targetValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? [\n                ...inheritedValue as any\n            ] : (value as any) instanceof Map\n                ? new Map(inheritedValue as any)\n                : { ...inheritedValue };\n\n        this.meta.set(key, value);\n\n    }\n\n\n\n    /**\n     * Method to get values from the map\n     * \n     * @param key \n     * @returns \n     */\n    get<K extends keyof _StorageItems>(key: K): _StorageItems[K] | undefined {\n        return this.meta.get(key) as _StorageItems[K];\n    }\n\n\n    /**\n     * Method to delete values from the map\n     * \n     * @param key \n     * @returns \n     */\n    delete(key: keyof _StorageItems): boolean {\n        return this.meta.delete(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    size(): number {\n        return this.meta.size;\n    }\n\n\n    /**\n     * This method is needed to convert the key to a regular expression and cover cases like: \n     * \n     * simple * e.g. \"a*\" instead of \"a.*\"\n     * \n     * simple ? e.g. \"a?\" instead of \"a.\"\n     * \n     * etc. \n     * \n     * @param key \n     * @returns \n     */\n    private convertToRegExp(key: string | RegExp): RegExp {\n        return key instanceof RegExp\n            ? key\n            : new RegExp(key);\n    }\n\n\n    /**\n     * Method to find values in the map by name.\n     * \n     * Converts the Key in Map to a regular expression and then compares to the name\n     * \n     * @param name \n     * @returns \n     */\n    find(name: string) {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (this.convertToRegExp(String(key)).test(name)) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to find values in the map by regular expression\n     * \n     * Compares Map Key to the input regular expression\n     * \n     * @param regex \n     * @returns \n     */\n    findByRegex(regex: RegExp): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (regex.test(String(key))) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to check if the map has a specific key\n     * \n     * @param key \n     * @returns \n     */\n    has(key: keyof _StorageItems): boolean {\n        return this.meta.has(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    entries(): IterableIterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return this.meta.entries();\n    }\n\n\n    /**\n     * Method to clear the map\n     */\n    clear(): void {\n        this.meta.clear();\n    }\n\n\n    toArray(): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return Array.from(this.meta.entries());\n    }\n\n\n    protected recursiveToJSON(value: any): any {\n        switch (true) {\n            case value instanceof A_Meta:\n                return value.toJSON();\n\n            case value instanceof Map:\n                const obj: Record<string, any> = {};\n                for (const [k, v] of value.entries()) {\n                    obj[String(k)] = this.recursiveToJSON(v);\n                }\n                return obj;\n\n            case Array.isArray(value):\n                return value.map((item) => this.recursiveToJSON(item));\n\n            case !!value && typeof value === 'object':\n                const res: Record<string, any> = {};\n                for (const [k, v] of Object.entries(value)) {\n                    res[k] = this.recursiveToJSON(v);\n                }\n                return res;\n\n            default:\n                return value;\n        }\n    }\n\n    /**\n     * Serializes the meta to a JSON object\n     * Uses internal storage to convert to JSON\n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        const json: Record<string, any> = {};\n\n        for (const [key, value] of this.meta.entries()) {\n            json[String(key)] = this.recursiveToJSON(value);\n        }\n        return json as _SerializedType;\n    }\n}","export enum A_TYPES__EntityMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    ABSTRACTIONS = 'a-component-abstractions',\n    INJECTIONS = 'a-component-injections',\n}\n\nexport enum A_TYPES__EntityFeatures {\n    SAVE = 'save',\n    DESTROY = 'destroy',\n    LOAD = 'load'\n}","export enum A_TYPES__ContainerMetaKey {\n    FEATURES = 'a-container-features',\n    INJECTIONS = 'a-container-injections',\n    ABSTRACTIONS = 'a-container-abstractions',\n    EXTENSIONS  = 'a-container-extensions',\n}","\n\n\nexport enum A_TYPES__ComponentMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    INJECTIONS = 'a-component-injections',\n    ABSTRACTIONS = 'a-component-abstractions',\n}","import { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/global/A-Inject/A-Inject.types\";\nimport { A_TYPES__ConceptAbstractionMeta } from \"../A-Concept/A-Concept.types\";\nimport { A_Meta } from \"../A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMeta, A_TYPES__ComponentMetaExtension } from \"./A-Component.types\";\nimport { A_TYPES__ComponentMetaKey } from \"./A-Component.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"../A-Feature/A-Feature.types\";\n\n\nexport class A_ComponentMeta extends A_Meta<A_TYPES__ComponentMeta> {\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ComponentMetaExtension[] {\n        const steps: A_TYPES__ComponentMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ComponentMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override:''\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n    /**\n     * Returns all features defined in the Component\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ComponentMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Component during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: any\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ComponentMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        // component: constructor,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n}","import { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_TYPES__Container_Init } from \"./A-Container.types\";\n\n\n\nexport class A_Container {\n\n    /**\n     * Configuration of the container that will be used to run it.\n     */\n    protected readonly config!: Partial<A_TYPES__Container_Init>;\n    /**\n     * Name of the container\n     */\n    get name() {\n        return this.config?.name || this.constructor.name;\n    }\n    /**\n     * Returns the scope where the container is registered\n     */\n    get scope(): A_Scope {\n        return A_Context.scope(this);\n    }\n\n\n    /**\n     * This class should combine Components to achieve the goal withing Concept\n     * \n     * Container is a direct container that should be \"run\" to make Concept work. \n     * So because of that Container can be:\n     * - HTTP Server\n     * - BASH Script\n     * - Database Connection\n     * - Microservice\n     * - etc.\n     * \n     * @param config - Configuration of the container that will be used to run it.\n     */\n    constructor(\n        /**\n         * Configuration of the container that will be used to run it.\n         */\n        config: Partial<A_TYPES__Container_Init> = {}\n    ) {\n        this.config = config;\n\n        A_Context.allocate(this, this.config);\n    }\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    async call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return await newFeature.process(scope);\n    }\n}","import { A_TYPES__ContainerMeta, A_TYPES__ContainerMetaExtension, } from \"./A-Container.types\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/global/A-Inject/A-Inject.types\";\nimport { A_TYPES__ConceptAbstraction, A_TYPES__ConceptAbstractionMeta } from \"../A-Concept/A-Concept.types\";\nimport { A_Meta } from \"../A-Meta/A-Meta.class\";\nimport { A_TYPES__ContainerMetaKey } from \"./A-Container.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"../A-Feature/A-Feature.types\";\nimport { A_TYPES__ConceptAbstractions } from \"../A-Concept/A-Concept.constants\";\n\n\n\nexport class A_ContainerMeta extends A_Meta<A_TYPES__ContainerMeta> {\n\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ContainerMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Container during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: A_TYPES__ConceptAbstractions\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ContainerMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ContainerMetaExtension[] {\n        const steps: A_TYPES__ContainerMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ContainerMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override: ''\n\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n}","\n/**\n * A_FormatterHelper\n * \n * Helper class for formatting strings into different cases.\n */\nexport class A_FormatterHelper {\n    /**\n     * Convert string to UPPER_SNAKE_CASE\n     * \n     * @param str \n     * @returns \n     */\n    static toUpperSnakeCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1_$2')  // Handle camelCase\n            .replace(/[^a-zA-Z0-9]+/g, '_')       // Replace non-alphanumeric with underscores\n            .replace(/_+/g, '_')                  // Collapse multiple underscores\n            .replace(/^_|_$/g, '')                // Remove leading/trailing underscores\n            .toUpperCase();\n    }\n    /**\n     * Convert string to camelCase\n     * \n     * @param str \n     * @returns \n     */\n    static toCamelCase(str: string): string {\n        return str\n            .trim()\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map((part, index) => {\n                if (index === 0) {\n                    return part.toLowerCase();\n                }\n                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n            })\n            .join('');\n    }\n    /**\n     * Convert string to PascalCase\n     * \n     * @param str \n     * @returns \n     */\n    static toPascalCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1 $2')  // Insert space before uppercase in camelCase\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n    /**\n     * Convert string to kebab-case\n     * \n     * @param str \n     * @returns \n     */\n    static toKebabCase(str: string): string {\n        return str\n            // 1. Replace all non-alphanumeric (underscore, dot, etc.) with a space\n            .replace(/[^a-zA-Z0-9]+/g, ' ')\n            // 2. Insert space before any uppercase preceded by lowercase or digit\n            .replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n            // 3. Trim spaces at both ends and replace remaining spaces with dashes\n            .trim()\n            .replace(/\\s+/g, '-')\n            // 4. Lowercase everything\n            .toLowerCase();\n    }\n}","\nexport type A_ID_TYPES__TimeId_Parts = {\n    timestamp: Date;\n    random: string;\n}\n\n\nexport class A_IdentityHelper {\n    /**\n   * Generates a short, time-based unique ID.\n   * Encodes current time (ms since epoch) and random bits in base36.\n   * Example: \"mb4f1g-7f9a1c\"\n   */\n    static generateTimeId(\n        parts: A_ID_TYPES__TimeId_Parts = { timestamp: new Date(), random: Math.random().toString(36).slice(2, 8) }\n    ): string {\n        const time = parts.timestamp.getTime().toString(36); // base36-encoded timestamp\n        const random = parts.random; // use provided random string\n        return `${time}-${random}`;\n    }\n\n    /**\n     * Parses a short ID back into its parts.\n     * Returns an object with the original timestamp (as Date) and random string.\n     */\n    static parseTimeId(id: string): A_ID_TYPES__TimeId_Parts {\n        const [timePart, randomPart] = id.split('-');\n        const timestamp = new Date(parseInt(timePart, 36));\n        return { timestamp, random: randomPart };\n    }\n\n\n    /**\n     *  Format a number with leading zeros to a fixed length\n     * \n     * @param number \n     * @param maxZeros \n     * @returns \n     */\n    static formatWithLeadingZeros(number, maxZeros = 10) {\n        const formattedNumber = String(number).padStart(maxZeros + 1, '0');\n        return formattedNumber.slice(-maxZeros);\n    }\n\n    /**\n     * Remove leading zeros from a formatted number\n     */\n    static removeLeadingZeros(formattedNumber) {\n        return String(Number(formattedNumber)); // Convert to number and back to string to remove leading zeros\n    }\n\n\n}","\n\n\nexport const A_CONSTANTS__ERROR_CODES = {\n    UNEXPECTED_ERROR: 'A-Error Unexpected Error',\n    VALIDATION_ERROR: 'A-Error Validation Error',\n} as const;\n\n\n\nexport const A_CONSTANTS__ERROR_DESCRIPTION = 'If you see this error please let us know.'","import {\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from './A_Error.types';\nimport {\n    A_CONSTANTS__ERROR_CODES,\n    A_CONSTANTS__ERROR_DESCRIPTION\n} from './A_Error.constants';\nimport { A_FormatterHelper } from '@adaas/a-concept/helpers/A_Formatter.helper';\nimport { A_Context } from '../A-Context/A-Context.class';\nimport { A_TypeGuards } from '@adaas/a-concept/helpers/A_TypeGuards.helper';\nimport { ASEID } from '../ASEID/ASEID.class';\nimport { A_CONSTANTS__DEFAULT_ENV_VARIABLES } from '@adaas/a-concept/constants/env.constants';\n\n\nexport class A_Error<\n    _ConstructorType extends A_TYPES__Error_Init = A_TYPES__Error_Init,\n    _SerializedType extends A_TYPES__Error_Serialized = A_TYPES__Error_Serialized\n> extends Error {\n    // ====================================================================\n    // ================== Static A-Error Information ======================\n    // ====================================================================\n    /**\n     * Error Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Namespace of the error from environment variable A_CONCEPT_NAMESPACE\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n    // ====================================================================\n    // ================== Hidden A-Error Information ======================\n    // ====================================================================\n    /**\n     * ASEID of the error instance\n     */\n    protected _aseid!: ASEID;\n    /**\n     * Title of the error\n     */\n    protected _title!: string;\n    /**\n     * Possible Scope if needed to identify the error by it's execution environment\n     */\n    protected _scope?: string;\n    /**\n     * Unique code representing the type of error\n     */\n    protected _code?: string;\n    /**\n     * Detailed description of the error\n     */\n    protected _description?: string;\n    /**\n     * Original Error if any\n     */\n    protected _originalError?: Error | any\n    /**\n     * Link to the documentation or support page for the error\n     */\n    protected _link?: string;\n\n\n\n    /**\n     * A_Error is a custom error class for A_Concept framework.\n     * This error allows to have more structured error handling.\n     * Each error has a unique code, description and a link to the documentation.\n     * \n     * Example of usage: \n     * ```typescript\n     * \n     * // 1) all parameters will be used as provided\n     * throw new A_Error({\n     *    message: 'User not found',\n     *    code: 'USER_NOT_FOUND',\n     *    description: 'The user with the given ID was not found.',\n     *    link: 'https://support.adaas.org/error/USER_NOT_FOUND'\n     * });\n     * \n     * // or\n     * // 2) only message is provided, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'User not found' (same as message)\n     * //     - link: Empty\n     * throw new A_Error('User not found');\n     * \n     * // or\n     * // 3) Provided Message and Description, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'The user with the given ID was not found.' (as provided)\n     * //     - link: Empty\n     * throw new A_Error('User not found', 'The user with the given ID was not found.');\n     * \n     * \n     * ```\n     * [!] Note: The behavior of A_Error is similar to the A_Entity however it cannot have own A_Features.\n     * [!] Note: This class can be inherited to create custom error classes.\n     * \n     * @param message \n     */\n    constructor(\n        /**\n         * A_Error Constructor params\n         */\n        params: _ConstructorType\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        message: string\n    )\n    constructor(\n        /**\n         * Original JS Error\n         */\n        error: Error\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        title: string,\n        /**\n         * Detailed description of the error\n         */\n        description: string\n    )\n    constructor(\n        param1: _ConstructorType | Error | string | A_Error,\n        param2?: string\n    ) {\n        //  to prevent errors accumulation in the stack trace it returns the original error if provided param1 is A_Error\n        switch (true) {\n            case param1 instanceof A_Error:\n                return param1 as A_Error<_ConstructorType, _SerializedType>;\n\n            case param1 instanceof Error:\n                super(param1.message);\n                break;\n\n            case A_TypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                super(param1.message);\n                break;\n\n            case A_TypeGuards.isErrorConstructorType<_ConstructorType>(param1) && 'description' in param1:\n                super(`[${param1.title}]: ${param1.description}`);\n                break;\n\n            case A_TypeGuards.isErrorConstructorType<_ConstructorType>(param1) && !('description' in param1):\n                super(param1.title);\n                break;\n\n            case A_TypeGuards.isString(param1) && !param2:\n                super(param1);\n                break;\n\n            case A_TypeGuards.isString(param1) && !!param2:\n                super(`[${param1}]: ${param2}`);\n                break;\n\n            default:\n                throw new A_Error(\n                    A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                    'Invalid parameters provided to A_Error constructor'\n                );\n        }\n\n        const initializer = this.getInitializer(param1, param2);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n\n\n    // ====================================================================\n    // ================== Public A-Error Information ======================\n    // ====================================================================\n    /**\n     * Returns the ASEID of the error instance\n     */\n    get aseid(): ASEID {\n        return this._aseid;\n    }\n    /**\n     * Returns the title of the error\n     * \n     * Example: 'User not found', 'Validation error', 'Unauthorized access', etc.\n     * \n     * [!] Note: This title should be short and concise, less than 60 characters\n     * [!] Note: If title exceeds 60 characters, there would be an error thrown\n     * [!] Note: This title is intended to be human-readable and can be displayed in UI or logs\n     */\n    get title(): string {\n        return this._title;\n    }\n    /**\n     * Returns an Error message what is a brief title of the error\n     * \n     */\n    get message(): string {\n        return super.message;\n    }\n    /**\n     * Returns a unique code representing the type of error\n     * \n     * If code is not provided, it will generate a kebab-case of the message\n     * \n     * Example: 'validation-error', 'not-found', 'user-not-found', 'unauthorized' etc.\n     * \n     * [!] Note: It is recommended to use kebab-case for error codes\n     * [!] Note: If not provided would be used a kebab-case message of the error\n     */\n    get code(): string {\n        return this._code || A_FormatterHelper.toKebabCase(this.title);\n    }\n    /**\n     * Returns the type of the error which corresponds to the static entity of the class\n     * \n     * Example: 'a-error', 'validation-error', 'not-found-error', 'user-error', etc.\n     * \n     * Defaults to the kebab-case of the class name\n     * \n     * [!] Note: naming ad separation are fully dependent on the architecture of the application\n     * [!] Note: It is recommended to use kebab-case for error types\n     * [!] Note: This type is intended to group similar errors together\n     */\n    get type() {\n        return (this.constructor as typeof A_Error).entity;\n    }\n    /**\n     * Returns a link with possible documentation or support page for the error\n     * If link is not provided, it will generate a link based on the ASEID of the error that points to the A-Concept support page\n     * \n     * Example: https://adaas.support/a-concept/errors/{ASEID}\n     * \n     * [!] Note: ASEID is generated based on the static properties of the class (concept, scope, entity) and the code of the error\n     */\n    get link() {\n        if (this._link)\n            return this._link;\n\n        const url = new URL(`https://adaas.support/a-concept/errors/${this.aseid.toString()}`);\n\n        return url.toString();\n    }\n    /**\n     * The scope name of the error instance\n     * \n     * If scope is not provided, it will use the static scope of the class\n     * \n     * [!] Note: Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    get scope() {\n        return this._aseid.scope\n    }\n    /**\n     * A detailed description of the error\n     * If description is not provided, it will use the environment variable A_ERROR_DEFAULT_DESCRIPTION or a generic message\n     * \n     * Example: 'The user with the given ID was not found.', 'The provided data is invalid.', 'You do not have permission to access this resource.', etc.\n     * \n     * [!] Note: This description is intended to provide more context about the error and can be used for debugging or logging purposes\n     */\n    get description(): string {\n        return this._description || process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_ERROR_DEFAULT_DESCRIPTION] || A_CONSTANTS__ERROR_DESCRIPTION;\n    }\n    /**\n     * Returns the original error if any\n     * \n     * This can be useful for debugging purposes to see the original stack trace or error message\n     * \n     * [!] Note: Original error is optional and may not be present in all cases\n     */\n    get originalError(): Error | any | undefined {\n        return this._originalError;\n    }\n\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1: _ConstructorType | Error | string | any,\n        param2?: string\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n\n            case A_TypeGuards.isString(param1) && !param2:\n                return this.fromMessage;\n\n            case A_TypeGuards.isString(param1) && !!param2:\n                return this.fromTitle;\n\n            case param1 instanceof Error:\n                return this.fromError;\n\n            case A_TypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                return this.fromJSON;\n\n            case A_TypeGuards.isErrorConstructorType<_ConstructorType>(param1):\n                return this.fromConstructor;\n\n            default: {\n                throw new A_Error(\n                    A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                    'Invalid parameters provided to A_Error constructor'\n                );\n            }\n        }\n    }\n\n    /**\n     * Initializes the A_Error instance from a standard Error object.\n     * \n     * @param error \n     */\n    protected fromError(error: Error): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._originalError = error;\n    }\n    /**\n     * Initializes the A_Error instance from a message.\n     * \n     * @param title \n     * @param description \n     */\n    protected fromMessage(message: string): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a serialized object.\n     * \n     * @param serialized\n     */\n    protected fromJSON(serialized: _SerializedType): void {\n        this._aseid = new ASEID(serialized.aseid);\n        super.message = serialized.message;\n        this._title = serialized.title;\n        this._code = serialized.code;\n        this._scope = serialized.scope;\n        this._description = serialized.description;\n        // Note: originalError is deserialized as message only\n        this._originalError = serialized.originalError ? new A_Error(serialized.originalError) : undefined;\n        this._link = serialized.link;\n    }\n\n\n\n    fromTitle(title: string, description: string): void {\n        this.validateTitle(title);\n\n        this._title = title;\n        this._description = description;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a constructor parameters object.\n     * \n     * @param params \n     */\n    protected fromConstructor(params: _ConstructorType): void {\n        this.validateTitle(params.title);\n\n        this._title = params.title;\n        this._code = params.code;\n        this._scope = params.scope ? (A_TypeGuards.isScopeInstance(params.scope) ? params.scope.name : params.scope) : undefined;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._description = params.description;\n        this._link = params.link;\n\n        // Handle originalError: if it's an A_Error, we should trace back to the root cause\n        // to avoid infinite nesting of A_Error instances\n        if (params.originalError instanceof A_Error) {\n            // Find the root original error by traversing the chain\n            let rootError = params.originalError;\n            while (rootError.originalError instanceof A_Error) {\n                rootError = rootError.originalError;\n            }\n            // Set the root cause as the original error\n            this._originalError = rootError.originalError || rootError;\n        } else {\n            this._originalError = params.originalError;\n        }\n    }\n\n    /**\n     * Serializes the A_Error instance to a plain object.\n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString(),\n            title: this.title,\n            code: this.code,\n            type: this.type,\n            message: this.message,\n            link: this.link,\n            scope: this.scope,\n            description: this.description,\n            originalError: this.originalError?.message\n        } as _SerializedType;\n    }\n\n\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n    /**\n     * Checks if the provided title exceeds 60 characters.\n     * If it does, throws a validation A_Error.\n     * \n     * @param title \n     */\n    protected validateTitle(title: string) {\n        if (title.length > 60) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title exceeds 60 characters limit.'\n            );\n        }\n        if (title.length === 0) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title cannot be empty.'\n            );\n        }\n    }\n}\n\n\n\n\n\n// message = title + description for better printing in the console\n// description = detailed information about the error\n// code = kebabcase (title)\n\n","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\n\nexport class ASEID_Error extends A_Error {\n\n\n    static readonly ASEIDInitializationError = 'ASEID Initialization Error';\n    \n    static readonly ASEIDValidationError = 'ASEID Validation Error';\n\n}","import {\n    A_TYPES__ASEID_Constructor,\n    A_TYPES__ASEID_JSON\n} from \"./ASEID.types\";\nimport { A_IdentityHelper } from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { ASEID_Error } from \"./ASEID.error\";\nimport { A_TYPES__Required } from \"@adaas/a-concept/types/A_Common.types\";\n\n\n\nexport class ASEID {\n\n\n    //==========================================================================\n    //============================= STATIC METHODS ===========================\n    //==========================================================================\n    /**\n     * ASEID Regular Expression\n     */\n    static readonly regexp: RegExp = new RegExp(`^[a-z|A-Z|0-9|-]+@[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\\\.|-]+(@v[0-9|\\\\.]+|@lts)?$`)\n    /**\n     * Tests if the identity string is an ASEID\n     * \n     * @param identity \n     * @returns \n     */\n    static isASEID(identity: string): boolean {\n        return this.regexp.test(identity)\n    }\n\n\n\n    // ====================================================================\n    // ==================== Hidden ASEID Information ======================\n    // ====================================================================\n    /**\n     * Concept for the ASEID\n     * Generally it is the application name or code, should correspond to the concept where the entity is used\n     * Could be ID or ASEID\n     */\n    private _concept!: string;\n    /**\n     * Entity Scope the primary location of the resource \n     * Organization, or organization Unit\n     * Could be ID or ASEID\n     * \n     */\n    private _scope!: string\n    /**\n     * Entity Type the type of the resource\n     */\n    private _entity!: string\n    /**\n     * Entity ID the unique identifier of the resource\n     */\n    private _id!: string\n    /**\n     * Version of the entity (optional)\n     */\n    private _version?: string\n    /**\n     * Shard of the entity (optional)\n     */\n    private _shard?: string\n\n\n\n\n\n\n    /**\n     * ASEID is a structured identifier for entities in the A-Concept system. \n     * using the format:\n     *  A - A-Concept\n     *  S - System \n     *  E - Entity\n     *  I - Identifier\n     *  D - iDentifier\n     * \n     * Structure: CONCEPT_NAME + @ + SCOPE + : ENTITY_NAME + : + ID + @ + VERSION \n     * \n     * Example:\n     *  - root@core:usr:0000000001\n     * \n     * [!] Concept is optional, if not provided will be used the current concept name\n     * [!] Scope is optional, if not provided will be used the root scope of the current concept\n     * [!] Version is optional, if not provided will be considered as latest version\n     * \n     * @param aseid - ASEID string representation or ASEID components as object\n     */\n    constructor(\n        /**\n         * ASEID string representation\n         */\n        aseid: string\n    )\n    constructor(\n        /**\n         * ASEID components as object \n         */\n        props: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    )\n    constructor(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this.verifyInput(param1);\n\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1);\n    }\n\n    /**\n     * Getters for ASEID components\n     */\n    get concept(): string {\n        return this._concept || A_Context.concept;\n    }\n    /**\n     * Get the scope of the ASEID\n     */\n    get scope(): string {\n        return this._scope || A_Context.root.name;\n    }\n    /**\n     * Get the entity of the ASEID\n     */\n    get entity(): string {\n        return this._entity;\n    }\n    /**\n     * Get the id of the ASEID\n     */\n    get id(): string {\n        return this._id;\n    }\n    /**\n     * Get the version of the ASEID (if any)\n     */\n    get version(): string | undefined {\n        return this._version;\n    }\n    /**\n     * Get the shard of the ASEID (if any)\n     */\n    get shard(): string | undefined {\n        return this._shard;\n    }\n\n    /**\n     * get Internal Initializer based on the type of the parameter provided\n     * \n     * @param param1 \n     * @returns \n     */\n    private getInitializer(\n        param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    ): (param1: any) => void | (() => void) {\n        switch (true) {\n            case A_TypeGuards.isString(param1):\n                return this.fromString;\n\n            case A_TypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1):\n                return this.fromObject;\n\n            default:\n                throw new ASEID_Error(\n                    ASEID_Error.ASEIDInitializationError,\n                    'Invalid parameters provided to ASEID constructor'\n                );\n        }\n    }\n\n\n    /**\n     * Initialize ASEID from string\n     * \n     * @param param1 \n     */\n    private fromString(param1: string) {\n        const [concept, body, version] = param1.split('@');\n        const [scope, entity, idCandidate] = body.split(':');\n\n        const shard = idCandidate.includes('.') ? idCandidate.split('.')[0] : undefined;\n        const id = idCandidate.includes('.') ? idCandidate.split('.')[1] : idCandidate;\n\n        this._concept = concept || A_Context.root.name;\n        this._scope = scope || A_Context.root.name;\n        this._entity = entity;\n        this._id = id;\n        this._version = version;\n        this._shard = shard;\n    }\n    /**\n     * Initialize ASEID from object\n     * \n     * @param param1 \n     */\n    private fromObject(param1: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this._concept = param1.concept\n            ? ASEID.isASEID(param1.concept)\n                ? new ASEID(param1.concept).id\n                : param1.concept\n            : A_Context.concept;\n\n        this._scope = param1.scope\n            ? A_TypeGuards.isNumber(param1.scope)\n                ? A_IdentityHelper.formatWithLeadingZeros(param1.scope) :\n                ASEID.isASEID(param1.scope)\n                    ? new ASEID(param1.scope).id\n                    : param1.scope\n            : A_Context.root.name\n\n        this._entity = param1.entity;\n\n        this._id = A_TypeGuards.isNumber(param1.id)\n            ? A_IdentityHelper.formatWithLeadingZeros(param1.id)\n            : param1.id;\n\n        this._version = param1.version;\n        this._shard = param1.shard;\n    }\n\n\n    /**\n     * String representation of the ASEID\n     * \n     * @returns \n     */\n    toString(): string {\n        return `${this.concept}@${this.scope}:${this.entity}:${this.shard ? (this.shard + '.' + this.id) : this.id}${this.version ? ('@' + this.version) : ''}`\n    }\n\n    /**\n     * JSON representation of the ASEID\n     * \n     * @returns \n     */\n    toJSON(): A_TYPES__ASEID_JSON {\n        return {\n            concept: this._concept,\n            scope: this._scope,\n            entity: this._entity,\n            id: this._id,\n            version: this._version,\n            shard: this._shard\n        }\n    }\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n\n\n    protected verifyInput(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n\n        switch (true) {\n            // 1) check for string and validate it as ASEID\n            case A_TypeGuards.isString(param1) && !ASEID.isASEID(param1):\n                throw new ASEID_Error(ASEID_Error.ASEIDValidationError, 'Invalid ASEID format provided')\n\n            // 2) check for object and validate required fields\n            case A_TypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.id:\n                throw new ASEID_Error(ASEID_Error.ASEIDValidationError, 'ASEID id is required')\n\n            // 3) check for object and validate required fields\n            case A_TypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.entity:\n                throw new ASEID_Error(ASEID_Error.ASEIDValidationError, 'ASEID entity is required')\n\n        }\n    }\n}","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\n\nexport class A_EntityError extends A_Error {\n\n    /**\n     * Error code for validation errors.\n     */\n    static readonly ValidationError = 'A-Entity Validation Error';\n\n}","import {\n    A_TYPES__Entity_Serialized,\n    A_TYPES__Entity_Init,\n    A_TYPES__IEntity,\n} from \"./A-Entity.types\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_FormatterHelper } from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { ASEID } from \"../ASEID/ASEID.class\";\nimport { A_IdentityHelper } from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport { A_EntityError } from \"./A-Entity.error\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_TYPES__ASEID_Constructor } from \"../ASEID/ASEID.types\";\n\n\n/**\n * A_Entity is another abstraction that describes all major participants in the system business logic.\n * Each Entity should have a clear definition and a clear set of responsibilities. \n * However, entity may hide some of its responsibilities behind the interface to prevent overload. \n * \n * Each entity should be connected to the ContextFragment (Scope) and should be able to communicate with other entities.\n */\nexport class A_Entity<\n    _ConstructorType extends A_TYPES__Entity_Init = A_TYPES__Entity_Init,\n    _SerializedType extends A_TYPES__Entity_Serialized = A_TYPES__Entity_Serialized\n>\n    implements A_TYPES__IEntity {\n\n    // ====================================================================\n    // ================== Static A-Entity Information ============================\n    // ====================================================================\n    /**\n     * Entity Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Concept Name (Application Name) of the entity from environment variable A_CONCEPT_NAME\n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n\n\n    // ====================================================================\n    // ================== Instance A-Entity Information ====================\n    // ====================================================================\n\n    /**\n     * ASEID is an entity identifier that is unique across the system\n     * A - A_Concept or Application\n     * S - System or Scope\n     * E - Entity\n     * ID - Identifier\n     * \n     * [!] ASEID is immutable and should not be changed after the entity is created\n     * \n     * [!] ASEID is composed of the following parts:\n     * - concept: an application specific identifier from where the entity is coming from\n     * - scope: the scope of the entity from concept\n     * - entity: the name of the entity from concept\n     * - id: the unique identifier of the entity\n     *\n     * [!] For more information about ASEID, please refer to the ASEID class documentation]\n     */\n    aseid!: ASEID;\n\n\n\n    /**\n     * Create a new A_entity instance from Aseid String\n     * e.g. project@scope:entity:0000000001\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID string that represents the entity\n         */\n        aseid?: string\n    )\n    /**\n     * Create a new A_entity instance from Aseid instance\n     * e.g. new ASEID({concept: 'project', scope: 'default', entity: 'entity', id: '0000000001'})\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID instance that represents the entity\n         */\n        aseid: ASEID\n    )\n    /**\n     * Create a new A_entity instance from serialized object\n     * \n     * @param serialized \n     */\n    constructor(\n        /**\n         * Serialized object that represents the entity\n         */\n        serialized: _SerializedType\n    )\n    /**\n     * Create a new A_entity instance from constructor object\n     * \n     * @param newEntity \n     */\n    constructor(\n        /**\n         * Constructor object that represents the entity\n         */\n        newEntity?: _ConstructorType\n    )\n    constructor(props?: string | ASEID | _SerializedType | _ConstructorType) {\n\n        const initializer = this.getInitializer(props);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, props);\n    }\n    // ====================================================================\n    // ================== DUPLICATED ASEID Getters ========================\n    // ====================================================================\n\n    /**\n     * Extracts the ID from the ASEID\n     * ID is the unique identifier of the entity\n     */\n    get id(): string | number {\n        return this.aseid.id;\n    }\n\n    // ====================================================================\n    // ================== Constructor Helpers =============================\n    // ====================================================================\n\n\n    // --- Type guards used to classify `props` properly ---\n    protected isStringASEID(x: unknown): x is string {\n        return typeof x === \"string\" && ASEID.isASEID(x);\n    }\n\n    protected isASEIDInstance(x: unknown): x is ASEID {\n        return x instanceof ASEID;\n    }\n\n    /**\n     * A \"serialized\" object is considered such if it is a non-null object \n     * and contains an \"aseid\" property (this mirrors your original check). \n     * \n     * @param x \n     * @returns \n     */\n    protected isSerializedObject(x: unknown): x is _SerializedType {\n        return !!x && typeof x === \"object\" && \"aseid\" in (x as object);\n    }\n\n    /**\n     * Constructor-style props = a plain object which does NOT contain \"aseid\".\n     * This is the \"create from provided fields\" case.\n     * \n     * @param x \n     * @returns \n     */\n    protected isConstructorProps(x: unknown): x is _ConstructorType {\n        return !!x && typeof x === \"object\" && !(\"aseid\" in (x as object));\n    }\n\n    /**\n     * Determines the appropriate initializer method based on the type of `props`.\n     * The method checks if `props` is:  \n     * 1) a string that matches ASEID format -> fromASEID\n     * 2) an ASEID instance -> fromASEID\n     * 3) a serialized object (has 'aseid') -> fromJSON\n     * 4) a plain object with no 'aseid' -> treat as constructor props -> fromNew\n     * \n     * [!] If `props` is undefined, it will call fromUndefined method\n     * \n     * If none of the above, it throws an error indicating incorrect constructor usage.\n     * \n     * \n     * To get a custom initializer, override this method in the child class.\n     * Example:\n     * ```typescript\n     * protected getInitializer(\n     *   props?: string | ASEID | _SerializedType | _ConstructorType\n     * ): (props: any) => void | (() => void) {\n     *   if('customField' in props) {\n     *       return this.fromCustomField.bind(this);\n     *   }\n     *   return super.getInitializer(props);\n     * }\n     * ```\n     * @param props\n     * @returns The appropriate initializer method\n     */\n    protected getInitializer(\n        props?: string | ASEID | _SerializedType | _ConstructorType\n    ): (props: any) => void | (() => void) {\n\n        if (!props) {\n            return this.fromUndefined\n        }\n\n        // 1) string that matches ASEID format -> fromASEID\n        if (this.isStringASEID(props)) {\n            return this.fromASEID as (p: string) => void;\n        }\n\n        // 2) ASEID instance -> fromASEID\n        if (this.isASEIDInstance(props)) {\n            return this.fromASEID as (p: ASEID) => void;\n        }\n\n        // 3) serialized object (has 'aseid') -> fromJSON\n        if (this.isSerializedObject(props)) {\n            return this.fromJSON as (p: _SerializedType) => void;\n        }\n\n        // 4) plain object with no 'aseid' -> treat as constructor props -> fromNew\n        if (this.isConstructorProps(props)) {\n            return this.fromNew as (p: _ConstructorType) => void;\n        }\n\n        // none of the above -> throw consistent error\n        throw new A_EntityError(A_EntityError.ValidationError, 'Unable to determine A-Entity constructor initialization method. Please check the provided parameters.');\n    }\n\n    /**\n     * Generates a new ASEID for the entity. \n     * It uses class definitions for concept, scope, and entity,\n     * and allows overriding any of these values.\n     * \n     * @param override \n     * @returns \n     */\n    protected generateASEID(override?: Partial<A_TYPES__ASEID_Constructor>): ASEID {\n        return new ASEID({\n            concept: override?.concept || (this.constructor as typeof A_Entity).concept,\n            scope: override?.scope || (this.constructor as typeof A_Entity).scope,\n            entity: override?.entity || (this.constructor as typeof A_Entity).entity,\n            id: override?.id || A_IdentityHelper.generateTimeId()\n        });\n    }\n\n\n    /**\n     * Call a feature of the component with the provided scope\n     * \n     * [!] If the provided scope is not inherited from the entity scope, it will be inherited\n     * \n     * @param lifecycleMethod \n     * @param args \n     */\n    async call(\n        feature: string,\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this,\n            scope\n        });\n\n        return await newFeature.process(scope);\n    }\n\n\n    // ====================================================================\n    // ================== Entity Base Methods =============================\n    // ====================================================================\n\n    /**\n     * The default method that can be called and extended to load entity data.\n     */\n    async load(\n        scope?: A_Scope,\n    ) {\n        return this.call('load', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to destroy entity data.\n     */\n    async destroy(scope?: A_Scope) {\n        return this.call('destroy', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to save entity data.\n     */\n    async save(scope?: A_Scope) {\n        return this.call('save', scope);\n    }\n\n\n\n    // ====================================================================\n    // ================== Entity Serialization ============================\n    // ====================================================================\n\n    /**\n     * Create a new entity from ASEID string or instance\n     * [!] Executed when the constructor is called with a string or ASEID instance that represents the ASEID\n     * [!] Executes By Default with new A_Entity('aseid-string') or new A_Entity(new ASEID(...)) if getInitializer has not been overridden\n     * \n     * @param aseid \n     */\n    fromASEID(aseid: string | ASEID): void {\n        if (aseid instanceof ASEID)\n            this.aseid = aseid;\n        else\n            this.aseid = new ASEID(aseid);\n    }\n\n    /**\n     * Handles the case when no props are provided to the constructor.\n     * This method can be overridden in child classes to set default values or perform specific initialization logic.\n     * By default, it does nothing.\n     * \n     * \n     * @returns \n     */\n    fromUndefined(): void {\n        this.aseid = this.generateASEID();\n        \n        return;\n    }\n\n    /**\n     * Create a new entity from constructor object\n     * [!] Executed when the constructor is called with an object that does not contain \"aseid\" property\n     * [!] Executes By Default with new A_Entity({}) if getInitializer has not been overridden\n     * \n     * @param newEntity \n     * @returns \n     */\n    fromNew(newEntity: _ConstructorType): void {\n        this.aseid =  this.generateASEID();\n\n        return;\n    }\n\n\n    /**\n     * Creates a new entity from serialized object\n     * \n     * [!] Executed when the constructor is called with an object that contains \"aseid\" property\n     * [!] Executes By Default with new A_Entity({ aseid: '...' }) if getInitializer has not been overridden\n     * \n     * \n     * @param serialized \n     * @returns \n     */\n    fromJSON(serialized: _SerializedType): void {\n        this.aseid = new ASEID(serialized.aseid);\n        return;\n    }\n\n\n\n    /**\n     * Converts the entity to a JSON object \n     * [!] This method should be extended in the child classes to include all properties of the entity\n     * [!] Includes aseid by default \n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString()\n        } as _SerializedType;\n    }\n\n\n    /**\n     * Returns the string representation of the entity\n     * what is basically the ASEID string\n     * \n     * @returns \n     */\n    toString(): string {\n        return this.aseid ? this.aseid.toString() : this.constructor.name;\n    }\n}","import { A_Meta } from \"../A-Meta/A-Meta.class\";\nimport { A_TYPES__EntityMeta } from \"./A-Entity.types\";\nimport { A_TYPES__EntityMetaKey } from \"./A-Entity.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"../A-Feature/A-Feature.types\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"../A-Inject/A-Inject.types\";\n\n\nexport class A_EntityMeta extends A_Meta<A_TYPES__EntityMeta> {\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__EntityMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__EntityMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n}","import { A_TYPES__DeepPartial } from \"@adaas/a-concept/types/A_Common.types\";\nimport { A_Meta } from \"../A-Meta/A-Meta.class\";\nimport { A_TYPES__Fragment_Init, A_TYPES__Fragment_Serialized } from \"./A-Fragment.types\";\n\n\n/**\n * A_Fragment is a core architectural component that represents a singleton execution context\n * within the A-Concept framework. It serves as a shared memory container that can be passed\n * between Components, Entities, and Commands throughout the application pipeline.\n * \n * Key Features:\n * - Singleton pattern: Only one instance per fragment type per scope\n * - Meta storage: Built-in key-value storage for pipeline data\n * - Type-safe: Full TypeScript generics support for meta items and serialization\n * - Serializable: Can be converted to JSON for persistence or transmission\n * \n * @template _MetaItems - Type definition for the meta storage structure\n * @template _SerializedType - Type definition for the serialized output format\n * \n * @example\n * ```typescript\n * // Basic usage with typed meta\n * class UserFragment extends A_Fragment<{ userId: string; role: string }> {\n *   constructor() {\n *     super({ name: 'UserFragment' });\n *   }\n * }    \n * \n * // Custom serialization\n * class SessionFragment extends A_Fragment<\n *   { sessionId: string; timestamp: number },\n *   { name: string; sessionData: string }\n * > {\n *   toJSON() {\n *     return {\n *       name: this.name,\n *       sessionData: `${this.get('sessionId')}-${this.get('timestamp')}`\n *     };\n *   }\n * }\n * ```\n */\nexport class A_Fragment<\n    _SerializedType extends A_TYPES__Fragment_Serialized = A_TYPES__Fragment_Serialized\n> {\n    /**\n     * The unique identifier/name for this fragment instance.\n     * Used for identification and debugging purposes.\n     */\n    protected _name: string;\n\n    /**\n     * Creates a new A_Fragment instance.\n     * \n     * A_Fragment implements the singleton pattern for execution contexts, allowing\n     * shared state management across different parts of the application pipeline.\n     * Each fragment serves as a memory container that can store typed data and be\n     * serialized for persistence or transmission.\n     * \n     * Key Benefits:\n     * - Centralized state management for related operations\n     * - Type-safe meta operations with full IntelliSense support\n     * - Serialization support for data persistence \n     * - Singleton pattern ensures consistent state within scope\n     * \n     * @param params - Initialization parameters\n     * @param params.name - Optional custom name for the fragment (defaults to class name)\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string }>({ \n     *   name: 'UserSessionFragment' \n     * });\n     * fragment.set('userId', '12345');\n     * ```\n     */\n    constructor(params: Partial<A_TYPES__Fragment_Init> = {}) {\n        this._name = params.name || this.constructor.name;\n    }\n\n    /**\n     * Gets the fragment's unique name/identifier.\n     * \n     * @returns The fragment name\n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Serializes the fragment to a JSON-compatible object.\n     * \n     * This method combines the fragment's name with all meta data to create\n     * a serializable representation. The return type is determined by the\n     * _SerializedType generic parameter, allowing for custom serialization formats.\n     * \n     * @returns A serialized representation of the fragment\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string, role: string }>({\n     *   name: 'UserFragment'\n     * });\n     * fragment.set('userId', '12345');\n     * fragment.set('role', 'admin');\n     * \n     * const json = fragment.toJSON();\n     * // Result: { name: 'UserFragment', userId: '12345', role: 'admin' }\n     * ```\n     */\n    toJSON(): _SerializedType {\n        const result = {\n            name: this.name,\n        };\n\n        return result as _SerializedType;\n    }\n}","import { A_TYPES__DeepPartial } from \"../types/A_Common.types\";\n\nexport class A_CommonHelper {\n\n    /**\n     * A simple promise that resolves immediately.\n     * Can be used in async functions to create a resolved promise.\n     */\n    static resolve() {\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    /**\n     * Check if a class is inherited from another class\n     * \n     * @param childClass \n     * @param parentClass \n     * @returns \n     */\n    static isInheritedFrom(childClass: any, parentClass: any): boolean {\n        let current = childClass;\n\n        // Traverse the prototype chain\n        while (current) {\n            if (current === parentClass) {\n                return true;\n            }\n            current = Object.getPrototypeOf(current);\n        }\n        return false;\n    }\n\n\n    /**\n     * Get all parent classes of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClasses(childClass: any): any[] {\n\n        // first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        const parents = [] as any[];\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            parents.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return parents;\n\n    }\n\n    /**\n     * Get the class inheritance chain as an array of class names\n     * \n     * @param childClass \n     * @returns \n     */\n    static getClassInheritanceChain(childClass: any): any[] {\n\n        //  first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        //  then if input is instance we have to include its own class name\n        const chain = typeof childClass === 'function'\n            ? [childClass]\n            : [childClass.constructor];\n\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            chain.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return chain;\n    }\n\n    /**\n     * Get the parent class of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClass(childClass: any): any {\n        return Object.getPrototypeOf(childClass);\n    }\n\n    /**\n     *  Omit properties from an object or array with nested objects\n     * \n     * @param input \n     * @param paths \n     * @returns \n     */\n    static omitProperties<T, S extends string>(\n        input: T,\n        paths: string[]\n\n    ): Omit<T, S> {\n\n        // Deep clone the input object or array\n        const result = JSON.parse(JSON.stringify(input));\n\n        // Helper function to recursively remove properties\n        function removeProperties(target: Record<string, any> | any[], currPath: string[]) {\n            const currKey = currPath[0];\n            if (currPath.length === 1) {\n                // If current path has only one key, delete the property\n                delete target[currKey];\n            } else if (target[currKey] !== undefined && typeof target[currKey] === 'object') {\n                // If current key exists and is an object, recursively call removeProperties\n                removeProperties(target[currKey], currPath.slice(1));\n            }\n        }\n\n        // Iterate through each path and remove corresponding properties from the result\n        paths.forEach(path => {\n            const pathKeys = path.split('.');\n            removeProperties(result, pathKeys);\n        });\n\n        return result as Omit<T, S>;\n    }\n\n\n    static isObject(item: unknown): item is Record<string, any> {\n        return item !== null && typeof item === 'object' && !Array.isArray(item);\n    }\n\n    static deepMerge<T = any>(target: any, source: any, visited = new Map<any, any>()): T {\n        if (this.isObject(target) && this.isObject(source)) {\n            for (const key in source) {\n                if (this.isObject(source[key])) {\n                    if (!target[key]) {\n                        target[key] = {};\n                    }\n                    // Check if the source object has already been visited\n                    if (!visited.has(source[key])) {\n                        visited.set(source[key], {});\n                        this.deepMerge(target[key], source[key], visited);\n                    } else {\n                        target[key] = visited.get(source[key]);\n                    }\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    }\n\n\n    static deepClone<T>(target: T): T {\n        // Check if the value is null or undefined\n        if (target === null || target === undefined) {\n            return target;\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target;\n        }\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepClone(item)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (target.hasOwnProperty(key)) {\n                    clone[key] = this.deepClone(target[key]);\n                }\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n\n    static deepCloneAndMerge<T>(target: A_TYPES__DeepPartial<T>, source: T): T {\n        if (\n            (source === null || source === undefined) &&\n            (target === null || target === undefined))\n            return target;\n\n        // Check if the value is null or undefined\n        if ((target === null || target === undefined) &&\n            source\n        ) {\n            return this.deepClone(source);\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target\n        }\n\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepCloneAndMerge(item, source)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (\n                    source[key] !== null\n                    &&\n                    source[key] !== undefined\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key as any], source[key]);\n                else\n                    clone[key as any] = this.deepClone(target[key]);\n            }\n\n            for (const key in source) {\n                if (\n                    target[key] !== undefined\n                    &&\n                    target[key] !== null\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key], source[key]);\n                else\n                    clone[key] = this.deepClone(source[key]);\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n    /**\n     * Get a readable name for a component (string, class, function, React element, instance, etc.)\n     *\n     * Covers:\n     * - string tags (\"div\")\n     * - symbols (Symbol.for('xxx'))\n     * - functions and classes (with name or displayName)\n     * - React elements (object with `type`)\n     * - component instances (constructor.name)\n     * - objects with custom toString returning meaningful info\n     *\n     * Falls back to sensible defaults (\"Unknown\" / \"Anonymous\").\n     */\n    static getComponentName(component: any): string {\n        const UNKNOWN = 'Unknown';\n        const ANONYMOUS = 'Anonymous';\n\n        if (component === null || component === undefined) {\n            return UNKNOWN;\n        }\n\n        // Strings (HTML tags or explicit names)\n        if (typeof component === 'string') {\n            return component || UNKNOWN;\n        }\n\n        // Symbols\n        if (typeof component === 'symbol') {\n            try {\n                return component.toString();\n            } catch {\n                return UNKNOWN;\n            }\n        }\n\n        // Arrays - try to derive from first element\n        if (Array.isArray(component)) {\n            if (component.length === 0) return UNKNOWN;\n            return this.getComponentName(component[0]);\n        }\n\n        // Functions and classes\n        if (typeof component === 'function') {\n            const fnAny = component as any;\n            // Common React convention\n            if (fnAny.displayName) return String(fnAny.displayName);\n            if (fnAny.name) return String(fnAny.name);\n\n            // Try to extract a name from source if possible\n            try {\n                const src = Function.prototype.toString.call(component);\n                // class Foo { ... } or function foo() { ... } or foo => ...\n                const match = src.match(/^(?:class\\s+([A-Za-z0-9_$]+)|function\\s+([A-Za-z0-9_$]+)|([A-Za-z0-9_$]+)\\s*=>)/);\n                if (match) {\n                    return match[1] || match[2] || match[3] || ANONYMOUS;\n                }\n            } catch {\n                // fallthrough\n            }\n            return ANONYMOUS;\n        }\n\n        // Objects (instances, React elements, plain objects)\n        if (typeof component === 'object') {\n            const objAny = component as any;\n\n            // React element: { type: ComponentOrString, props: ... }\n            if (objAny.type) {\n                return this.getComponentName(objAny.type);\n            }\n\n            // React forwardRef / memo wrappers often expose displayName\n            if (objAny.displayName) return String(objAny.displayName);\n            if (objAny.name) return String(objAny.name);\n\n            // Instance: use constructor name if available and not Object\n            if (objAny.constructor && objAny.constructor.name && objAny.constructor.name !== 'Object') {\n                return String(objAny.constructor.name);\n            }\n\n            // If object implements a meaningful toString, try it\n            try {\n                const s = objAny.toString();\n                if (typeof s === 'string' && s !== '[object Object]') {\n                    return s;\n                }\n            } catch {\n                // ignore\n            }\n\n            return ANONYMOUS;\n        }\n\n        // Fallback for other types\n        try {\n            return String(component);\n        } catch {\n            return UNKNOWN;\n        }\n    }\n}","import { A_Error } from \"../A-Error/A_Error.class\";\n\nexport class A_ScopeError extends A_Error {\n\n\n    static readonly InitializationError = 'A-Scope Initialization Error';\n\n    static readonly ConstructorError = 'Unable to construct A-Scope instance';\n\n    static readonly ResolutionError = 'A-Scope Resolution Error';\n\n    static readonly RegistrationError = 'A-Scope Registration Error';\n\n    static readonly CircularInheritanceError = 'A-Scope Circular Inheritance Error';\n\n    static readonly DeregistrationError = 'A-Scope Deregistration Error';\n}","import {\n    A_TYPES__ScopeConfig,\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES__ScopeResolvableComponents,\n    A_TYPES__Scope_Constructor,\n    A_TYPES__ScopeLinkedConstructors\n} from './A-Scope.types'\nimport {\n    A_TYPES__A_InjectDecorator_EntityInjectionInstructions,\n    A_TYPES__A_InjectDecorator_EntityInjectionQuery,\n    A_TYPES__InjectableConstructors,\n} from \"@adaas/a-concept/global/A-Inject/A-Inject.types\";\nimport { A_Fragment } from \"../A-Fragment/A-Fragment.class\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Component } from \"../A-Component/A-Component.class\";\nimport { A_Entity } from \"../A-Entity/A-Entity.class\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_Error } from \"../A-Error/A_Error.class\";\nimport { A_FormatterHelper } from '@adaas/a-concept/helpers/A_Formatter.helper';\nimport { ASEID } from '../ASEID/ASEID.class';\nimport { A_CommonHelper } from '@adaas/a-concept/helpers/A_Common.helper';\nimport { A_TYPES__Entity_Constructor } from '../A-Entity/A-Entity.types';\nimport { A_ScopeError } from './A-Scope.error';\nimport { A_TYPES__Component_Constructor } from '../A-Component/A-Component.types';\nimport { A_TYPES__Fragment_Constructor } from '../A-Fragment/A-Fragment.types';\nimport { A_TYPES__Error_Constructor } from '../A-Error/A_Error.types';\nimport { A_TYPES__ComponentMetaKey } from '../A-Component/A-Component.constants';\nimport { A_Meta } from '../A-Meta/A-Meta.class';\n\n\n\n\nexport class A_Scope<\n    _MetaItems extends Record<string, any> = any,\n    _ComponentType extends A_TYPES__Component_Constructor[] = A_TYPES__Component_Constructor[],\n    _ErrorType extends A_TYPES__Error_Constructor[] = A_TYPES__Error_Constructor[],\n    _EntityType extends A_TYPES__Entity_Constructor[] = A_TYPES__Entity_Constructor[],\n    _FragmentType extends A_Fragment[] = A_Fragment[],\n> {\n\n    /**\n     * Scope Name uses for identification and logging purposes\n     */\n    protected _name!: string;\n    /**\n     * Parent scope reference, used for inheritance of components, fragments, entities and commands\n     */\n    protected _parent?: A_Scope;\n    /**\n     * Internal meta storage using A_Meta for type-safe key-value operations.\n     * This stores all the scope's runtime data that can be accessed and modified\n     * throughout the execution pipeline or within running containers.\n     */\n    protected _meta: A_Meta<_MetaItems> = new A_Meta<_MetaItems>();\n\n    // ===========================================================================\n    // --------------------ALLowed Constructors--------------------------------\n    // ===========================================================================\n    /**\n     * A set of allowed components, A set of constructors that are allowed in the scope\n     *      \n     */\n    protected _allowedComponents = new Set<_ComponentType[number]>();\n    /**\n     * A set of allowed errors, A set of constructors that are allowed in the scope\n     */\n    protected _allowedErrors = new Set<_ErrorType[number]>();\n    /**\n     * A set of allowed entities, A set of constructors that are allowed in the scope\n     */\n    protected _allowedEntities = new Set<_EntityType[number]>();\n    /**\n     * A set of allowed fragments, A set of constructors that are allowed in the scope\n     */\n    protected _allowedFragments = new Set<A_TYPES__Fragment_Constructor<_FragmentType[number]>>();\n\n\n\n    // ===========================================================================\n    // --------------------Internal Storage--------------------------------\n    // ===========================================================================\n    /**\n     * Storage for the components, should be strong as components are unique per scope\n     */\n    protected _components: Map<_ComponentType[number], InstanceType<_ComponentType[number]>> = new Map();\n    /**\n     * Storage for the errors, should be strong as errors are unique per code\n     */\n    protected _errors: Map<string, InstanceType<_ErrorType[number]>> = new Map();\n    /**\n     * Storage for the entities, should be strong as entities are unique per aseid\n     */\n    protected _entities: Map<string, InstanceType<_EntityType[number]>> = new Map();\n    /**\n     * Storage for the fragments, should be weak as fragments are singletons per scope\n     */\n    protected _fragments: Map<A_TYPES__Fragment_Constructor<_FragmentType[number]>, _FragmentType[number]> = new Map();\n\n\n\n\n    // ===========================================================================\n    // --------------------Readonly Allowed Properties----------------------------\n    // ===========================================================================\n    /**\n     * Returns the name of the scope\n     */\n    get name() { return this._name }\n    /**\n     * Returns the meta object of the scope\n     */\n    get meta() { return this._meta }\n    /**\n     * Returns a list of Constructors for A-Components that are available in the scope\n     */\n    get allowedComponents() { return this._allowedComponents }\n    /**\n     * Returns a list of Constructors for A-Entities that are available in the scope\n     */\n    get allowedEntities() { return this._allowedEntities }\n    /**\n     * Returns a list of Constructors for A-Fragments that are available in the scope\n     */\n    get allowedFragments() { return this._allowedFragments }\n    /**\n     * Returns a list of Constructors for A-Errors that are available in the scope\n     */\n    get allowedErrors() { return this._allowedErrors }\n    // ===========================================================================\n    // --------------------Readonly Registered Properties--------------------------\n    // ===========================================================================\n    /**\n     * Returns an Array of entities registered in the scope\n     * \n     * [!] One entity per aseid\n     */\n    get entities(): Array<InstanceType<_EntityType[number]>> { return Array.from(this._entities.values()) }\n    /**\n     * Returns an Array of fragments registered in the scope\n     * \n     * [!] One fragment per scope\n     */\n    get fragments(): Array<_FragmentType[number]> { return Array.from(this._fragments.values()) }\n    /**\n     * Returns an Array of components registered in the scope\n     * \n     * [!] One component instance per scope\n     */\n    get components(): Array<InstanceType<_ComponentType[number]>> { return Array.from(this._components.values()) }\n    /**\n     * Returns an Array of errors registered in the scope\n     * \n     * [!] One error per code\n     */\n    get errors(): Array<InstanceType<_ErrorType[number]>> { return Array.from(this._errors.values()) }\n\n    /**\n     * Returns the parent scope of the current scope\n     * \n     * @param setValue \n     * @returns \n     */\n    get parent(): A_Scope | undefined {\n        return this._parent;\n    }\n    /**\n     * A_Scope refers to the visibility and accessibility of :\n     * - variables, \n     * - Components, \n     * - Context Fragments \n     * - Entities\n     * - and objects in different parts of your code. \n     * Scope determines where a particular piece of data (like a variable or function) \n     * can be accessed, modified, or referenced, and it plays a crucial role in avoiding naming collisions and ensuring data integrity. \n     * \n     * [!] The scope behavior is similar to tree structure where each scope can have a parent scope and inherit its components, fragments, entities and errors\n     * \n     * @param params \n     * @param config \n     */\n    constructor()\n    constructor(\n        /**\n         * A set of constructors that are allowed in the scope\n         */\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        /**\n         * Configuration options for the scope\n         */\n        config?: Partial<A_TYPES__ScopeConfig>\n    )\n    constructor(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ) {\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n    /**\n     * Generator to iterate through all parent scopes\n     */\n    *parents(): Generator<A_Scope> {\n        let currentParent = this._parent;\n        while (currentParent) {\n            yield currentParent;\n            currentParent = currentParent._parent;\n        }\n    }\n\n    /**\n     * This method is used to retrieve a parent scope at a specific level\n     * \n     * [!] Note that if the level is out of bounds, undefined is returned\n     * [!!] Uses negative values for levels (e.g. -1 for immediate parent, -2 for grandparent, etc.)\n     * \n     * @param level \n     * @returns \n     */\n    parentOffset(\n        /**\n         * Level of the parent scope to retrieve\n         * \n         * Examples:\n         * - level 0 - immediate parent\n         * - level -1 - grandparent\n         * - level -2 - great-grandparent\n         */\n        layerOffset: number\n    ): A_Scope | undefined {\n        let parentScope = this.parent;\n\n        while (layerOffset < -1 && parentScope) {\n            parentScope = parentScope.parent;\n            layerOffset++;\n        }\n\n        return parentScope;\n    }\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n            case !param1 && !param2: ;\n                return this.defaultInitialized;\n\n            case !!param1:\n                return this.defaultInitialized;\n            default:\n                throw new A_ScopeError(A_ScopeError.ConstructorError, 'Invalid parameters provided to A_Scope constructor');\n        }\n    }\n\n\n\n    protected defaultInitialized(\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>> = {},\n        config: Partial<A_TYPES__ScopeConfig> = {}\n    ) {\n        this._name = params.name || this.constructor.name\n\n        this.initComponents(params.components);\n        this.initErrors(params.errors);\n        this.initFragments(params.fragments);\n        this.initEntities(params.entities);\n        this.initMeta(params.meta);\n\n        if (config.parent) {\n            this._parent = config.parent;\n        }\n    }\n\n\n    //==========================================================================\n    // --------------------Scope Initialization Methods---------------------------\n    //==========================================================================\n\n    /**\n     * This method is used to initialize the components in the scope\n     * To save memory components are initialized only when they are requested\n     * \n     * This method only registers the component in the scope in case they are not registered yet\n     * \n     * @param _components \n     */\n    protected initComponents(_components?: _ComponentType) { _components?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the errors in the scope\n     * \n     * This method only registers the errors in the scope in case they are not registered yet\n     * \n     * @param _errors \n     */\n    protected initErrors(_errors?: _ErrorType) { _errors?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the entities in the scope\n     * \n     * This method only registers the entities in the scope in case they are not registered yet\n     * \n     * @param _entities \n     */\n    protected initEntities(_entities?: [\n        ..._EntityType,\n        ...InstanceType<_EntityType[number]>[]\n    ]) { _entities?.forEach(ent => this.register(ent as any)); }\n    /**\n     * This method is used to initialize the fragments in the scope\n     * \n     * This method only registers the fragments in the scope in case they are not registered yet\n     * \n     * @param _fragments \n     */\n    protected initFragments(_fragments?: _FragmentType) { _fragments?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the meta in the scope\n     * \n     * This method only sets the meta values in the scope in case they are not set yet\n     * \n     * @param _meta \n     */\n    protected initMeta(_meta?: Partial<_MetaItems>) {\n        if (_meta) {\n            Object.entries(_meta).forEach(([key, value]) => {\n                this._meta.set(key as keyof _MetaItems, value as _MetaItems[keyof _MetaItems]);\n            });\n        }\n    }\n\n\n    // ==========================================================================\n    // --------------------Scope Public Methods-----------------------------------\n    // ==========================================================================\n    /**\n     * This method is used to destroy the scope and all its registered components, fragments and entities\n     * \n     * [!] This method deregisters all components, fragments and entities from the A-Context\n     * [!] This method also clears all internal registries and collections\n     */\n    destroy() {\n        this._components.forEach(component => A_Context.deregister(component));\n        this._fragments.forEach(fragment => A_Context.deregister(fragment));\n        this._entities.forEach(entity => A_Context.deregister(entity));\n\n        this._components.clear();\n        this._errors.clear();\n        this._fragments.clear();\n        this._entities.clear();\n\n        if (this.issuer()) {\n\n            A_Context.deallocate(this);\n        }\n    }\n\n\n    /**\n     * Retrieves a value from the scope's meta.\n     * \n     * @param param - The key to retrieve\n     * @returns The value associated with the key, or undefined if not found\n     * \n     * @example\n     * ```typescript\n     * const userId = scope.get('userId');\n     * if (userId) {\n     *   console.log(`Current user: ${userId}`);\n     * }\n     * ```\n     */\n    get<K extends keyof _MetaItems>(param: K): _MetaItems[K] | undefined {\n        return this._meta.get(param);\n    }\n\n    /**\n     * Stores a value in the scope's meta.\n     * \n     * @param param - The key to store the value under\n     * @param value - The value to store\n     * \n     * @example\n     * ```typescript\n     * scope.set('userId', '12345');\n     * scope.set('role', 'admin');\n     * ```\n     */\n    set<K extends keyof _MetaItems>(param: K, value: _MetaItems[K]): void {\n        this._meta.set(param, value);\n    }\n\n\n    /**\n     * Returns the issuer of the scope, useful for debugging and tracking purposes\n     * \n     * Issuer can be:\n     * - A Container that allocated the scope\n     * - A Feature that allocated the scope\n     * \n     * [!] Note that the issuer is the direct allocator of the scope, so if a Container allocated a Feature that allocated the scope, the issuer will be the Feature\n     * \n     * @returns \n     */\n    issuer<T extends A_TYPES__ScopeLinkedComponents>(): T | undefined {\n        return A_Context.issuer(this) as T;\n    }\n\n\n\n    /**\n     * This method is used to inherit from a parent scope\n     * \n     * [!] This method checks for circular inheritance and throws an error if detected\n     * \n     * @param parent \n     * @returns \n     */\n    inherit(parent: A_Scope): A_Scope {\n        if (!parent)\n            throw new A_ScopeError(\n                A_ScopeError.InitializationError,\n                `Invalid parent scope provided`\n            );\n\n        if (parent === this)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Unable to inherit scope ${this.name} from itself`\n            );\n\n        if (parent === this._parent)\n            return this;\n\n        // Prevent circular inheritance\n        const circularCheck = this.checkCircularInheritance(parent);\n\n        if (circularCheck)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Circular inheritance detected: ${[...circularCheck, parent.name].join(' -> ')}`\n            );\n\n\n        this._parent = parent;\n        return this;\n    }\n\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component in the current scope and all parent scopes\n     * \n     * @param component \n     * @returns \n     */\n    has<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    has<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    has<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    has<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    has(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    has(\n        ctor: unknown\n    ): boolean {\n\n        let found = this.hasFlat(ctor as any);\n\n        if (!found && !!this._parent)\n            try {\n                return this._parent.has(ctor as any);\n            } catch (error) {\n                return false;\n            }\n\n        return found;\n    }\n\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component ONLY in the current scope\n     * \n     * @param component \n     * @returns \n     */\n    hasFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    hasFlat(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    hasFlat(\n        ctor: unknown\n    ): boolean {\n\n        let found = false;\n\n        switch (true) {\n            // 1) Check if it's a Scope. It's always true since it returns itself\n            case A_TypeGuards.isScopeConstructor(ctor):\n                return true;\n\n            // 2) Check by string name.  \n            case A_TypeGuards.isString(ctor): {\n\n                // 2.1 Check if it's a component name\n                const possibleComponent = Array.from(this.allowedComponents).find(c => c.name === ctor);\n                if (possibleComponent) found = true;\n\n                // 2.2 Check if it's a fragment name\n                const possibleFragment = Array.from(this.allowedFragments).find(f => f.name === ctor);\n                if (possibleFragment) found = true;\n\n                // 2.3 Check if it's an entity name or entity static entity property\n                const possibleEntity = Array.from(this.allowedEntities).find(e => e.name === ctor);\n                if (possibleEntity) found = true;\n\n                // 2.4 Check if it's an error name\n                const possibleError = Array.from(this.allowedErrors).find(e => e.name === ctor);\n                if (possibleError) found = true;\n\n                break;\n            }\n            // 3) Check if it's a Component\n            case A_TypeGuards.isComponentConstructor(ctor): {\n                found = this.isAllowedComponent(ctor)\n                    || !![...this.allowedComponents]\n                        .find(c => A_CommonHelper.isInheritedFrom(c, ctor));\n\n                break;\n            }\n            // 4) Check if it's an Entity\n            case A_TypeGuards.isEntityConstructor(ctor): {\n                found = this.isAllowedEntity(ctor)\n                    || !![...this.allowedEntities]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n            // 5) Check if it's a Fragment\n            case A_TypeGuards.isFragmentConstructor(ctor): {\n                found = this.isAllowedFragment(ctor)\n                    || !![...this.allowedFragments]\n                        .find(f => A_CommonHelper.isInheritedFrom(f, ctor));\n\n                break;\n            }\n\n            // 6) Check if it's an Error\n            case A_TypeGuards.isErrorConstructor(ctor): {\n                found = this.isAllowedError(ctor)\n                    || !![...this.allowedErrors]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n\n            // 7) Check scope issuer\n            case this.issuer()\n                && (this.issuer()!.constructor === ctor\n                    || A_CommonHelper.isInheritedFrom(this.issuer()!.constructor, ctor\n                    )\n                ): {\n                    found = true;\n                    break;\n                }\n        }\n\n        return found;\n    }\n\n\n    /**\n     * Merges two scopes into a new one\n     * \n     * [!] Notes: \n     *  - this method does NOT modify the existing scopes\n     *  - parent of the new scope will be the parent of the current scope or the parent of anotherScope (if exists)\n     * \n     * @param anotherScope \n     * @returns \n     */\n    merge(anotherScope: A_Scope): A_Scope {\n        const merged = new A_Scope(\n            {\n                name: `${this.name} + ${anotherScope.name}`,\n\n                components: [...this.allowedComponents, ...anotherScope.allowedComponents],\n                fragments: [...this.fragments, ...anotherScope.fragments],\n                entities: [\n                    ...this.entities, ...anotherScope.entities,\n                    ...this.allowedEntities, ...anotherScope.allowedEntities\n                ],\n            },\n            {\n                parent: this._parent || anotherScope._parent\n            }\n        );\n\n        return merged;\n    }\n\n\n    /**\n     * Allows to retrieve the constructor of the component or entity by its name\n     * \n     * [!] Notes:\n     * - In case of search for A-Entity please ensure that provided string corresponds to the static entity property of the class. [!] By default it's the kebab-case of the class name\n     * - In case of search for A_Component please ensure that provided string corresponds to the class name in PascalCase\n     * \n     * @param name \n     * @returns \n     */\n    resolveConstructor<T extends A_Entity>(\n        /**\n         * Provide the entity name or static entity property to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Entity_Constructor<T>\n    resolveConstructor<T extends A_Component>(\n        /**\n         * Provide the component name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Component_Constructor<T>\n    resolveConstructor<T extends A_Fragment>(\n        /**\n         * Provide the fragment name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Fragment_Constructor<T>\n    resolveConstructor<T extends A_TYPES__ScopeResolvableComponents>(name: string): A_TYPES__Entity_Constructor<T> | A_TYPES__Component_Constructor<T> | A_TYPES__Fragment_Constructor<T> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (component) return component as A_TYPES__Component_Constructor<T>;\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return entity as A_TYPES__Entity_Constructor<T>;\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return fragment as A_TYPES__Fragment_Constructor<T>;\n\n        // If not found in current scope, check parent scope\n        if (!!this._parent) {\n            return this._parent.resolveConstructor(name) as any;\n        }\n\n        return undefined;\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_TYPES__ScopeResolvableComponents>(\n        constructorName: string\n    ): Array<T>\n    resolveAll<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors\n    ): Array<T> {\n\n        const results: Array<T> = [];\n\n        // 1) Resolve all in the current scope\n        const currentResults = this.resolveFlatAll<T>(param1 as any);\n        results.push(...currentResults);\n\n        // 2) Resolve all in the parent scope\n\n        let parentScope = this._parent;\n\n        while (parentScope && parentScope.has(param1 as any)) {\n            const parentResults = parentScope.resolveFlatAll<T>(param1 as any);\n            results.push(...parentResults);\n\n            // Move to the next parent scope\n            parentScope = parentScope._parent;\n        }\n\n\n        return results;\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlatAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__ScopeResolvableComponents>(\n        constructorName: string\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors\n    ): Array<T> {\n\n        const results: Array<T> = [];\n\n        switch (true) {\n            // 1) if a parameter is a component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                // 1) Check components\n                this.allowedComponents.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolve<T>(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n            // 2) if a parameter is a fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                // 2) Check fragments\n                this.allowedFragments.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolve(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isEntityConstructor(param1): {\n                // 3) Check entities\n                this.entities.forEach(entity => {\n\n                    if (A_CommonHelper.isInheritedFrom(entity.constructor, param1)) {\n                        results.push(entity as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isString(param1): {\n                // 4) Check by name\n                const ctor = this.resolveConstructor(param1);\n                if (!A_TypeGuards.isComponentConstructor(ctor)\n                    && !A_TypeGuards.isEntityConstructor(ctor)\n                    && !A_TypeGuards.isFragmentConstructor(ctor)\n                )\n                    throw new A_ScopeError(\n                        A_ScopeError.ResolutionError,\n                        `Unable to resolve all instances for name: ${param1} in scope ${this.name} as no matching component, entity or fragment constructor found`);\n\n\n                if (ctor) {\n                    const instances = this.resolveAll<T>(ctor as any);\n                    if (instances)\n                        results.push(...instances);\n                }\n                break;\n            }\n\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Invalid parameter provided to resolveAll method: ${param1} in scope ${this.name}`);\n        }\n\n\n        return results;\n    }\n\n\n\n    /**\n     * This method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * @param component \n     * @returns \n     */\n    resolve<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolve<T extends A_TYPES__Component_Constructor[]>(\n        /**\n         * Provide an array of component constructors to resolve their instances from the scope\n         */\n        components: [...T]\n    ): Array<InstanceType<T[number]>> | undefined\n    resolve<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolve<T extends A_TYPES__Fragment_Constructor[]>(\n        /**\n         * Provide an array of fragment constructors to resolve their instances from the scope\n         */\n        fragments: [...T]\n    ): Array<InstanceType<T[number]>> | undefined\n    resolve<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n\n    resolve<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>,\n        /**\n         * Provide optional instructions to find a specific entity or a set of entities\n         */\n        instructions: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions<T>>\n    ): Array<T>\n    resolve<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolve<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolve<T extends A_TYPES__ScopeResolvableComponents>(\n        constructorName: string\n    ): T | undefined\n    // base definition\n    resolve<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors,\n\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__ScopeLinkedConstructors>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: InstanceType<T>,\n\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors | Array<A_TYPES__InjectableConstructors>,\n        param2?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions>\n    ): T | Array<T> | undefined {\n\n\n        if (A_TypeGuards.isArray(param1)) {\n            return param1.map(c => this.resolveOnce(c, param2)) as Array<T>;\n        } else {\n            return this.resolveOnce(param1, param2) as T;\n        }\n    }\n\n\n    /**\n     * This polymorphic method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__Component_Constructor[]>(\n        /**\n         * Provide an array of component constructors to resolve their instances from the scope\n         */\n        components: [...T]\n    ): Array<InstanceType<T[number]>> | undefined\n    resolveFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__Fragment_Constructor[]>(\n        /**\n         * Provide an array of fragment constructors to resolve their instances from the scope\n         */\n        fragments: [...T]\n    ): Array<InstanceType<T[number]>> | undefined\n    resolveFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n\n    resolveFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>,\n        /**\n         * Provide optional instructions to find a specific entity or a set of entities\n         */\n        instructions: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions<T>>\n    ): Array<T>\n    resolveFlat<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__ScopeResolvableComponents>(\n        constructorName: string\n    ): T | undefined\n    // base definition\n    resolveFlat<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors,\n\n    ): T | Array<T> | undefined\n    resolveFlat<T extends A_TYPES__ScopeLinkedConstructors>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: InstanceType<T>,\n\n    ): T | Array<T> | undefined\n    resolveFlat<T extends A_TYPES__ScopeResolvableComponents>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__InjectableConstructors | Array<A_TYPES__InjectableConstructors>,\n        param2?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions>\n    ): T | Array<T | undefined> | undefined {\n\n        if (A_TypeGuards.isArray(param1)) {\n            return param1.map(c => this.resolveFlatOnce(c, param2)) as Array<T>;\n        } else {\n            return this.resolveFlatOnce(param1, param2) as T;\n        }\n    }\n\n\n\n\n\n\n    // ==================================================================================================\n    // --------------------------------------------------------------------------------------------------\n    // -------------------------------------INTERNAL RESOLVERS-------------------------------------------\n    // --------------------------------------------------------------------------------------------------\n    // ==================================================================================================\n    /**\n     * This method is used internally to resolve a component, fragment or entity by its constructor name\n     * \n     * [!] Note that this method checks for the component, fragment or entity in the current scope and all parent scopes\n     * [!!] Note: No parent scopes are checked\n     * \n     * @param name  - name of the component, fragment or entity to resolve (constructor name for components and fragments, static entity property for entities, static code property for commands)\n     * @returns \n     */\n    private resolveByName(\n        /**\n         * Provide the name of the component, fragment or entity to resolve\n         */\n        name: string\n    ): _EntityType[number] | InstanceType<_ComponentType[number]> | _FragmentType[number] |\n        InstanceType<_ErrorType[number]> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (component) return this.resolveOnce(component) as InstanceType<_ComponentType[number]>;\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return this.resolveOnce(entity) as InstanceType<_EntityType[number]>;\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return this.resolveOnce(fragment) as _FragmentType[number];\n\n        // 4) Check errors\n        const error = Array.from(this.allowedErrors).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).code === name\n                || (e as any).code === A_FormatterHelper.toKebabCase(name)\n        );\n        if (error) return this.resolveOnce(error) as InstanceType<_ErrorType[number]>;\n\n        return undefined;\n    }\n\n    /**\n     * Resolves a component, fragment or entity from the scope without checking parent scopes\n     * \n     * @param component \n     * @param instructions \n     */\n    private resolveFlatOnce(\n        component: any,\n        instructions?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions>\n    ): A_TYPES__ScopeResolvableComponents | A_Scope | A_TYPES__ScopeLinkedComponents | Array<A_TYPES__ScopeResolvableComponents> | undefined {\n\n        let value: A_TYPES__ScopeResolvableComponents | A_Scope | A_TYPES__ScopeLinkedComponents | Array<A_TYPES__ScopeResolvableComponents> | undefined = undefined;\n\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        if (!component || !this.has(component))\n            return undefined;\n\n        switch (true) {\n            case A_TypeGuards.isString(component): {\n                value = this.resolveByName(component) as A_TYPES__ScopeResolvableComponents | A_Scope | A_TYPES__ScopeLinkedComponents | undefined;\n                break;\n            }\n            case A_TypeGuards.isConstructorAllowedForScopeAllocation(component): {\n                value = this.resolveIssuer(component);\n                break;\n            }\n            case A_TypeGuards.isEntityConstructor(component): {\n                value = this.resolveEntity(component, instructions);\n                break;\n            }\n            case A_TypeGuards.isFragmentConstructor(component): {\n                value = this.resolveFragment(component);\n                break;\n            }\n            case A_TypeGuards.isScopeConstructor(component): {\n                value = this.resolveScope(component);\n                break;\n            }\n            case A_TypeGuards.isComponentConstructor(component): {\n                value = this.resolveComponent(component);\n                break;\n            }\n            case A_TypeGuards.isErrorConstructor(component): {\n                value = this.resolveError(component);\n                break;\n            }\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Injected Component ${componentName} not found in the scope`\n                );\n        }\n\n        return value;\n    }\n\n    /**\n     * This method is used internally to resolve a single component, fragment or entity from the scope\n     * \n     * @param component \n     * @param instructions \n     * @returns \n     */\n    private resolveOnce(\n        component: any,\n        instructions?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions>\n    ): A_TYPES__ScopeResolvableComponents | A_Scope | A_TYPES__ScopeLinkedComponents | Array<A_TYPES__ScopeResolvableComponents> | undefined {\n\n        const values = this.resolveFlatOnce(component, instructions);\n\n        //  The idea here that in case when Scope has no exact component we have to resolve it from the _parent\n        //  That means that we should ensure that there's no components that are children of the required component\n        if (!values && !!this.parent) {\n            return this.parent.resolveOnce(component, instructions);\n        }\n\n        return values;\n    }\n\n\n    /**\n     * Resolves the issuer of the scope by provided constructor\n     * \n     * [!] Note that this method checks ONLY for the direct issuer of the scope\n     * [!!] No parent scopes are checked\n     * \n     * \n     * @param ctor \n     * @returns \n     */\n    private resolveIssuer(\n        ctor: A_TYPES__ScopeLinkedConstructors\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const issuer = this.issuer();\n\n        if (issuer\n            && (\n                issuer.constructor === ctor\n                || A_CommonHelper.isInheritedFrom(issuer?.constructor, ctor)\n            )) {\n            return issuer!;\n        }\n\n\n        return undefined;\n    }\n\n    /**\n     * This method is used internally to resolve a single entity from the scope based on the provided instructions\n     * \n     * [!] Note that this method can return either a single entity or an array of entities depending on the instructions provided\n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param entity \n     * @param instructions \n     * @returns \n     */\n    private resolveEntity<T extends A_Entity>(\n        entity: A_TYPES__Entity_Constructor<T>,\n        instructions?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions<T>>\n    ): T | Array<T> | undefined {\n\n        const query = instructions?.query || {} as Partial<A_TYPES__A_InjectDecorator_EntityInjectionQuery<T>>;\n        const count = instructions?.pagination?.count || 1;\n\n        switch (true) {\n            /**\n             * 1) In case when no instructions provided, return the first found entity of the provided type\n             * \n             * [!] Note that it returns ONLY ONE entity\n             * [!!] In case when no entity found in the current scope, it tries to resolve it from the parent scope (if exists)\n             */\n            case !instructions: {\n                return this.entities.find(e => e instanceof entity) as T | undefined;\n            }\n            /**\n             * 2) In case when aseid is provided in the query, we can directly get the entity from the map\n             * \n             * [!] Note that it returns ONLY ONE entity\n             */\n            case !!query.aseid\n                && typeof query.aseid === 'string'\n                && this._entities.has(query.aseid): {\n                    return this._entities.get(query.aseid) as T;\n                }\n            /**\n             * 3) In case when aseid is provided as ASEID instance, we can directly get the entity from the map\n             * \n             * [!] Note that it returns ONLY ONE entity\n             */\n            case !!query.aseid\n                && typeof query.aseid === 'object'\n                && query.aseid instanceof ASEID\n                && this._entities.has(query.aseid.toString()): {\n                    return this._entities.get(query.aseid.toString()) as T;\n                }\n            /**\n             * 4) In case when id is provided in the query, we have to find the entity by the id\n             * \n             * [!]  Note that it returns ONLY ONE entity\n             */\n            case !!query.id: {\n\n                const found = this.entities\n                    .filter(e => e instanceof entity)\n                    .find(e => String(e.id) === String(query.id));\n\n                return found as T;\n            }\n            /**\n             * 5) In case when there's a query object, we have to filter the entities by the query\n             * \n             * [!] Note that it can return either a single entity or an array of entities depending on the count instruction\n             * [!!] In case when no entity found in the current scope, it tries to resolve it from the parent scope (if exists)\n             */\n            default: {\n\n                const found = this.entities\n                    .filter(e => e instanceof entity)\n                    .filter(e => {\n                        return Object\n                            .entries(query)\n                            .every(([key, value]) => {\n                                if (key in e) {\n                                    return (e as any)[key] === value;\n                                }\n                                return false;\n                            });\n                    });\n\n                if (found.length === 0)\n                    return undefined;\n\n                if (count === 1)\n                    return found[0] as T;\n\n                return found as T[];\n            }\n        }\n    }\n    /**\n     * This method is used internally to resolve a single error from the scope\n     * \n     * [!] Note that errors are singleton instances within the scope\n     * [!!] No parent scopes are checked\n     * \n     * @param error \n     * @returns \n     */\n    private resolveError<T extends A_Error>(error: A_TYPES__Error_Constructor<T>): T | undefined {\n\n        return this.errors.find(e => e instanceof error) as T | undefined;\n    }\n    /**\n     * This method is used internally to resolve a single fragment from the scope\n     * \n     * [!] Note that this method checks for the fragment in the current scope and all parent scopes\n     * \n     * @param fragment \n     * @returns \n     */\n    private resolveFragment<T extends A_Fragment>(fragment: A_TYPES__Fragment_Constructor<T>): _FragmentType[number] | undefined {\n        const fragmentInstancePresented = this._fragments.get(fragment);\n\n        switch (true) {\n            case fragmentInstancePresented && this._fragments.has(fragment):\n                return fragmentInstancePresented;\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !fragmentInstancePresented && Array.from(this._allowedFragments).some(el => A_CommonHelper.isInheritedFrom(el, fragment)): {\n                const found = Array.from(this._allowedFragments).find(el => A_CommonHelper.isInheritedFrom(el, fragment))!;\n\n                return this.resolveFragment(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n    /**\n     *  This method is used internally to resolve a single scope from the current scope\n     * \n     * @param scope \n     * @returns \n     */\n    private resolveScope(scope: A_TYPES__Scope_Constructor): A_Scope {\n        return this;\n    }\n\n    /**\n     * This method is used internally to resolve a single component from the scope\n     * \n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param component \n     * @returns \n     */\n    private resolveComponent<T extends A_Component>(component: A_TYPES__Component_Constructor<T>): InstanceType<_ComponentType[number]> | undefined {\n\n\n        switch (true) {\n            // 1) In case when the component is available and exists in the scope\n            case this.allowedComponents.has(component) && this._components.has(component): {\n                return this._components.get(component)!;\n            }\n\n            // 2) In case the component available but does NOT exist in the scope\n            case this.allowedComponents.has(component) && !this._components.has(component): {\n                const componentMeta = A_Context.meta(component)\n\n                const argsMeta = componentMeta.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n                const resolvedArgs = (argsMeta?.get('constructor') || [])\n                    .map(arg => {\n                        // for Error handling purposes\n                        const componentName = A_CommonHelper.getComponentName(arg.target)\n\n                        if ('instructions' in arg && !!arg.instructions) {\n                            const { target, parent, flat, instructions } = arg\n                            const dependency = this.resolve(target as any, instructions);\n                            if (!dependency)\n                                throw new A_ScopeError(\n                                    A_ScopeError.ResolutionError,\n                                    `Unable to resolve dependency ${componentName} for component ${component.name} in scope ${this.name}`\n                                );\n\n                            return dependency;\n                        } else {\n                            const { target, require, create, defaultArgs, parent, flat, } = arg;\n\n                            let dependency;\n\n                            // ----------------- Resolution Strategies -----------------\n                            switch (true) {\n                                // 1) Flat resolution\n                                case flat: {\n                                    dependency = this.resolveFlat(target);\n                                    break;\n                                }\n                                // 2) Parent resolution\n                                case parent && typeof parent.layerOffset === 'number': {\n                                    const targetParent = this.parentOffset(parent.layerOffset);\n                                    if(!targetParent) {\n                                        throw new A_ScopeError(\n                                            A_ScopeError.ResolutionError,\n                                            `Unable to resolve parent scope at offset ${parent.layerOffset} for dependency ${componentName} for component ${component.name} in scope ${this.name}`\n                                        );\n                                    }\n                                    dependency = targetParent.resolve(target);\n\n                                    break;\n                                }\n                                // 3) Normal resolution\n                                default: {\n                                    dependency = this.resolve(target);\n                                    break;\n                                }\n                            }\n\n                            // ----------------- Post-Resolution Actions -----------------\n\n                            // 1) Create default instance in case when allowed\n                            if (create && !dependency && A_TypeGuards.isAllowedForDependencyDefaultCreation(target)) {\n                                dependency = new target(...defaultArgs);\n\n                                this.register(dependency);\n                            }\n\n                            // 2) Throw error in case when required but not resolved\n                            if (require && !dependency) {\n                                throw new A_ScopeError(\n                                    A_ScopeError.ResolutionError,\n                                    `Unable to resolve required dependency ${componentName} for component ${component.name} in scope ${this.name}`\n                                );\n                            }\n\n\n                            //  Finally, return the dependency (either resolved or undefined)\n                            return dependency;\n                        }\n                    });\n\n                const newComponent = new component(...resolvedArgs)\n\n                this.register(newComponent);\n\n                return this._components.get(component)!;\n            }\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !this.allowedComponents.has(component) && Array.from(this.allowedComponents).some(el => A_CommonHelper.isInheritedFrom(el, component)): {\n                const found = Array.from(this.allowedComponents).find(el => A_CommonHelper.isInheritedFrom(el, component))!;\n\n                return this.resolveComponent(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n\n\n    /**\n     * This method is used to register the component in the scope\n     * \n     * @param fragment \n     */\n    register<T extends A_Component>(\n        /**\n         * Provide a component constructor to register it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    register<T extends A_Component>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        component: T\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error constructor to register it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error instance to register it in the scope\n         */\n        error: T\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a fragment instance to register it in the scope\n         */\n        fragment: T\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to register it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        entity: T\n    ): void\n\n    register(\n        param1: unknown\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                if (!this.allowedComponents.has(param1.constructor as _ComponentType[number]))\n                    this.allowedComponents.add(param1.constructor as _ComponentType[number]);\n\n                this._components.set(\n                    param1.constructor as _ComponentType[number],\n                    param1 as InstanceType<_ComponentType[number]>\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1) && !this._entities.has(param1.aseid.toString()): {\n\n                if (!this.allowedEntities.has(param1.constructor as _EntityType[number]))\n                    this.allowedEntities.add(param1.constructor as _EntityType[number]);\n\n                this._entities.set(param1.aseid.toString(), param1 as InstanceType<_EntityType[number]>);\n                A_Context.register(this, param1);\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n\n                if (!this.allowedFragments.has(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>))\n                    this.allowedFragments.add(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n\n                this._fragments.set(\n                    param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>,\n                    param1 as _FragmentType[number]\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n                if (!this.allowedErrors.has(param1.constructor as _ErrorType[number]))\n                    this.allowedErrors.add(param1.constructor as _ErrorType[number]);\n\n                this._errors.set(\n                    param1.code,\n                    param1 as InstanceType<_ErrorType[number]>\n                );\n\n                A_Context.register(this, param1);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                if (!this.allowedComponents.has(param1))\n                    this.allowedComponents.add(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                if (!this.allowedFragments.has(param1))\n                    this.allowedFragments.add(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                if (!this.allowedEntities.has(param1))\n                    this.allowedEntities.add(param1 as _EntityType[number]);\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                if (!this.allowedErrors.has(param1))\n                    this.allowedErrors.add(param1 as _ErrorType[number]);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                if (param1 instanceof A_Entity)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Entity with ASEID ${param1.aseid.toString()} is already registered in the scope ${this.name}`\n                    );\n                else if (param1 instanceof A_Fragment)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Fragment ${param1.constructor.name} is already registered in the scope ${this.name}`\n                    );\n                else {\n                    const componentName = A_CommonHelper.getComponentName(param1);\n\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Cannot register ${componentName} in the scope ${this.name}`\n                    );\n                }\n        }\n    }\n\n\n    /**\n     * This method is used to deregister the component from the scope\n     * \n     * @param fragment \n     */\n    deregister<T extends A_Component>(\n        /**\n         * Provide a component constructor to deregister it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        component: A_Component\n    ): void\n    deregister<T extends A_Error>(\n        /**\n         * Provide an error constructor to deregister it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an error instance to deregister it in the scope\n         */\n        error: A_Error\n    ): void\n    deregister<T extends A_Fragment>(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a fragment instance to deregister it in the scope\n         */\n        fragment: A_Fragment\n    ): void\n    deregister<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to deregister it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an entity instance to deregister it in the scope\n         */\n        entity: A_Entity\n    ): void\n\n    deregister(\n        param1: unknown\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                this._components.delete(param1.constructor as _ComponentType[number]);\n                A_Context.deregister(param1);\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1): {\n\n                this._entities.delete(param1.aseid.toString());\n                A_Context.deregister(param1);\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n\n                this._fragments.delete(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                A_Context.deregister(param1);\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n\n                this._errors.delete(param1.code);\n                A_Context.deregister(param1);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                this.allowedComponents.delete(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                this.allowedFragments.delete(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                this.allowedEntities.delete(param1 as _EntityType[number]);\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                this.allowedErrors.delete(param1 as _ErrorType[number]);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                const componentName = A_CommonHelper.getComponentName(param1);\n\n                throw new A_ScopeError(\n                    A_ScopeError.DeregistrationError,\n                    `Cannot deregister ${componentName} from the scope ${this.name}`\n                );\n        }\n    }\n\n    /**\n     * This method is useful when you want to serialize the scope to JSON\n     * \n     * [!] Note this is not a deep serialization, only the fragments are serialized\n     * [!] Fragments are a storage for information which is relevant to the scope\n     * \n     * @returns \n     */\n    toJSON(): Record<string, any> {\n        return this.fragments\n            .reduce((acc, fragment) => {\n\n                const serialized = fragment.toJSON()\n\n                return {\n                    ...acc,\n                    [serialized.name]: serialized\n                }\n            }, {});\n    }\n\n\n\n    //==========================================================================\n    // --------------------Scope Type Check Helpers---------------------------\n    //==========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Component and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedComponent(ctor: unknown): ctor is _ComponentType[number] {\n        return A_TypeGuards.isComponentConstructor(ctor) && this.allowedComponents.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedEntity(ctor: unknown): ctor is A_TYPES__Entity_Constructor<_EntityType[number]> {\n        return A_TypeGuards.isEntityConstructor(ctor) && this.allowedEntities.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedFragment(ctor: unknown): ctor is A_TYPES__Fragment_Constructor<_FragmentType[number]> {\n        return A_TypeGuards.isFragmentConstructor(ctor) && this.allowedFragments.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Error and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedError(ctor: unknown): ctor is A_TYPES__Error_Constructor<_ErrorType[number]> {\n        return A_TypeGuards.isErrorConstructor(ctor) && this.allowedErrors.has(ctor);\n    }\n\n\n\n\n    // ==========================================================================\n    // --------------------DEBUG & Helpers Methods--------------------------------\n    // ===========================================================================\n    /**\n     * This method is used to check if the scope is inherited from another scope\n     * \n     * @param scope \n     * @returns \n     */\n    isInheritedFrom(scope: A_Scope): boolean {\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            if (current === scope) {\n                return true;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to check circular inheritance\n     * Should return a full sequence of inheritance for logging purposes\n     * \n     * @param scope \n     * @returns \n     */\n    checkCircularInheritance(scope: A_Scope): Array<string> | false {\n        const inheritanceChain: Array<string> = [];\n        let current: A_Scope | undefined = this._parent;\n\n        while (current) {\n            inheritanceChain.push(current.name);\n            if (current === scope) {\n                return inheritanceChain;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to print the inheritance chain of the scope\n     */\n    printInheritanceChain(): void {\n        const chain: Array<string> = [];\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            chain.push(current.name);\n            current = current._parent;\n        }\n\n        console.log(chain.join(' -> '));\n    }\n}","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\nexport class A_CallerError extends A_Error {\n\n    /**\n     * This error code indicates that there was an issue initializing the A-Caller\n     */\n    static readonly CallerInitializationError = 'Unable to initialize A-Caller';\n}","import { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__FeatureAvailableComponents } from \"../A-Feature/A-Feature.types\";\nimport { A_CallerError } from \"./A_Caller.error\";\n\n\n\n/**\n * This is a common class that uses to return an entity that initiates a feature call\n * \n * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n * \n * [!] the class itself may be retrieved, but may require additional processing inside the feature\n * \n */\nexport class A_Caller<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    /**\n     * The component that initiated the feature call\n     */\n    protected _component: T;\n\n\n    /**\n     * A_Caller allows to get the component that initiated the feature call\n     * \n     * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n     * \n     * [!] If Scope is not provided, a new empty scope will be created and inherited from the global scope\n     * \n     * @param component \n     * @param scope \n     */\n    constructor(\n        component: T\n    ) {\n        this.validateParams(component);\n\n        this._component = component;\n    }\n\n    get component(): T {\n        return this._component;\n    }\n\n\n    /**\n     * Validates the provided parameters and Ensures that the component is of an allowed type\n     * \n     * @param component \n     */\n    protected validateParams(\n        component: T\n    ) {\n        if (!A_TypeGuards.isAllowedForFeatureCall(component)) {\n            throw new A_CallerError(\n                A_CallerError.CallerInitializationError,\n                `Invalid A-Caller component provided of type: ${typeof component} with value: ${JSON.stringify(component).slice(0, 100)}...`\n            );\n        }\n    }\n}","import {\n    A_TYPES__Feature_Constructor,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureExtendDecoratorTarget\n} from \"../global/A-Feature/A-Feature.types\";\nimport {\n    A_TYPES__Error_Constructor,\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from \"../global/A-Error/A_Error.types\";\nimport { A_Component } from \"../global/A-Component/A-Component.class\";\nimport { A_ComponentMeta } from \"../global/A-Component/A-Component.meta\";\nimport { A_TYPES__Component_Constructor } from \"../global/A-Component/A-Component.types\";\nimport { A_Container } from \"../global/A-Container/A-Container.class\";\nimport { A_ContainerMeta } from \"../global/A-Container/A-Container.meta\";\nimport { A_TYPES__Container_Constructor } from \"../global/A-Container/A-Container.types\";\nimport { A_Entity } from \"../global/A-Entity/A-Entity.class\";\nimport { A_EntityMeta } from \"../global/A-Entity/A-Entity.meta\";\nimport { A_TYPES__Entity_Constructor } from \"../global/A-Entity/A-Entity.types\";\nimport { A_Feature } from \"../global/A-Feature/A-Feature.class\";\nimport { A_Fragment } from \"../global/A-Fragment/A-Fragment.class\";\nimport { A_TYPES__Fragment_Constructor } from \"../global/A-Fragment/A-Fragment.types\";\nimport { A_Scope } from \"../global/A-Scope/A-Scope.class\";\nimport { A_Caller } from \"../global/A-Caller/A_Caller.class\";\nimport { A_TYPES__Caller_Constructor } from \"../global/A-Caller/A_Caller.types\";\nimport { A_Error } from \"../global/A-Error/A_Error.class\";\nimport { A_CommonHelper } from \"./A_Common.helper\";\nimport { A_TYPES__AbstractionAvailableComponents } from \"../global/A-Abstraction/A-Abstraction.types\";\nimport { A_TYPES__Scope_Constructor, A_TYPES__ScopeLinkedComponents, A_TYPES__ScopeLinkedConstructors } from \"../global/A-Scope/A-Scope.types\";\nimport { A_TYPES__InjectableTargets } from \"../global/A-Inject/A-Inject.types\";\nimport { ASEID } from \"../global/ASEID/ASEID.class\";\n\n\n\nexport class A_TypeGuards {\n    // ===========================================================================\n    // ============================= BASE Type Guards ============================\n    // ===========================================================================\n    /**\n     * Check if value is a string\n     * \n     * @param value \n     * @returns \n     */\n    static isString(value: any): value is string {\n        return typeof value === 'string' || value instanceof String;\n    }\n    /**\n     * Check if value is a number\n     * \n     * @param value \n     * @returns \n     */\n    static isNumber(value: any): value is number {\n        return typeof value === 'number' && isFinite(value);\n    }\n    /**\n     * Check if value is a boolean\n     * \n     * @param value \n     * @returns \n     */\n    static isBoolean(value: any): value is boolean {\n        return typeof value === 'boolean';\n    }\n    /**\n     * Check if value is an array\n     * \n     * @param value \n     * @returns \n     */\n    static isArray(value: any): value is Array<any> {\n        return Array.isArray(value);\n    }\n    /**\n     * Check if value is an object\n     * \n     * @param value \n     * @returns \n     */\n    static isObject<T extends Object = Object>(value: any): value is T {\n        return value && typeof value === 'object' && !Array.isArray(value);\n    }\n    /**\n     * Check if value is a function\n     * \n     * @param value \n     * @returns \n     */\n    static isFunction(value: any): value is Function {\n        return typeof value === 'function';\n    }\n\n    static isUndefined(value: any): value is undefined {\n        return typeof value === 'undefined';\n    }\n\n    static isRegExp(value: any): value is RegExp {\n        return value instanceof RegExp;\n    }\n\n\n    // ===========================================================================\n    // ==========================A-Concept Type Guards ===========================\n    // ===========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Container\n     * \n     * @param ctor \n     * @returns \n     */\n    static isContainerConstructor(ctor: any): ctor is A_TYPES__Container_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Container);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Component\n     * \n     * @param ctor \n     * @returns \n     */\n    static isComponentConstructor(ctor: any): ctor is A_TYPES__Component_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Component);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFragmentConstructor(ctor: any): ctor is A_TYPES__Fragment_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Fragment);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity\n     * \n     * @param ctor \n     * @returns \n     */\n    static isEntityConstructor(ctor: any): ctor is A_TYPES__Entity_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Entity);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isScopeConstructor(ctor: any): ctor is A_TYPES__Scope_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Scope);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isErrorConstructor(ctor: any): ctor is A_TYPES__Error_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Error);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Feature\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFeatureConstructor(ctor: any): ctor is A_TYPES__Feature_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Feature);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Caller\n     * \n     * @param ctor \n     * @returns \n     */\n    static isCallerConstructor(ctor: any): ctor is A_TYPES__Caller_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Caller);\n    }\n    // ----------------------------------------------------------------------------\n    // Instance type guards\n    // ----------------------------------------------------------------------------\n    /**\n     * Type guard to check if the instance is of type A_Container\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerInstance(instance: any): instance is A_Container {\n        return instance instanceof A_Container;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Component\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentInstance(instance: any): instance is A_Component {\n        return instance instanceof A_Component;\n    }\n\n    /**\n     * Type guard to check if the instance is of type A_Feature\n     * \n     * @param instance \n     * @returns \n     */\n    static isFeatureInstance(instance: any): instance is A_Feature {\n        return instance instanceof A_Feature;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Fragment\n     * \n     * @param instance \n     * @returns \n     */\n    static isFragmentInstance(instance: any): instance is A_Fragment {\n        return instance instanceof A_Fragment;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Entity\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityInstance(instance: any): instance is A_Entity {\n        return instance instanceof A_Entity;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Scope\n     * \n     * @param instance \n     * @returns \n     */\n    static isScopeInstance(instance: any): instance is A_Scope {\n        return instance instanceof A_Scope;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Error\n     * \n     * @param instance \n     * @returns \n     */\n    static isErrorInstance(instance: any): instance is A_Error {\n        return instance instanceof A_Error;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ComponentMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentMetaInstance(instance: any): instance is A_ComponentMeta {\n        return instance instanceof A_ComponentMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ContainerMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerMetaInstance(instance: any): instance is A_ContainerMeta {\n        return instance instanceof A_ContainerMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_EntityMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityMetaInstance(instance: any): instance is A_EntityMeta {\n        return instance instanceof A_EntityMeta;\n    }\n\n\n\n    // ==========================================================================\n    // ========================= SPECIAL Type Guards =============================\n    // ===========================================================================\n    static isConstructorAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedConstructors {\n        return A_TypeGuards.isContainerConstructor(target)\n            || A_TypeGuards.isFeatureConstructor(target);\n    }\n    static isInstanceAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isFeatureInstance(target);\n    }\n\n    static isConstructorAvailableForAbstraction(target: any): target is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isComponentInstance(target);\n    }\n\n\n    static isTargetAvailableForInjection(target: any): target is A_TYPES__InjectableTargets {\n        return A_TypeGuards.isComponentConstructor(target)\n            || A_TypeGuards.isComponentInstance(target)\n            || A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isEntityInstance(target)\n    }\n\n    static isAllowedForFeatureCall(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureDefinition(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureExtension(param: any): param is A_TYPES__FeatureExtendDecoratorTarget {\n        return A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForAbstractionDefinition(param: any): param is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param);\n    }\n\n    static isAllowedForDependencyDefaultCreation(param: any): param is A_TYPES__Entity_Constructor | A_TYPES__Component_Constructor {\n        return A_TypeGuards.isComponentConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Component)\n            || A_TypeGuards.isEntityConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Entity)\n\n    }\n\n    /**\n     * Allows to check if the provided param is of constructor type.\n     * \n     * @param param \n     * @returns \n     */\n    static isErrorConstructorType<T extends A_TYPES__Error_Init>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"title\" in param;\n    }\n\n\n    static isErrorSerializedType<T extends A_TYPES__Error_Serialized>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"aseid\" in param && ASEID.isASEID(param.aseid);\n    }\n}","import { A_Error } from \"../A-Error/A_Error.class\";\nimport { A_Stage } from \"../A-Stage/A-Stage.class\";\nimport { A_TYPES__FeatureError_Init } from \"./A-Feature.types\";\n\n\n\nexport class A_FeatureError extends A_Error<A_TYPES__FeatureError_Init> {\n\n    /**\n     * Indicates that the Feature has been interrupted\n     */\n    static readonly Interruption = 'Feature Interrupted';\n    /**\n     * Indicates that there was an error initializing the Feature\n     * \n     * Failed during the A-Feature initialization process\n     */\n    static readonly FeatureInitializationError = 'Unable to initialize A-Feature';\n    /**\n     * Indicates that there was an error processing the Feature\n     * \n     * Failed during the A-Feature processing\n     */\n    static readonly FeatureProcessingError = 'Error occurred during A-Feature processing';\n\n    // =======================================================================\n    // ---------------------- Decorator Errors -----------------------------\n    // =======================================================================\n    /**\n     * Indicates that there was an error defining the Feature\n     * \n     * Failed during the @A_Feature.Define() decorator execution\n     */\n    static readonly FeatureDefinitionError = 'Unable to define A-Feature';\n    /**\n     * Indicates that there was an error extending the Feature\n     * \n     * Failed during the @A_Feature.Extend() decorator execution\n     */\n    static readonly FeatureExtensionError = 'Unable to extend A-Feature';\n\n    \n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n\n    protected fromConstructor(params: A_TYPES__FeatureError_Init): void {\n        super.fromConstructor(params);\n\n        this.stage = params.stage;\n    }\n}","import {\n    A_TYPES__FeatureDefineDecoratorConfig,\n    A_TYPES__FeatureDefineDecoratorDescriptor,\n    A_TYPES__FeatureDefineDecoratorMeta,\n    A_TYPES__FeatureDefineDecoratorTarget\n} from \"./A-Feature.types\";\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_EntityMeta } from \"@adaas/a-concept/global/A-Entity/A-Entity.meta\";\nimport { A_ContainerMeta } from \"@adaas/a-concept/global/A-Container/A-Container.meta\";\nimport { A_ComponentMeta } from \"@adaas/a-concept/global/A-Component/A-Component.meta\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/global/A-Entity/A-Entity.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * A-Feature decorator\n * \n * This decorator allows to define a custom lifecycle stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Feature and A-Feature decorators is that A-Feature methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\nexport function A_Feature_Define(\n    config: Partial<A_TYPES__FeatureDefineDecoratorConfig> = {}\n) {\n    return function (\n        target: A_TYPES__FeatureDefineDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureDefineDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureDefinitionError,\n                `A-Feature cannot be defined on the ${componentName} level`\n            );\n\n        const meta: A_EntityMeta | A_ContainerMeta | A_ComponentMeta = A_Context.meta(target.constructor as any);\n\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n        }\n\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            /**\n             * Where Key is the name of the feature\n             * \n             * Where value is the list of features\n             */\n            [Key: string]: A_TYPES__FeatureDefineDecoratorMeta\n        }> = meta.get(metaKey) || new A_Meta();\n\n\n        const name = config.name || propertyKey;\n        //  default to false\n        const invoke = config.invoke || false;\n\n\n        // Set the metadata of the method to define a custom Feature with name \n        existedMeta.set(propertyKey, {\n            name: `${target.constructor.name}.${name}`,\n            handler: propertyKey,\n            invoke: invoke,\n            template: config.template && config.template.length ? config.template.map(\n                item => ({\n                    ...item,\n                    before: item.before || '',\n                    after: item.after || '',\n                    behavior: item.behavior || 'sync',\n                    throwOnError: true,\n                    override: item.override || ''\n\n                })\n            ) : [],\n        });\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target.constructor as any)\n            .set(\n                metaKey,\n                existedMeta\n            );\n\n        const originalMethod = descriptor.value!;\n\n        // Wrap the original method to add the call to `call`\n        // this helps to automatically call the container/entity/component method when it's called\n        descriptor.value = function (...args: any[]) {\n\n            // Call the original method\n            if (!invoke)\n                return originalMethod.apply(this, args);\n            else\n                originalMethod.apply(this, args);\n\n            // Call your `call` with the function name\n            if (typeof (this as A_TYPES__FeatureDefineDecoratorTarget).call === \"function\" && invoke)\n                return (this as A_TYPES__FeatureDefineDecoratorTarget).call(name);\n\n        };\n\n        return descriptor;\n    };\n}","import { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__FeatureExtendDecoratorConfig, A_TYPES__FeatureExtendDecoratorDescriptor, A_TYPES__FeatureExtendDecoratorScopeItem, A_TYPES__FeatureExtendDecoratorTarget } from \"./A-Feature.types\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__ComponentMetaKey } from \"../A-Component/A-Component.constants\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_TYPES__EntityMetaKey } from \"../A-Entity/A-Entity.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"../A-Container/A-Container.constants\";\nimport { A_Container } from \"../A-Container/A-Container.class\";\n\n\n\n\n/**\n * A-Extend decorator\n * \n * This decorator allows to define a custom Extend stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Extend and A-Extend decorators is that A-Extend methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\n/**\n * Use regexp in case if you need more flexibility and control over the name of the method\n * \n * @param regexp \n */\nexport function A_Feature_Extend(\n    /**\n     * The regular expression to match the name of the Feature method to be extended\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend(/.*\\.load/)\n     * ```\n     */\n    regexp: RegExp\n)\n/**\n * In this case the name configurations will be used as an input to get scope and name of target function\n * [!] Not that for all SCOPE will be used OR operator\n * \n * @param config \n */\nexport function A_Feature_Extend(\n    /**\n     * Configuration for the A-Feature-Extend decorator\n     */\n    config: Partial<A_TYPES__FeatureExtendDecoratorConfig>\n)\n/**\n * In this case the name of function will be used as a name of the Feature.\n * [!] AND it will be applicable for ANY element where the name is the same as the name of the function\n */\nexport function A_Feature_Extend()\nexport function A_Feature_Extend(\n    param1?: Partial<A_TYPES__FeatureExtendDecoratorConfig> | RegExp\n) {\n    return function (\n        target: A_TYPES__FeatureExtendDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureExtendDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isAllowedForFeatureExtension(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be applied on the ${componentName} level`\n            );\n\n        let targetRegexp: RegExp;\n        let behavior: 'sync' | 'async' = 'sync';\n        let before: string = '';\n        let after: string = '';\n        let override: string = '';\n        let include: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let exclude: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let throwOnError: boolean = true;\n        let metaKey;\n\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.EXTENSIONS;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.EXTENSIONS\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.EXTENSIONS\n                break;\n        }\n\n\n        switch (true) {\n            case A_TypeGuards.isRegExp(param1):\n                targetRegexp = param1;\n                break;\n\n            case !!param1 && typeof param1 === 'object':\n\n                if (Array.isArray(param1.scope))\n                    include = param1.scope;\n                else if (!!param1.scope && typeof param1.scope === 'object') {\n                    if (Array.isArray(param1.scope.include))\n                        include = param1.scope.include;\n                    if (Array.isArray(param1.scope.exclude))\n                        exclude = param1.scope.exclude;\n                }\n\n\n                targetRegexp = buildTargetRegexp(param1, include, exclude, propertyKey);\n\n                behavior = param1.behavior || behavior;\n                throwOnError = param1.throwOnError !== undefined ? param1.throwOnError : throwOnError;\n\n                before = A_TypeGuards.isArray(param1.before)\n                    ? new RegExp(`^${param1.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.before instanceof RegExp\n                        ? param1.before.source\n                        : ''\n                after = A_TypeGuards.isArray(param1.after)\n                    ? new RegExp(`^${param1.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.after instanceof RegExp\n                        ? param1.after.source\n                        : ''\n\n                override = A_TypeGuards.isArray(param1.override)\n                    ? new RegExp(`^${param1.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.override instanceof RegExp\n                        ? param1.override.source\n                        : ''\n                break;\n\n            default:\n                targetRegexp = new RegExp(`^.*${propertyKey.replace(/\\./g, '\\\\.')}$`);\n                break;\n        }\n\n\n\n\n\n        const existedDefinitions = A_Context\n            .meta(target)\n            .get(metaKey);\n\n\n        // Get the existed metadata or create a new one\n        const meta = A_Context\n            .meta(target)\n\n        const existedMeta = meta.get(metaKey)\n            ? new A_Meta().from(meta.get(metaKey)!)\n            : new A_Meta();\n\n        if (existedDefinitions\n            && existedDefinitions.size()\n            && existedDefinitions.has(propertyKey)\n            && existedDefinitions.get(propertyKey)!.invoke\n        ) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be used on the method \"${propertyKey}\" because it is already defined as a Feature with \"invoke\" set to true. Please remove the A-Feature-Extend decorator or set \"invoke\" to false in the A-Feature decorator.`\n            );\n        }\n\n        const existedMetaValue = [\n            ...(existedMeta.get(targetRegexp.source) || [])\n        ];\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const extension = {\n            name: targetRegexp.source,\n            handler: propertyKey,\n            behavior,\n            before,\n            after,\n            throwOnError,\n            override\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = extension;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(extension);\n        }\n\n        // Add the new method to the metadata\n        existedMetaValue.push();\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(targetRegexp.source, existedMetaValue);\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target)\n            .set(metaKey, existedMeta);\n    };\n}\n\n\n/**\n * Builds a target regular expression based on the provided parameters.\n * \n * @param param1 - The first parameter, which can be a string or an object.\n * @param include - An array of items to include in the regular expression.\n * @param exclude - An array of items to exclude from the regular expression.\n * @param propertyKey - The property key to use in the regular expression.\n * @returns A regular expression object.\n */\nexport function buildTargetRegexp(\n    param1: any,\n    include: any[],\n    exclude: any[],\n    propertyKey: string\n) {\n    const includePart = include.length\n        ? `(${include.map(el => el.name).join('|')})`\n        : `.*`;\n\n    const excludePart = exclude.length\n        ? `(?!${exclude.map(el => el.name).join('|')})`\n        : ``;\n\n    const pattern = param1.scope\n        ? `^${excludePart}${includePart}\\\\.${param1.name || propertyKey}$`\n        : `.*\\\\.${param1.name || propertyKey}$`;\n\n    return new RegExp(pattern);\n}","import { A_Container } from \"../A-Container/A-Container.class\"\nimport { A_TYPES__Component_Constructor } from \"../A-Component/A-Component.types\"\n\n\n\nexport enum A_TYPES__A_Stage_Status {\n    /**\n     * The stage is currently being processed\n     */\n    PROCESSING = 'PROCESSING',\n    /**\n     * The stage has been completed\n     */\n    COMPLETED = 'COMPLETED',\n    /**\n     * The stage has failed\n     */\n    FAILED = 'FAILED',\n    /**\n     * The stage has been skipped\n     */\n    SKIPPED = 'SKIPPED',\n    /**\n     * The stage has been paused\n     */\n    // PAUSED = 'PAUSED',\n    /**\n     * The stage has been stopped\n     */\n    // STOPPED = 'STOPPED',\n    /**\n     * The stage has been started\n     */\n    // STARTED = 'STARTED',\n    /**\n     * The stage has been initialized\n     */\n    INITIALIZED = 'INITIALIZED',\n    /**\n     * The stage has been aborted\n     */\n    ABORTED = 'ABORTED'\n}\n\nexport type A_TYPES_StageExecutionBehavior = 'async' | 'sync'\n\n\nexport type A_TYPES__A_StageStep = {\n    /**\n     * The component to be called\n     */\n    component: A_TYPES__Component_Constructor | A_Container | string\n    /**\n     * The method to be called on the component\n     */\n    handler: string,\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     * \n     */\n    name: string,\n\n    /**\n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string,\n\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * \n     */\n    override: string\n}\n\n\n\nexport type A_TYPES__Stage_Serialized = {\n\n    /**\n     * The name of the stage\n     */\n    name: string,\n\n    /**\n     *  The status of the stage\n     * \n     */\n    status: A_TYPES__A_Stage_Status,\n\n\n}\n\n\n\nexport type A_TYPES__A_StageStepProcessingExtraParams = {\n    steps: A_TYPES__A_StageStep[]\n    filter: (step: A_TYPES__A_StageStep) => boolean\n}\n","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\nexport class A_StageError extends A_Error {\n\n    static readonly ArgumentsResolutionError = 'A-Stage Arguments Resolution Error';\n\n\n    static get CompileError(): string {\n        return 'Unable to compile A-Stage';\n    }\n\n}\n","import {\n    A_TYPES__A_Stage_Status,\n    A_TYPES__A_StageStep,\n    A_TYPES__Stage_Serialized\n} from \"./A-Stage.types\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_StageError } from \"./A-Stage.error\";\nimport { A_Error } from \"../A-Error/A_Error.class\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__ScopeResolvableComponents } from \"../A-Scope/A-Scope.types\";\nimport { A_TYPES__Container_Constructor } from \"../A-Container/A-Container.types\";\nimport { A_TYPES__Component_Constructor } from \"../A-Component/A-Component.types\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n\nexport class A_Stage {\n\n    /**\n     * The feature that owns this stage\n     */\n    private readonly _feature!: A_Feature;\n    /**\n     * Initial Instructions to process the stage\n     */\n    private readonly _definition!: A_TYPES__A_StageStep;\n    /**\n     * Possible errors during stage processing\n     */\n    private _error?: A_Error;\n    /**\n     * Indicates the current status of the stage\n     */\n    private _status: A_TYPES__A_Stage_Status = A_TYPES__A_Stage_Status.INITIALIZED;\n\n    /**\n     * Promise that will be resolved when the stage is Processed\n     */\n    private _processed: Promise<void> | undefined;\n\n\n    /**\n     * A_Stage is a callable A_Function within A_Feature that should be run with specific parameters.\n     * [!] Depending on the Stage Definition type sync/async function can be executed correspondingly.\n     * \n     * A-Stage is a common object that uses to simplify logic and re-use of A-Feature internals for better composition. \n     */\n    constructor(\n        /**\n         * The feature that owns this stage\n         */\n        feature: A_Feature,\n        /**\n         * The step definitions of the stage\n         */\n        step: A_TYPES__A_StageStep\n    ) {\n        this._feature = feature;\n        this._definition = step;\n    }\n\n    /**\n     * Returns the name of the stage\n     */\n    get name(): string {\n        return this.toString();\n    }\n    /**\n     * Returns the definition of the stage\n     */\n    get definition(): A_TYPES__A_StageStep {\n        return this._definition;\n    }\n    /**\n     * Returns the current status of the stage\n     */\n    get status(): A_TYPES__A_Stage_Status {\n        return this._status;\n    }\n    /**\n     * Returns the feature that owns this stage\n     */\n    get feature(): A_Feature {\n        return this._feature;\n    }\n    /**\n     * Returns true if the stage is processed (completed, failed, or skipped)\n     */\n    get isProcessed(): boolean {\n        return this._status === A_TYPES__A_Stage_Status.COMPLETED\n            || this._status === A_TYPES__A_Stage_Status.FAILED\n            || this._status === A_TYPES__A_Stage_Status.SKIPPED;\n    }\n    /**\n     * Returns the error of the stage\n     */\n    get error(): A_Error | undefined {\n        return this._error;\n    }\n\n    /**\n     * Resolves the arguments of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected async getStepArgs(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        let resolverConstructor: A_TYPES__Container_Constructor | A_TYPES__Component_Constructor;\n\n        switch (true) {\n            case A_TypeGuards.isContainerInstance(step.component):\n                resolverConstructor = step.component.constructor as A_TYPES__Container_Constructor;\n                break;\n\n            case A_TypeGuards.isString(step.component):\n                resolverConstructor = scope.resolveConstructor(step.component);\n                break;\n\n            default:\n                resolverConstructor = step.component;\n                break;\n        }\n\n\n        return Promise\n            .all(A_Context\n                .meta(resolverConstructor)\n                .injections(step.handler)\n                .map(async arg => {\n                    switch (true) {\n                        case A_TypeGuards.isCallerConstructor(arg.target):\n                            return this._feature.caller.component;\n\n                        case A_TypeGuards.isFeatureConstructor(arg.target):\n                            return this._feature;\n\n                        default: {\n                            const { target, require, create, defaultArgs, parent, flat } = arg;\n\n\n                            let dependency;\n                            let targetScope = scope;\n\n\n                            switch (true) {\n                                // 1) Flat resolution\n                                case flat: {\n                                    dependency = targetScope.resolveFlat(target);\n                                    break;\n                                }\n                                // 2) Parent resolution\n                                case parent && typeof parent.layerOffset === 'number': {\n                                    const targetParent = targetScope.parentOffset(parent.layerOffset);\n                                    if (!targetParent) {\n                                        throw new A_StageError(\n                                            A_StageError.ArgumentsResolutionError,\n                                            `Unable to resolve parent scope at layer offset ${parent.layerOffset} for argument ${A_CommonHelper.getComponentName(arg.target)} for stage ${this.name} in scope ${scope.name}`\n                                        );\n                                    }\n                                    dependency = targetParent.resolve(target);\n                                    targetScope = targetParent;\n\n                                    break;\n                                }\n                                // 3) Normal resolution\n                                default: {\n                                    dependency = targetScope.resolve(target);\n                                    break;\n                                }\n                            }\n\n                            if (create && !dependency && A_TypeGuards.isAllowedForDependencyDefaultCreation(target)) {\n                                const newDependency = new target(...defaultArgs);\n\n                                targetScope.register(newDependency);\n                                return newDependency;\n                            }\n\n                            if (require && !dependency) {\n                                throw new A_StageError(\n                                    A_StageError.ArgumentsResolutionError,\n                                    `Unable to resolve required argument ${A_CommonHelper.getComponentName(arg.target)} for stage ${this.name} in scope ${scope.name}`\n                                );\n                            }\n\n                            return dependency;\n                        }\n                    }\n                })\n            )\n    }\n\n\n    /**\n     * Resolves the component of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected getStepComponent(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        const { component, handler } = step;\n\n        let instance: A_TYPES__ScopeResolvableComponents | undefined\n\n        switch (true) {\n            case A_TypeGuards.isContainerInstance(component):\n                instance = component;\n                break;\n\n            case A_TypeGuards.isString(component):\n                instance = scope.resolve(component) || this.feature.scope.resolve(component);\n                break;\n\n            default:\n                instance = scope.resolve(component) || this.feature.scope.resolve(component);\n                break;\n        }\n\n        if (!instance)\n            throw new A_StageError(A_StageError.CompileError, `Unable to resolve component ${typeof component === 'string' ? component : component.name} from scope ${scope.name}`);\n\n        if (!instance[handler])\n            throw new A_StageError(A_StageError.CompileError, `Handler ${handler} not found in ${instance.constructor.name}`);\n\n        return instance;\n    }\n\n\n\n    /**\n     * Calls the handler of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected async callStepHandler(\n        step: A_TYPES__A_StageStep,\n        scope: A_Scope\n    ) {\n        // 1) Resolve component\n        const component = await this.getStepComponent(scope, step);\n        // 2) Resolve arguments\n        const callArgs = await this.getStepArgs(scope, step);\n\n        // 3) Call handler\n        return await component[step.handler](...callArgs);\n    }\n\n\n    skip() {\n        this._status = A_TYPES__A_Stage_Status.SKIPPED;\n    }\n\n\n    /**\n     * This method processes the stage by executing all the steps\n     * \n     * @param scope - Scope to be used to resolve the steps dependencies\n     */\n    async process(\n        /**\n         * Scope to be used to resolve the steps dependencies\n         */\n        scope?: A_Scope,\n    ): Promise<void> {\n\n        const targetScope = A_TypeGuards.isScopeInstance(scope)\n            ? scope\n            : this._feature.scope;\n\n        if (!this._processed)\n            this._processed = new Promise<void>(\n                async (resolve, reject) => {\n                    try {\n                        this._status = A_TYPES__A_Stage_Status.PROCESSING;\n\n                        if (this._definition.behavior === 'sync') {\n                            // in case we have to wait for the result\n                            await this.callStepHandler(this._definition, targetScope);\n                        } else {\n                            // in case we don't have to wait for the result\n                            this.callStepHandler(this._definition, targetScope);\n                        }\n\n                        this.completed();\n\n                        return resolve();\n                    } catch (error) {\n                        const wrappedError = new A_Error(error as any);\n\n                        this.failed(wrappedError);\n\n                        if (this._definition.throwOnError) {\n                            return resolve();\n                        } else {\n                            return reject(wrappedError);\n                        }\n                    }\n                });\n\n        return this._processed;\n    }\n\n\n    // ==========================================\n    // ============ Status methods =============\n    // ==========================================\n\n    protected completed() {\n        this._status = A_TYPES__A_Stage_Status.COMPLETED;\n    }\n\n    protected failed(\n        error: Error | A_Error | any\n    ) {\n        this._error = new A_Error(error);\n\n        this._status = A_TYPES__A_Stage_Status.FAILED;\n    }\n\n\n\n    // ==========================================\n    // ============ Serialization ===============\n    // ==========================================\n    /**\n     * Serializes the stage to JSON\n     * \n     */\n    toJSON(): A_TYPES__Stage_Serialized {\n        return {\n            name: this.name,\n            status: this.status,\n        }\n    }\n\n    /**\n     * Returns a string representation of the stage\n     * \n     * @returns \n     */\n    toString() {\n        return `A-Stage(${this._feature.name}::${this._definition.behavior}@${this._definition.handler})`;\n    }\n}   ","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\n\nexport class A_StepManagerError extends A_Error {\n\n\n    static readonly CircularDependencyError = 'A-StepManager Circular Dependency Error';\n\n}","import { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_TYPES__FeatureDefineDecoratorTemplateItem } from \"../A-Feature/A-Feature.types\";\nimport { A_Stage } from \"../A-Stage/A-Stage.class\";\nimport { A_TYPES__A_StageStep } from \"../A-Stage/A-Stage.types\";\nimport { A_StepManagerError } from \"./A-StepManager.error\";\n\nexport class A_StepsManager {\n\n    public entities: A_TYPES__A_StageStep[];\n    public graph: Map<string, Set<string>>;\n    public visited: Set<string>;\n    public tempMark: Set<string>;\n    public sortedEntities: string[];\n\n\n    private _isBuilt: boolean = false;\n\n    constructor(entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>) {\n        this.entities = this.prepareSteps(entities);\n\n        this.graph = new Map();\n        this.visited = new Set();\n        this.tempMark = new Set();\n        this.sortedEntities = [];\n\n    }\n\n    private prepareSteps(\n        entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n    ): Array<A_TYPES__A_StageStep> {\n        return entities\n            .map(step => ({\n                ...step,\n\n                behavior: step.behavior || 'sync',\n                before: step.before || '',\n                after: step.after || '',\n                override: step.override || '',\n                throwOnError: false\n            }));\n    }\n\n    private ID(step: A_TYPES__A_StageStep) {\n        return `${typeof step.component === 'string' ? step.component : step.component.name}.${step.handler}`;\n    }\n\n    private buildGraph() {\n        if (this._isBuilt) return;\n        this._isBuilt = true;\n\n        // Filter override\n        this.entities = this.entities\n            .filter((step, i, self) =>\n                !self.some(s => s.override ? new RegExp(s.override).test(this.ID(step)) : false)\n            );\n\n        // Initialize graph nodes\n        this.entities.forEach(entity => this.graph.set(this.ID(entity), new Set()));\n\n        // Add directed edges based on 'before' and 'after'\n        this.entities.forEach(entity => {\n            const entityId = this.ID(entity);\n\n            // Add edges for 'before' dependencies\n            // If entity should execute before targets, then targets depend on entity\n            // So we add edges: target -> entity (target depends on entity)\n            if (entity.before) {\n                const targets = this.matchEntities(entityId, entity.before);\n                targets.forEach(target => {\n                    if (!this.graph.has(target)) this.graph.set(target, new Set());\n                    this.graph.get(target)!.add(entityId); // target depends on entity\n                });\n            }\n\n            // Add edges for 'after' dependencies  \n            // If entity should execute after sources, then entity depends on sources\n            // So we add edges: entity -> source (entity depends on source)\n            if (entity.after) {\n                const sources = this.matchEntities(entityId, entity.after);\n\n                sources.forEach(source => {\n                    if (!this.graph.has(entityId)) this.graph.set(entityId, new Set());\n                    this.graph.get(entityId)!.add(source); // entity depends on source\n                });\n            }\n        });\n    }\n\n    // Match entities by name or regex\n    private matchEntities(entityId: string, pattern: string): string[] {\n        const regex = new RegExp(pattern);\n\n        return this.entities\n            .filter(entity => regex.test(this.ID(entity)) && this.ID(entity) !== entityId)\n            .map(entity => this.ID(entity));\n    }\n\n    // Topological sort with cycle detection\n    private visit(node: string): void {\n        if (this.tempMark.has(node)) {\n            return;\n            // TODO: maybe we have to keep this error but only for partial cases\n            throw new A_StepManagerError(\n                A_StepManagerError.CircularDependencyError,\n                `Circular dependency detected involving step: ${node}. Make sure that your 'before' and 'after' dependencies do not create cycles.`\n            );\n        }\n\n        if (!this.visited.has(node)) {\n            this.tempMark.add(node);\n\n\n            (this.graph.get(node) || []).forEach(neighbor => this.visit(neighbor));\n            this.tempMark.delete(node);\n            this.visited.add(node);\n            this.sortedEntities.push(node);\n\n            // // Visit neighbors in stable order (preserving original order)\n            // const neighbors = Array.from(this.graph.get(node) || []);\n            // // neighbors.sort((a, b) => {\n            // //     const orderA = this.originalOrder.get(a) || 0;\n            // //     const orderB = this.originalOrder.get(b) || 0;\n            // //     return orderA - orderB;\n            // // });\n\n            // neighbors.forEach(neighbor => this.visit(neighbor));\n            // this.tempMark.delete(node);\n            // this.visited.add(node);\n            // this.sortedEntities.push(node);\n        }\n    }\n\n\n    toSortedArray(): Array<string> {\n        this.buildGraph();\n\n        // Start topological sort\n        this.entities.forEach(entity => {\n            if (!this.visited.has(this.ID(entity))) this.visit(this.ID(entity));\n        });\n\n        return this.sortedEntities;\n    }\n\n    // Sort the entities based on dependencies\n    toStages(feature: A_Feature): Array<A_Stage> {\n\n\n        const sortedNames = this.toSortedArray();\n\n\n        // Map sorted names back to entity objects\n        return sortedNames\n            .map(id => {\n                const step = this.entities.find(entity => this.ID(entity) === id)!;\n\n\n                return new A_Stage(feature, step);\n            });\n    }\n}\n\n\n","import {\n    A_TYPES__Feature_Init,\n    A_TYPES__Feature_InitWithComponent,\n    A_TYPES__Feature_InitWithTemplate,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureState,\n} from \"./A-Feature.types\";\nimport { A_Feature_Define } from \"@adaas/a-concept/global/A-Feature/A-Feature-Define.decorator\";\nimport { A_Feature_Extend } from \"@adaas/a-concept/global/A-Feature/A-Feature-Extend.decorator\";\nimport { A_Stage } from \"../A-Stage/A-Stage.class\";\nimport { A_StepsManager } from \"@adaas/a-concept/global/A-StepManager/A-StepManager.class\";\nimport { A_StageError } from \"../A-Stage/A-Stage.error\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Caller } from \"../A-Caller/A_Caller.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_Component } from \"../A-Component/A-Component.class\";\n\n\n/**\n * A_Feature is representing a feature that can be executed across multiple components\n * This class stores the steps of the feature and executes them in order of appearance\n * \n * Using A_Feature.Define and A_Feature.Extend decorators to define and extend the feature methods \n * across the different, distributed components\n * \n */\nexport class A_Feature<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    // =============================================================================\n    // --------------------------- Static Methods ---------------------------------\n    // =============================================================================\n    /**\n     * Define a new A-Feature\n     */\n    static get Define(): typeof A_Feature_Define {\n        return A_Feature_Define;\n    }\n\n    /**\n     * Extend an existing A-Feature\n     */\n    static get Extend(): typeof A_Feature_Extend {\n        return A_Feature_Extend;\n    }\n    // =============================================================================\n    // --------------------------- Internal Properties ----------------------------\n    // =============================================================================\n    /**\n     * The name of the Feature\n     */\n    protected _name!: string;\n    /**\n     * List of stages that are part of this Feature\n     */\n    protected _stages: Array<A_Stage> = [];\n    /**\n     * The Stage currently being processed\n     */\n    protected _current?: A_Stage;\n    /**\n     * Actual Index of the current Stage being processed\n     */\n    protected _index: number = 0;\n    /**\n     * Steps Manager to organize the steps into stages\n     */\n    protected _SM!: A_StepsManager;\n    /**\n     * The Caller that initiated the Feature call\n     */\n    protected _caller!: A_Caller<T>;\n    /**\n     * The current state of the Feature\n     */\n    protected _state: A_TYPES__FeatureState = A_TYPES__FeatureState.INITIALIZED;\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    protected _error?: A_FeatureError\n\n\n\n    /**\n     * A-Feature is a pipeline distributed by multiple components that can be easily attached or detached from the scope. \n     * Feature itself does not have scope, but attached to the caller who dictates how feature should be processed. \n     * \n     * Comparing to A-Command Feature does not store any state except statuses for better analysis. \n     * \n     * [!] Note: If A-Feature should have result use A-Fragment \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Feature Initialization parameters\n         */\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        this.validateParams(params);\n\n        const initializer = this.getInitializer(params);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, params);\n    }\n\n\n    /**\n     * The name of the Feature\n     */\n    get name(): string { return this._name; }\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    get error(): A_FeatureError | undefined { return this._error; }\n    /**\n     * The current state of the Feature\n     */\n    get state(): A_TYPES__FeatureState { return this._state; }\n    /**\n     * Sets the current state of the Feature\n     */\n    get index(): number { return this._index; }\n    /**\n     * Returns the current A-Feature Stage\n     */\n    get stage(): A_Stage | undefined { return this._current; }\n    /**\n     * The Caller that initiated the Feature call\n     */\n    get caller(): A_Caller<T> { return this._caller; }\n    /**\n     * The Scope allocated for the Feature Execution\n     */\n    get scope(): A_Scope { return A_Context.scope(this); }\n    /**\n     * The number of stages in the feature\n     */\n    get size(): number {\n        return this._stages.length;\n    }\n\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.stage\n            || this._index >= this._stages.length;\n    }\n    /**\n     * Indicates whether the feature has been processed (completed, failed, or interrupted)\n     */\n    get isProcessed(): boolean {\n        return this.state === A_TYPES__FeatureState.COMPLETED\n            || this.state === A_TYPES__FeatureState.FAILED\n            || this.state === A_TYPES__FeatureState.INTERRUPTED;\n    }\n    /**\n     * Iterator to iterate over the steps of the feature\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<A_Stage, any> {\n        return {\n            next: (): IteratorResult<A_Stage, any> => {\n                if (!this.isDone) {\n                    this._current = this._stages[this._index];\n                    this._index++;\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    // ============================================================================\n    // ------------------------ Initialization Methods ----------------------------\n    // ============================================================================\n    /**\n     * Validates the provided parameters for A-Feature initialization\n     * \n     * @param params \n     */\n    protected validateParams(\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        if (!params || typeof params !== 'object') {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n            );\n        }\n    }\n    /**\n     * Returns the appropriate initializer method based on the provided parameters\n     * \n     * @param params \n     * @returns \n     */\n    protected getInitializer(\n        params: A_TYPES__Feature_Init<T>\n    ): (param1: any) => void | (() => void) {\n\n        switch (true) {\n            case !('template' in params):\n                return this.fromComponent;\n\n            case 'template' in params:\n                return this.fromTemplate;\n            default:\n                throw new A_FeatureError(\n                    A_FeatureError.FeatureInitializationError,\n                    `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n                );\n        }\n    }\n    /**\n     * Initializes the A-Feature from the provided template\n     * \n     * @param params \n     */\n    protected fromTemplate(\n        params: A_TYPES__Feature_InitWithTemplate<T>\n    ) {\n        if (!params.template || !Array.isArray(params.template)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature template provided of type: ${typeof params.template} with value: ${JSON.stringify(params.template).slice(0, 100)}...`\n            );\n        }\n\n        if (!params.component && (!params.scope || !(params.scope instanceof A_Scope))) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature scope provided of type: ${typeof params.scope} with value: ${JSON.stringify(params.scope).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            if (params.component)\n                componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        //   - Just to prevent issues with undefined caller in features without component\n        //   - TODO: maybe would be better to allow passing caller in params?\n        this._caller = new A_Caller<T>(params.component || new A_Component() as T);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(params.template);\n\n        // 7) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 8) set the first stage as current\n        this._current = this._stages[0];\n    }\n    /**\n     * Initializes the A-Feature from the provided component\n     * \n     * @param params \n     */\n    protected fromComponent(\n        params: A_TYPES__Feature_InitWithComponent<T>\n    ) {\n        if (!params.component || !A_TypeGuards.isAllowedForFeatureDefinition(params.component)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature component provided of type: ${typeof params.component} with value: ${JSON.stringify(params.component).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        this._caller = new A_Caller<T>(params.component);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) retrieve the template from the context\n        const template = A_Context.featureTemplate(this._name, this._caller.component, scope);\n\n        // 7) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(template);\n\n        // 8) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 9) set the first stage as current\n        this._current = this._stages[0];\n    }\n\n\n    // ============================================================================\n    // ----------------------- Main Processing Methods ----------------------------\n    // ============================================================================\n    /**\n     * This method processes the feature by executing all the stages\n     * \n     */\n    async process(\n        /**\n         * Optional scope to be used to resolve the steps dependencies\n         * If not provided, the scope of the caller component will be used\n         */\n        scope?: A_Scope,\n    ) {\n        try {\n            // It seems like this is a bad idea to enforce scope inheritance here\n            // ---------------------------------------------------------------\n            // if (scope && !scope.isInheritedFrom(A_Context.scope(this)))\n            //     scope.inherit(A_Context.scope(this));\n\n            if (this.isProcessed)\n                return;\n\n            this._state = A_TYPES__FeatureState.PROCESSING;\n\n            for (const stage of this) {\n                await stage.process(scope);\n            }\n\n            return await this.completed();\n        } catch (error) {\n            return await this.failed(new A_FeatureError({\n                title: A_FeatureError.FeatureProcessingError,\n                description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${this.stage?.name || 'N/A'}.`,\n                stage: this.stage,\n                originalError: error\n            }));\n        }\n\n    }\n    /**\n     * This method moves the feature to the next stage\n     * \n     * @param stage \n     */\n    next(stage) {\n        const stageIndex = this._stages.indexOf(stage);\n\n        this._index = stageIndex + 1;\n\n        if (this._index >= this._stages.length) {\n            this.completed();\n        }\n    }\n    /**\n     * This method marks the feature as completed and returns the result\n     * Uses to interrupt or end the feature processing\n     * \n     * @param result \n     * @returns \n     */\n    async completed(): Promise<void> {\n        if (this.isProcessed) return;\n\n\n        this._state = A_TYPES__FeatureState.COMPLETED;\n\n        this.scope.destroy();\n    }\n    /**\n     * This method marks the feature as failed and throws an error\n     * Uses to mark the feature as failed\n     * \n     * @param error \n     */\n    async failed(error: A_FeatureError) {\n        if (this.isProcessed) return;\n\n        this._state = A_TYPES__FeatureState.FAILED;\n\n        this._error = error;\n\n        this.scope.destroy();\n\n        throw this._error;\n    }\n    /**\n     * This method marks the feature as failed and throws an error\n     * Uses to interrupt or end the feature processing\n     * \n     * @param error \n     */\n    async interrupt(\n        /**\n         * The reason of feature interruption\n         */\n        reason?: string | A_StageError | Error\n    ) {\n        if (this.isProcessed) return;\n\n        this._state = A_TYPES__FeatureState.INTERRUPTED;\n\n        switch (true) {\n            case A_TypeGuards.isString(reason):\n                this._error = new A_FeatureError(A_FeatureError.Interruption, reason);\n                break;\n\n            case A_TypeGuards.isErrorInstance(reason):\n                this._error = new A_FeatureError({\n                    code: A_FeatureError.Interruption,\n                    title: reason.title,\n                    description: reason.description,\n                    stage: this.stage,\n                    originalError: reason\n                });\n                break;\n\n            default:\n                break;\n        }\n\n\n        this.scope.destroy();\n    }\n\n\n    /**\n     * Allows to chain the feature to another feature. \n     * In this case the parent feature scope (if new not provided), stages, caller will be used.\n     * \n     * [!] Note: Chained feature will use the same caller as the parent feature.\n     * \n     * @param feature \n     */\n    chain(\n        /**\n         * A Feature to be chained\n         */\n        feature: A_Feature,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        /**\n         * Component whose feature should be chained\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * A Feature Name to be chained\n         */\n        feature: string,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        param1: A_TYPES__FeatureAvailableComponents | A_Feature,\n        param2?: string | A_Scope,\n        param3?: A_Scope\n    ) {\n        let feature: A_Feature;\n        let scope: A_Scope | undefined;\n\n        if (param1 instanceof A_Feature) {\n            feature = param1;\n            scope = param2 instanceof A_Scope ? param2 : undefined;\n        } else {\n            feature = new A_Feature({\n                name: param2 as string,\n                component: param1 as T\n            });\n            scope = param3 instanceof A_Scope ? param3 : undefined;\n        }\n\n        const featureScope = scope || this.scope;\n\n        // create new caller for the chained feature\n        feature._caller = this._caller;\n\n        return feature.process(featureScope);\n    }\n\n\n\n\n    toString(): string {\n        return `A-Feature(${this.caller.component?.constructor?.name || 'Unknown'}::${this.name})`;\n    }\n}","import { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\n\n\n\n/**\n * A-Component is a primary \"extendable\" object in the system\n * A unique combination of Components creates completely new functionality\n * \n * The most important thing is that A-Component is STATELESS, it means that it doesn't store any state in itself\n * \n * \n * [!] Every A-Component is a singleton, so if you need to create multiple instances of the same logic - use A-Container\n * [!] So one scope can have only one instance of the same A-Component\n * [!] Every A-Component can be extended by features and extensions\n * [!] ONLY A-Component can have A-Feature extensions\n *\n */\nexport class A_Component {\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    async call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * Scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return await newFeature.process(scope);\n    }\n}\n\n\n\n","import { A_Error } from \"../A-Error/A_Error.class\";\n\n\n\nexport class A_ContextError extends A_Error {\n\n\n    static NotAllowedForScopeAllocationError = 'Component is not allowed for scope allocation';\n\n    static ComponentAlreadyHasScopeAllocatedError = 'Component already has scope allocated';\n\n    static InvalidMetaParameterError = 'Invalid parameter provided to get meta';\n\n    static InvalidScopeParameterError = 'Invalid parameter provided to get scope';\n\n    static ScopeNotFoundError = 'Scope not found';\n\n    static InvalidFeatureParameterError = 'Invalid parameter provided to get feature';\n\n    static InvalidFeatureDefinitionParameterError = 'Invalid parameter provided to define feature';\n\n    static InvalidFeatureTemplateParameterError = 'Invalid parameter provided to get feature template';\n\n    static InvalidFeatureExtensionParameterError = 'Invalid parameter provided to extend feature';\n\n\n    static InvalidAbstractionParameterError = 'Invalid parameter provided to get abstraction';\n\n    static InvalidAbstractionDefinitionParameterError = 'Invalid parameter provided to define abstraction';\n\n    static InvalidAbstractionTemplateParameterError = 'Invalid parameter provided to get abstraction template';\n\n    static InvalidAbstractionExtensionParameterError = 'Invalid parameter provided to extend abstraction';\n\n    static InvalidInjectionParameterError = 'Invalid parameter provided to get injections';\n\n    static InvalidExtensionParameterError = 'Invalid parameter provided to get extensions';\n\n\n    static InvalidRegisterParameterError = 'Invalid parameter provided to register component';\n\n\n    static InvalidComponentParameterError = 'Invalid component provided';\n\n    static ComponentNotRegisteredError = 'Component not registered in the context';\n\n    static InvalidDeregisterParameterError = 'Invalid parameter provided to deregister component';\n}","import {\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeConfig,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES_ScopeDependentComponents\n} from \"../A-Scope/A-Scope.types\";\nimport {\n    A_TYPES__MetaLinkedComponentConstructors,\n    A_TYPES__MetaLinkedComponents\n} from \"../A-Meta/A-Meta.types\";\nimport {\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureDefineDecoratorMeta\n} from \"../A-Feature/A-Feature.types\";\nimport { A_Component } from \"../A-Component/A-Component.class\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_Container } from \"../A-Container/A-Container.class\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_Meta } from \"../A-Meta/A-Meta.class\";\nimport { A_ComponentMeta } from \"../A-Component/A-Component.meta\";\nimport { A_ContainerMeta } from \"../A-Container/A-Container.meta\";\nimport { A_Entity } from \"../A-Entity/A-Entity.class\";\nimport { A_EntityMeta } from \"../A-Entity/A-Entity.meta\";\nimport { A_TYPES__A_StageStep } from \"../A-Stage/A-Stage.types\";\nimport { A_CONSTANTS__DEFAULT_ENV_VARIABLES } from \"@adaas/a-concept/constants/env.constants\";\nimport { A_TYPES__EntityMetaKey } from \"../A-Entity/A-Entity.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"../A-Container/A-Container.constants\";\nimport { A_TYPES__ComponentMetaKey } from \"../A-Component/A-Component.constants\";\nimport { A_TYPES__ContextEnvironment } from \"./A-Context.types\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_ContextError } from \"./A-Context.error\";\nimport { A_TYPES__Container_Constructor } from \"../A-Container/A-Container.types\";\nimport { A_TYPES__Entity_Constructor } from \"../A-Entity/A-Entity.types\";\nimport { A_TYPES__Component_Constructor } from \"../A-Component/A-Component.types\";\nimport { A_FormatterHelper } from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_Fragment } from \"../A-Fragment/A-Fragment.class\";\nimport { A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__ConceptAbstractions } from \"../A-Concept/A-Concept.constants\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n\nexport class A_Context {\n    // ====================================================================================================\n    // ================================ STATIC PROPERTIES =================================================\n    // ====================================================================================================\n    /**\n     * Default name of the application from environment variable A_CONCEPT_NAME\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_NAME] || 'a-concept';\n    }\n    /**\n     * Root scope of the application from environment variable A_CONCEPT_ROOT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'root'\n     */\n    static get root(): A_Scope {\n        return this.getInstance()._root;\n    }\n    /**\n     * Environment the application is running in.\n     * Can be either 'server' or 'browser'.\n     * [!] Determined by checking if 'window' object is available.\n     */\n    static get environment(): A_TYPES__ContextEnvironment {\n        let testEnvironment: A_TYPES__ContextEnvironment = 'browser';\n\n        try {\n            testEnvironment = window.location ? 'browser' : 'server';\n        } catch (error) {\n            testEnvironment = 'server';\n        }\n\n        return testEnvironment;\n    }\n\n    /**\n     * Singleton instance of the Context\n     */\n    private static _instance: A_Context;\n    // ====================================================================================================\n    // ================================ INTERNAL REGISTRY =================================================\n    // ====================================================================================================\n    /**\n     * Root Scope of the Concept and Environment\n     *\n     * Root scope is the top-level scope that all other scopes inherit from.\n     * It stores global configurations and settings and ALL SHAREABLE RESOURCES.\n     * \n     * [!] Root scope is created automatically when the Context is initialized.\n     * [!] Root scope name can be configured using environment variable A_CONCEPT_ROOT_SCOPE\n     */\n    private _root!: A_Scope\n    /**\n     * A registry that keeps track of scopes for all components (Containers, Features, Commands) \n     * Which can issue a scope allocation.\n     */\n    protected _registry: WeakMap<A_TYPES__ScopeLinkedComponents, A_Scope> = new WeakMap();\n    /**\n     * This is a registry that stores an issuer of each scope allocation.\n     * It helps to track which component (Container, Feature, Command) allocated a specific scope.\n     */\n    protected _scopeIssuers: WeakMap<A_Scope, A_TYPES__ScopeLinkedComponents> = new WeakMap();\n    /**\n     * Stores a context associated with a specific component that depends on a scope.\n     * uses for quick retrieval of the scope for the component.\n     */\n    protected _scopeStorage: WeakMap<A_TYPES_ScopeDependentComponents, A_Scope> = new WeakMap();\n    /**\n     * Stores meta information for different component types by their constructors.\n     * Meta provides to store extra information about the class behavior and configuration.\n     */\n    protected _metaStorage: Map<A_TYPES__MetaLinkedComponentConstructors, A_Meta> = new Map();\n\n\n\n    /**\n     * Private constructor to enforce singleton pattern.\n     * \n     * [!] This class should not be instantiated directly. Use A_Context.getInstance() instead.\n     */\n    private constructor() {\n        let name = 'root';\n\n        if (A_Context.environment === 'server')\n            name = process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE] || 'root';\n\n        if (A_Context.environment === 'browser')\n            name = (window as any)[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE] || 'root';\n\n        this._root = new A_Scope({ name });\n    }\n\n\n\n    /**\n     * Get the instance of the Namespace Provider.\n     * \n     * If the instance does not exist, it will be created.\n     * \n     * @returns \n     */\n    static getInstance() {\n        if (!A_Context._instance) {\n            A_Context._instance = new A_Context();\n        }\n\n        return A_Context._instance;\n    }\n\n\n\n    /**\n     * Register method allows to register a component with a specific scope in the context.\n     * \n     * @param component - Component to register with a specific scope. Can be either A_Container, A_Feature.\n     * @param scope - Scope to associate the component with.\n     * @returns \n     */\n    static register(\n        /**\n         * Provide the scope that will be associated with the component.\n         */\n        scope: A_Scope,\n        /**\n         * Provide a component that needs to be registered with a specific scope.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Component cannot be null or undefined.`);\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Scope cannot be null or undefined.`);\n\n        if (!this.isAllowedToBeRegistered(component)) throw new A_ContextError(\n            A_ContextError.NotAllowedForScopeAllocationError,\n            `Component ${componentName} is not allowed for scope allocation.`);\n\n        instance._scopeStorage.set(component, scope);\n\n        return scope;\n    }\n\n    /**\n     * Deregister method allows to deregister a component from the context.\n     * \n     * @param component - Component to deregister from the context.\n     */\n    static deregister(\n        /**\n         * Provide a component that needs to be deregistered from the context.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n    ): void {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidDeregisterParameterError,\n            `Unable to deregister component. Component cannot be null or undefined.`);\n\n        if (!instance._scopeStorage.has(component)) throw new A_ContextError(\n            A_ContextError.ComponentNotRegisteredError,\n            `Unable to deregister component. Component ${componentName} is not registered.`);\n\n        instance._scopeStorage.delete(component);\n    }\n\n    /**\n     * Allocate method instantiates a new scope for the given component and registers it in the context.\n     * It bounds the component (Container, Feature) to a new scope that can be configured and used independently.\n     * \n     * \n     * @param component - Component to allocate the scope for. Can be either A_Container, A_Feature.\n     * @param importing  - Configuration of the scope that will be created for the component.\n     */\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide the scope that will be used as a base for the new scope.\n         */\n        importing: A_Scope\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide configuration for the scope that will be created for the component.\n         */\n        config: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig>\n    ): A_Scope\n    static allocate(\n        component: A_TYPES__ScopeLinkedComponents,\n        importing?: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig> | A_Scope\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // ---------------------------------------------------------------------\n        // ----------------------Input Validation-------------------------------\n        // ---------------------------------------------------------------------\n        // 1) check if component is valid\n        if (!this.isAllowedForScopeAllocation(component))\n            throw new A_ContextError(A_ContextError.NotAllowedForScopeAllocationError, `Component of type ${componentName} is not allowed for scope allocation. Only A_Container, A_Feature are allowed.`);\n        const instance = this.getInstance();\n\n        // 2) check if component already has a scope allocated\n        if (instance._registry.has(component))\n            throw new A_ContextError(A_ContextError.ComponentAlreadyHasScopeAllocatedError, `Component ${componentName} already has a scope allocated.`);\n\n\n        // 3) Create a new scope for the component\n        const newScope = A_TypeGuards.isScopeInstance(importing)\n            ? importing\n            : new A_Scope(importing || {\n                name: componentName + '-scope'\n            }, importing);\n\n        // 4) Make sure that the new scope inherits from the root scope\n        if (!newScope.isInheritedFrom(A_Context.root))\n            newScope.inherit(A_Context.root);\n\n        // 5) Register the component in the appropriate storage\n        instance._registry.set(component, newScope);\n        // Also register the issuer of the scope for faster tracking\n        instance._scopeIssuers.set(newScope, component);\n\n        // 6) Return the newly created scope\n        return newScope;\n    }\n\n    /**\n     * Deallocate method removes the scope allocation for the given component from the context.\n     * \n     * @param component \n     * @returns \n     */\n    static deallocate(\n        /**\n         * A Scope that needs to be deallocated.\n         */\n        scope: A_Scope,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        param1: A_TYPES__ScopeLinkedComponents | A_Scope,\n    ) {\n        const instance = this.getInstance();\n\n        const scope = A_TypeGuards.isScopeInstance(param1)\n            ? param1\n            : instance._registry.get(param1);\n\n        if (!scope) return;\n\n        const component = A_TypeGuards.isComponentInstance(param1)\n            ? param1\n            : this.issuer(scope);\n\n        if (component)\n            instance._registry.delete(component);\n        if (scope)\n            instance._scopeIssuers.delete(scope);\n    }\n\n\n\n    /**\n      * Get or Create Meta for the specific class or instance.\n      * This method will return the existing meta if it exists, or create a new one if it doesn't.\n      * \n      * Meta object contains custom metadata based on the class type.\n      * \n      * @param container \n      */\n    static meta(\n        /**\n         * Get meta for the specific container class by constructor.\n         */\n        container: A_TYPES__Container_Constructor,\n    ): A_ContainerMeta\n    static meta(\n        /**\n         * Get meta for the specific container instance.\n         */\n        container: A_Container,\n    ): A_ContainerMeta\n    static meta(\n        /**\n         * Get meta for the specific entity class by constructor.\n         */\n        entity: A_TYPES__Entity_Constructor,\n    ): A_EntityMeta\n    static meta(\n        /**\n         * Get meta for the specific entity instance.\n         */\n        entity: A_Entity,\n    ): A_EntityMeta\n    static meta(\n        /**\n         * Get meta for the specific component class by constructor.\n         */\n        component: A_TYPES__Component_Constructor,\n    ): A_ComponentMeta\n    static meta(\n        /**\n         * Get meta for the specific component instance.\n         */\n        component: A_Component,\n    ): A_ComponentMeta\n    static meta(\n        /**\n         * Get meta for the specific component by its name.\n         */\n        component: string,\n    ): A_ComponentMeta\n    static meta(\n        /**\n         * Get meta for the specific injectable target (class or instance).\n         */\n        target: A_TYPES__InjectableTargets,\n    ): A_ComponentMeta\n    static meta<T extends Record<string, any>>(\n        /**\n         * Get meta for the specific class or instance\n         */\n        constructor: new (...args: any[]) => any\n    ): A_Meta<T>\n\n    static meta<T extends Record<string, any>>(\n        param1: A_TYPES__MetaLinkedComponentConstructors\n            | A_TYPES__MetaLinkedComponents\n            | string\n    ): A_Meta<T> {\n\n        // Get the component name for error messages\n        const componentName = A_CommonHelper.getComponentName(param1);\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for meta storage\n        if (!(\n            this.isAllowedForMeta(param1)\n            || this.isAllowedForMetaConstructor(param1)\n            || A_TypeGuards.isString(param1)\n            || A_TypeGuards.isFunction(param1\n            ))\n        ) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component of type ${componentName} is not allowed for meta storage. Only A_Container, A_Component and A_Entity are allowed.`);\n\n        let property: A_TYPES__MetaLinkedComponentConstructors;\n        let metaType: typeof A_Meta<T> | typeof A_ContainerMeta | typeof A_ComponentMeta | typeof A_EntityMeta\n\n        switch (true) {\n            // 1) If param1 is instance of A_Container\n            case A_TypeGuards.isContainerInstance(param1): {\n                property = param1.constructor as A_TYPES__Container_Constructor;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 2) If param1 is class of A_Container\n            case A_TypeGuards.isContainerConstructor(param1): {\n                property = param1 as typeof A_Container;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 3) If param1 is instance of A_Component\n            case A_TypeGuards.isComponentInstance(param1): {\n                property = param1.constructor as A_TYPES__Component_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 4) If param1 is class of A_Component\n            case A_TypeGuards.isComponentConstructor(param1): {\n                property = param1 as typeof A_Component;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 5) If param1 is instance of A_Entity\n            case A_TypeGuards.isEntityInstance(param1): {\n                property = param1.constructor as A_TYPES__Entity_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 6) If param1 is class of A_Entity\n            case A_TypeGuards.isEntityConstructor(param1): {\n                property = param1;\n                metaType = A_EntityMeta;\n\n                break;\n            }\n            // 7) If param1 is string then we need to find the component by its name\n            case typeof param1 === 'string': {\n                const found = Array.from(instance._metaStorage)\n                    .find(([c]) => c.name === param1\n                        || c.name === A_FormatterHelper.toKebabCase(param1)\n                        || c.name === A_FormatterHelper.toPascalCase(param1)\n                    )!;\n                if (!(found && found.length))\n                    throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component with name ${param1} not found in the meta storage.`);\n\n                property = found[0];\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 8) If param1 is any other class or function\n            default: {\n                property = param1;\n                metaType = A_Meta;\n\n                break;\n            }\n        }\n\n        // Check if the meta already exists for the property, if not create a new one\n        if (!instance._metaStorage.has(property)) {\n            const inheritMeta = instance._metaStorage.get(Object.getPrototypeOf(property)) || new metaType();\n            instance._metaStorage.set(property, new metaType().from(inheritMeta as any));\n        }\n\n        // Return the meta for the property\n        return instance._metaStorage.get(property)!;\n    }\n\n\n    /**\n     * \n     * This method allows to get the issuer of a specific scope.\n     * \n     * @param scope - Scope to get the issuer for.\n     * @returns - Component that issued the scope.\n     */\n    static issuer(\n        /**\n         * Provide the scope to get its issuer.\n         */\n        scope: A_Scope\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const instance = this.getInstance();\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidComponentParameterError,\n            `Invalid parameter provided to get scope issuer. Parameter cannot be null or undefined.`\n        );\n\n        // if (!instance._scopeIssuers.has(scope)) throw new A_ContextError(\n        //     A_ContextError.ScopeNotFoundError,\n        //     `Invalid parameter provided to get scope issuer. Provided scope does not have an issuer registered.`\n        // );\n\n        return instance._scopeIssuers.get(scope)!;\n    }\n\n\n\n    /**\n     * Get the scope of the specific class or instance.\n     * \n     * Every execution in Concept has its own scope.\n     * \n     * This method will return the scope of the specific class or instance.\n     * \n     * @param entity \n     */\n    static scope<T extends A_Entity>(\n        /**\n         * Provide an entity to get its scope.\n         */\n        entity: T\n    ): A_Scope\n    static scope<T extends A_Component>(\n        /**\n         * Provide a component to get its scope.\n         */\n        component: T\n    ): A_Scope\n    static scope<T extends A_Container>(\n        /**\n         * Provide a container to get its scope.\n         */\n        container: T\n    ): A_Scope\n    static scope<T extends A_Feature>(\n        /**\n         * Provide a feature to get its scope.\n         */\n        feature: T\n    ): A_Scope\n    static scope<T extends A_Fragment>(\n        /**\n         * Provide a fragment to get its scope.\n         */\n        fragment: T\n    ): A_Scope\n    static scope<T extends A_TYPES__ScopeLinkedComponents | A_TYPES_ScopeDependentComponents>(\n        param1: T\n    ): A_Scope {\n\n        // for error messages\n        const name = (param1 as any)?.constructor?.name || String(param1);\n\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        // Input validation\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for scope allocation\n        if (!this.isAllowedForScopeAllocation(param1)\n            && !this.isAllowedToBeRegistered(param1)\n        )\n            throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed for scope allocation.`);\n\n        switch (true) {\n            case this.isAllowedForScopeAllocation(param1):\n\n                // Check if the parameter has a scope allocated\n                if (!instance._registry.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope allocated. Make sure to allocate a scope using A_Context.allocate() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed for scope allocation, return the scope\n                return instance._registry.get(param1)!;\n\n            case this.isAllowedToBeRegistered(param1):\n\n                // Check if the parameter has a scope registered\n                if (!instance._scopeStorage.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope registered. Make sure to register the component using A_Context.register() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed to be registered, return the scope from the storage\n                return instance._scopeStorage.get(param1)!;\n            default:\n                throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed to be registered.`);\n        }\n    }\n\n\n    // ==========================================================================================================\n    // ================================== FEATURE MANAGEMENT ====================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a template of the feature that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the feature.\n     * \n     * @param name \n     */\n    static featureTemplate(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope = this.scope(component)\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base feature definition from the component\n            ...this.featureDefinition(name, component),\n            // 2) Get all extensions for the feature from other components in the scope\n            ...this.featureExtensions(name, component, scope)\n        ];\n\n        return steps;\n    }\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns all extensions for the specific feature in the specific component within the provided scope.\n     * Scope dictates which components are active and can provide extensions for the feature.\n     * \n     * [!] This method only returns extensions, not the base feature definition.\n     * \n     * @param scope \n     * @returns \n     */\n    static featureExtensions(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope\n    ): Array<A_TYPES__A_StageStep> {\n\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n\n        const callNames = A_CommonHelper.getClassInheritanceChain(component)\n            .filter(c => c !== A_Component && c !== A_Container && c !== A_Entity)\n            .map(c => `${c.name}.${name}`);\n\n        // const callName = `${component.constructor.name}.${name}`;\n\n        const steps: A_TYPES__A_StageStep[] = [];\n\n        for (const callName of callNames) {\n            // We need to get all components that has extensions for the feature in component\n            for (const [cmp, meta] of instance._metaStorage) {\n                // Just try to make sure that component not only Indexed but also presented in scope\n                if (scope.has(cmp) && (\n                    A_TypeGuards.isComponentMetaInstance(meta)\n                    || A_TypeGuards.isContainerMetaInstance(meta)\n                )) {\n                    // Get all extensions for the feature\n                    meta\n                        .extensions(callName)\n                        .forEach((declaration) => {\n                            steps.push({\n                                component: cmp,\n                                ...declaration\n                            });\n                        });\n                }\n            }\n        }\n\n        return instance.filterToMostDerived(scope, steps);\n    }\n\n\n    /**\n     * method helps to filter steps in a way that only the most derived classes are kept.\n     * \n     * @param scope \n     * @param items \n     * @returns \n     */\n    private filterToMostDerived(\n        scope: A_Scope,\n        items: A_TYPES__A_StageStep[]): Array<A_TYPES__A_StageStep> {\n        return items.filter(item => {\n            const currentClass = typeof item.component === 'string'\n                ? scope.resolveConstructor(item.component)\n                : A_TypeGuards.isContainerInstance(item.component)\n                    ? item.component.constructor : item.component;\n\n            // Check if this class is parent of any other in the list\n            const isParentOfAnother = items.some(other => {\n                if (other === item) return false;\n\n                const otherClass = typeof other.component === 'string'\n                    ? scope.resolveConstructor(other.component)\n                    : A_TypeGuards.isContainerInstance(other.component)\n                        ? other.component.constructor\n                        : other.component;\n\n\n                return currentClass.prototype.isPrototypeOf(otherClass.prototype);\n            });\n\n            // Keep only classes that are not parent of any other\n            return !isParentOfAnother;\n        });\n    }\n\n\n    /**\n     * This method returns the feature template definition without any extensions.\n     * It can be used to retrieve the base template for a feature before any modifications are applied.\n     * \n     * [!] This method does not consider extensions from other components.\n     * \n     * @param feature \n     * @param component \n     * @returns \n     */\n    static featureDefinition(\n        /**\n         * Name of the feature to get the template for.\n         * Regular expressions are also supported to match multiple features.\n         */\n        feature: string | RegExp,\n        /**\n         * Component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        let metaKey;\n\n        if (!feature)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n        if (!component)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n\n\n        switch (true) {\n            case component instanceof A_Entity:\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case component instanceof A_Container:\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case component instanceof A_Component:\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n\n            default:\n                throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `A-Feature cannot be defined on the ${component} level`);\n        }\n\n        const featureDefinition: A_TYPES__FeatureDefineDecoratorMeta | undefined = this.meta(component)\n            ?.get(metaKey)\n            ?.get(feature);\n\n        return [\n            ...(featureDefinition?.template || [])\n        ];\n    }\n\n    // ==========================================================================================================\n    // ================================== ABSTRACTION MANAGEMENT =================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a definition of the abstraction that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the abstraction.\n     * \n     * @param abstraction \n     */\n    static abstractionTemplate(\n        /**\n         * Provide the abstraction stage to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = (A_CommonHelper.getComponentName(component));\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`);\n\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidAbstractionTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base abstraction definition from the component\n            // [!] No abstraction Definitions -> They are limited to Concept Abstractions ONLY\n            // ...this.abstractionDefinition(abstraction, component),\n\n            // 2) Get all extensions for the abstraction from other components in the scope\n            ...this.abstractionExtensions(abstraction, component)\n        ];\n\n        return steps;\n    }\n\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n\n    static abstractionExtensions(\n        /**\n         * Provide the abstraction name to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`\n        );\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`\n        );\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError\n                (A_ContextError.InvalidAbstractionExtensionParameterError,\n                    `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`\n                );\n\n        const steps: A_TYPES__A_StageStep[] = [];\n\n        const scope = this.scope(component);\n\n        // We need to get all components that has extensions for the feature in component\n        for (const [cmp, meta] of instance._metaStorage) {\n            // Just try to make sure that component not only Indexed but also presented in scope\n            if (scope.has(cmp) && (\n                A_TypeGuards.isComponentMetaInstance(meta)\n                || A_TypeGuards.isContainerMetaInstance(meta)\n            )) {\n                // Get all extensions for the feature\n                meta\n                    .abstractions(abstraction)\n                    .forEach((declaration) => {\n                        steps.push({\n                            component: cmp,\n                            ...declaration\n                        });\n                    });\n            }\n        }\n\n        return instance.filterToMostDerived(scope, steps);\n    }\n\n\n    /**\n     * Resets the Context to its initial state.\n     */\n    static reset() {\n        const instance = A_Context.getInstance();\n\n        instance._registry = new WeakMap();\n\n        let name = 'root';\n\n        if (A_Context.environment === 'server')\n            name = process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE] || 'root';\n\n        if (A_Context.environment === 'browser')\n            name = (window as any)[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE] || 'root';\n\n        instance._root = new A_Scope({ name });\n    }\n\n\n\n\n    // ====================================================================================================================\n    // ====================================== HELPERS & GUARDS ============================================================\n    // ====================================================================================================================\n    /**\n     * Type guard to check if the param is allowed for scope allocation.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForScopeAllocation(param: any): param is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isFeatureInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed to be registered in the context.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedToBeRegistered(param: any): param is A_TYPES_ScopeDependentComponents {\n        return A_TypeGuards.isEntityInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isFragmentInstance(param)\n            || A_TypeGuards.isErrorInstance(param);\n    }\n\n    /**\n     * Type guard to check if the param is allowed for meta storage.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMeta(param: any): param is A_TYPES__MetaLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed for meta storage by constructor.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMetaConstructor(param: any): param is A_TYPES__MetaLinkedComponentConstructors {\n        return A_TypeGuards.isContainerConstructor(param)\n            || A_TypeGuards.isComponentConstructor(param)\n            || A_TypeGuards.isEntityConstructor(param);\n    }\n\n\n\n}","import { A_Error } from \"../A-Error/A_Error.class\";\n\nexport class A_AbstractionError extends A_Error {\n    /**\n     * This error code indicates that there was an issue extending the abstraction execution\n     */\n    static readonly AbstractionExtensionError = 'Unable to extend abstraction execution';\n\n}","import {\n    A_TYPES__AbstractionDecoratorConfig,\n    A_TYPES__AbstractionDecoratorDescriptor\n} from \"./A-Abstraction.types\";\nimport { A_Component } from \"@adaas/a-concept/global/A-Component/A-Component.class\";\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Container } from \"@adaas/a-concept/global/A-Container/A-Container.class\";\nimport { A_ContainerMeta } from \"@adaas/a-concept/global/A-Container/A-Container.meta\";\nimport { A_ComponentMeta } from \"@adaas/a-concept/global/A-Component/A-Component.meta\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ConceptAbstractions } from \"@adaas/a-concept/global/A-Concept/A-Concept.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ConceptAbstraction } from \"@adaas/a-concept/global/A-Concept/A-Concept.types\";\nimport { A_AbstractionError } from \"./A-Abstraction.error\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * A-Abstraction Extend decorator allows to extends behavior of each concept abstraction execution. \n * In case some components or containers requires to extend the behavior of the abstraction like 'start', 'build' or 'deploy'\n * for example, this decorator allows to do so.    \n * \n * @param name - abstraction name \n * @param config - configuration of the abstraction extension\n * @returns \n */\nexport function A_Abstraction_Extend(\n    /**\n     * Name of the Concept Abstraction to extend\n     */\n    name: A_TYPES__ConceptAbstractions,\n    /**\n     * Configuration of the Abstraction Extension\n     * \n     */\n    config: Partial<A_TYPES__AbstractionDecoratorConfig> = {}\n) {\n    return function (\n        target: A_Container | A_Component,\n        propertyKey: string,\n        descriptor: A_TYPES__AbstractionDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!name)\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Abstraction name must be provided to extend abstraction for '${componentName}'.`,\n            );\n\n        //  Only Containers and Components can extend Concept Abstractions\n        if (!A_TypeGuards.isConstructorAvailableForAbstraction(target)) {\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Unable to extend Abstraction '${name}' for '${componentName}'. Only A-Containers and A-Components can extend Abstractions.`,\n            );\n        }\n\n        let metaKey;\n        const meta: A_ContainerMeta | A_ComponentMeta = A_Context.meta(target);\n\n        switch (true) {\n            case A_TypeGuards.isContainerConstructor(target) || A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.ABSTRACTIONS\n                break;\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.ABSTRACTIONS\n                break;\n        }\n        const setName = `CONCEPT_ABSTRACTION::${name}`;\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            [Key: string]: A_TYPES__ConceptAbstraction[];\n        }> = meta.get(metaKey) ?\n                new A_Meta().from(meta.get(metaKey))\n                : new A_Meta();\n\n        // Set the metadata of the method to define a custom Stage with name\n        const existedMetaValue = [\n            ...(existedMeta.get(setName) || [])\n        ];\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const abstraction = {\n            name: setName,\n            handler: propertyKey,\n            behavior: config.behavior || 'sync',\n            throwOnError: config.throwOnError !== undefined ? config.throwOnError : true,\n\n            before: A_TypeGuards.isArray(config.before)\n                ? new RegExp(`^${config.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.before instanceof RegExp\n                    ? config.before.source\n                    : '',\n            after: A_TypeGuards.isArray(config.after)\n                ? new RegExp(`^${config.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n\n            override: A_TypeGuards.isArray(config.override)\n                ? new RegExp(`^${config.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = abstraction;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(abstraction);\n        }\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(setName, existedMetaValue);\n\n        //  Update the metadata of the container with the new Stage definition\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    };\n}\n","import { A_Abstraction_Extend } from \"@adaas/a-concept/global/A-Abstraction/A-Abstraction-Extend.decorator\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\nimport { A_TYPES__Abstraction_Init } from \"./A-Abstraction.types\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_TYPES__ConceptAbstractions } from \"../A-Concept/A-Concept.constants\";\n\n\n\nexport class A_Abstraction {\n\n    /**\n     * The name of the Abstraction e.g. 'deploy', 'start', 'test', etc.\n     */\n    protected _name: A_TYPES__ConceptAbstractions;\n    /**\n     * List of features that are part of this Abstraction\n     */\n    protected _features: A_Feature[] = [];\n    /**\n     * The Feature currently being processed\n     */\n    protected _current?: A_Feature;\n    /**\n     * Actual Index of the current Feature being processed\n     */\n    protected _index: number = 0;\n\n\n    /**\n     * Allows to extends A-Abstraction with additional methods\n     */\n    static get Extend(): typeof A_Abstraction_Extend {\n        return A_Abstraction_Extend;\n    }\n\n    /**\n     * A-Abstraction is an object that is common for any application. \n     * By providing components and creating abstraction extensions it's possible to create a unique behavior of the whole solution.\n     * \n     * Every application has basic abstractions like 'start', 'stop', 'deploy', 'test', etc. \n     * They can be easily extended with additional logic from both containers and components.\n     * \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Parameters to define the A-Abstraction\n         */\n        params: A_TYPES__Abstraction_Init\n    ) {\n        this._name = params.name;\n\n        this._features = params.containers.map(container => {\n            const template = A_Context.abstractionTemplate(\n                this._name,\n                container\n            );\n            return new A_Feature({\n                name: this._name,\n                component: container,\n                template\n            })\n        });\n\n        this._current = this._features[0];\n    }\n\n    /**\n     * Returns the name of the Abstraction\n     */\n    get name(): string { return this._name; }\n    /**\n     * Returns the current Feature being processed\n     */\n    get feature(): A_Feature | undefined {\n        return this._current;\n    }\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.feature\n            || this._index >= this._features.length\n\n    }\n\n\n    [Symbol.iterator](): Iterator<A_Feature, any> {\n        return {\n            // Custom next method\n            next: (): IteratorResult<A_Feature, any> => {\n                if (!this.isDone) {\n\n                    this._current = this._features[this._index];\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    /**\n     * This method moves the Abstraction processing to the next Feature in the list\n     * \n     * @param stage \n     */\n    next(stage) {\n        if (this._index >= this._features.length) {\n            return;\n        }\n\n        const stageIndex = this._features.indexOf(stage);\n\n        this._index = stageIndex + 1;\n    }\n\n\n\n    /**\n     * Allows to process all stages of the Abstraction\n     * \n     * @returns \n     */\n    async process(\n        /**\n         * Allows to override the scope in which the Abstraction will be processed\n         * \n         */\n        scope?: A_Scope\n    ) {\n        if (this.isDone)\n            return;\n\n        for (const feature of this._features) {\n\n            await feature.process(scope);\n        }\n    }\n}","export enum A_TYPES__ConceptAbstractions {\n    /**\n     * Run the concept.\n     */\n    Run = 'run',\n    /**\n     * Build the concept.\n     */\n    Build = 'build',\n    /**\n     * Publish the concept.\n     */\n    Publish = 'publish',\n    /**\n     * Deploy the concept.\n     */\n    Deploy = 'deploy',\n    /**\n     * Load the concept.\n     */\n    Load = 'load',\n    /**\n     * Start the concept.\n     */\n    Start = 'start',\n    /**\n     * Stop the concept.\n     */\n    Stop = 'stop',\n}\n\n\n\nexport enum A_TYPES__ConceptMetaKey {\n    LIFECYCLE = 'a-component-extensions',\n}","import { A_Container } from \"../A-Container/A-Container.class\";\nimport { A_Abstraction } from \"../A-Abstraction/A-Abstraction.class\";\nimport { A_Abstraction_Extend } from \"@adaas/a-concept/global/A-Abstraction/A-Abstraction-Extend.decorator\";\nimport { A_Scope } from \"../A-Scope/A-Scope.class\";\nimport { A_Context } from \"../A-Context/A-Context.class\";\nimport { A_TYPES__ConceptAbstractions } from \"./A-Concept.constants\";\nimport { A_TYPES__Concept_Init } from \"./A-Concept.types\";\nimport { A_TYPES__AbstractionDecoratorConfig } from \"../A-Abstraction/A-Abstraction.types\";\nimport { A_Feature } from \"../A-Feature/A-Feature.class\";\n\n\n\nexport class A_Concept<\n    _Imports extends A_Container[] = A_Container[]\n> {\n\n    // ==============================================================================\n    // ====================  STATIC LIFECYCLE DECORATORS  ===========================\n    // ==============================================================================\n    /**\n     * Load the concept. This step runs before any other steps to ensure that all components are loaded.\n     */\n    static Load(\n        /**\n         * provide additional configuration for the abstraction extension to make it dependent on other factors\n         */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ): ReturnType<typeof A_Abstraction_Extend> {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Load, config);\n    }\n\n    /**\n     * Publish the concept to ADAAS platform. (Or any other place defined in the concept)\n     *\n     * [!] To extend the logic just create a custom containers and override the default behavior.\n     */\n    static Publish(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ): ReturnType<typeof A_Abstraction_Extend> {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Publish);\n    }\n\n    /**\n     * Deploy the concept to the environment.\n     */\n    static Deploy(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Deploy, config);\n    }\n\n    /**\n     * Compiles the Concept in case there are some containers that require that. \n     * \n     * Can be used for static websites or any other concept that requires a build step.\n     * \n     */\n    static Build(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Build, config);\n    }\n\n    /**\n     *  Main execution of the concept.\n     */\n    static Run(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Run, config);\n    }\n\n    /**\n     *  Start the concept. Uses for servers or any other background services.\n     */\n    static Start(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Start, config);\n    }\n\n    /**\n     * Stop the concept. Uses for servers or any other background services.\n     */\n    static Stop(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Stop, config);\n    }\n\n\n    /**\n     * Name of the concept\n     * \n     * By default, the name of the Concept is 'a-concept'\n     */\n    private _name!: string;\n    /**\n     * A list of internally defined containers that the concept uses.\n     */\n    protected _containers!: A_Container[];\n\n\n\n    // ==============================================================================\n    // ==========================  MAIN Methods  ======================================\n    // ==============================================================================\n\n\n    /**\n     * A-Concept is a placeholder for the concept of the any program.\n     * \n     * Concept - could be any Program regardless environment and it's goal.\n     * It could be mobile, web or simple html page.\n     * All depends on Containers and Components installed and provided in the Concept.\n     * \n     * \n     * [!] Concept operates ONLY with all Components and Containers provided to achieve the goal.\n     * \n     * \n     * @param props - Initialization properties for the Concept\n     */\n    constructor(\n        protected props: A_TYPES__Concept_Init<_Imports>\n    ) {\n        this._name = props.name || A_Context.root.name;\n\n        if (props.components && props.components.length)\n            props.components.forEach(component => this.scope.register(component))\n\n        if (props.fragments && props.fragments.length)\n            props.fragments.forEach(fragment => this.scope.register(fragment))\n\n        if (props.entities && props.entities.length)\n            props.entities.forEach(entity => this.scope.register(entity as any))\n\n\n        this._containers = props.containers || [];\n    }\n\n    /**\n     * Name of the concept\n     */\n    get name() {\n        return A_Context.root.name;\n    }\n    /**\n     * The primary Root scope of the concept.\n     */\n    get scope() {\n        return A_Context.root;\n    }\n\n    /**\n     * Register a class or value in the concept scope.\n     */\n    get register(): A_Scope['register'] {\n        return this.scope.register.bind(this.scope);\n    }\n\n    /**\n     * Resolve a class or value from the concept scope.\n     */\n    get resolve(): A_Scope['resolve'] {\n        return this.scope.resolve.bind(this.scope);\n    }\n\n\n    // =======================================================================\n    // ==========================  LIFECYCLE  ================================\n    // =======================================================================\n    /**\n     * Load the concept.\n     */\n    async load(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Load,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Run the concept.\n     */\n    async run(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Run,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Start the concept.\n     * \n     * @param params \n     */\n    async start(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Start,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Stop the concept.\n     * \n     * @param params \n     */\n    async stop(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Stop,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Build the concept.\n     */\n    async build(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Build,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Deploy the concept.\n     */\n    async deploy(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Deploy,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n\n    }\n    /**\n     * Publish the concept.\n     */\n    async publish(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Publish,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n\n\n    // =======================================================================\n    // ==========================  CALL  =====================================\n    // =======================================================================\n\n\n    /**\n     * Call the specific method of the concept or included modules.\n     */\n    async call<\n        K extends Record<_Imports[number]['name'], string>\n    >(\n        /**\n         * Name of the method to call\n         */\n        method: K[keyof K],\n        /**\n         * Container in which the method is located\n         */\n        container: _Imports[number],\n    ) {\n        const feature = new A_Feature({ name: method, component: container });\n\n        return await feature.process();\n    }\n}\n\n\n\n\n","\nimport { A_Container } from \"@adaas/a-concept/global/A-Container/A-Container.class\";\nimport { A_Meta } from \"../A-Meta/A-Meta.class\";\n\n\n\nexport class A_ConceptMeta extends A_Meta<any> {\n\n\n    constructor(\n        private containers: Array<A_Container>,\n    ) {\n        super();\n    }\n\n\n}","import { A_Error } from \"../A-Error/A_Error.class\";\n\nexport class A_DependencyError extends A_Error {\n\n    static readonly InvalidDependencyTarget = 'Invalid Dependency Target';\n\n    static readonly InvalidLoadTarget = 'Invalid Load Target';\n\n    static readonly InvalidLoadPath = 'Invalid Load Path';\n\n\n    static readonly InvalidDefaultTarget = 'Invalid Default Target';\n}","\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__A_InjectDecorator_Meta, A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__A_Dependency_DefaultDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Default is required\n */\nexport function A_Dependency_Default(\n    /**\n     * Constructor Parameters that will be used to create the default instance\n     */\n    ...args: any[]\n): A_TYPES__A_Dependency_DefaultDecoratorReturn {\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDefaultTarget,\n                `A-Default cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            ...(paramsArray[parameterIndex] || {}),\n            defaultArgs: args,\n            create: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__A_InjectDecorator_Meta, A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__A_Dependency_FlatDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Flat(): A_TYPES__A_Dependency_FlatDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            ...(paramsArray[parameterIndex] || {}),\n            flat: true,\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__A_InjectDecorator_Meta, A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__A_Dependency_LoadDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Load is required\n */\nexport function A_Dependency_Load(\n    /**\n     * Path to load the dependency from\n     */\n    path: string\n): A_TYPES__A_Dependency_LoadDecoratorReturn {\n\n    if (!path || typeof path !== 'string') {\n        throw new A_DependencyError(\n            A_DependencyError.InvalidLoadPath,\n            `A-Load decorator requires a valid path string to the dependency`\n        );\n    }\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target);\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidLoadTarget,\n                `A-Load cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            ...(paramsArray[parameterIndex] || {}),\n            load: path\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__A_InjectDecorator_Meta, A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__A_Dependency_ParentDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Parent(\n    /**\n     * Indicates how many layers up the parent dependency should be resolved from current dependency\n     * \n     * Default: -1 (one layer up)\n     */\n    layerOffset: number = -1\n): A_TYPES__A_Dependency_ParentDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            ...(paramsArray[parameterIndex] || {}),\n            parent: { layerOffset }\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__A_InjectDecorator_Meta, A_TYPES__InjectableTargets } from \"../A-Inject/A-Inject.types\";\nimport { A_TYPES__A_Dependency_RequireDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Require(): A_TYPES__A_Dependency_RequireDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            ...(paramsArray[parameterIndex] || {}),\n            require: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Dependency_Default } from \"./A-Dependency-Default.decorator\";\nimport { A_Dependency_Flat } from \"./A-Dependency-Flat.decorator\";\nimport { A_Dependency_Load } from \"./A-Dependency-Load.decorator\";\nimport { A_Dependency_Parent } from \"./A-Dependency-Parent.decorator\";\nimport { A_Dependency_Require } from \"./A-Dependency-Require.decorator\";\n\n\nexport class A_Dependency {\n    /**\n     * Allows to indicate which Injected parameter is required\n     * \n     * [!] If parameter marked as required is not provided, an error will be thrown\n     * \n     * @returns \n     */\n    static get Required(): typeof A_Dependency_Require {\n        return A_Dependency_Require;\n    }\n    /**\n     * Allows to indicate which dependency should be loaded from a specific path\n     * \n     * @returns \n     */\n    static get Loaded(): typeof A_Dependency_Load {\n        return A_Dependency_Load;\n    }\n    /**\n     * Allows to indicate which dependency default parameters should be used\n     * \n     * @returns \n     */\n    static get Default(): typeof A_Dependency_Default {\n        return A_Dependency_Default;\n    }\n    /**\n     * Allows to indicate which parent dependency should be resolved\n     * e.g. from which layer up the parent should be taken\n     * \n     * @returns \n     */\n    static get Parent(): typeof A_Dependency_Parent {\n        return A_Dependency_Parent;\n    }\n\n    /**\n     * Allows to indicate that the dependency should be resolved in a flat manner\n     * Only in the same scope, without going up to parent scopes\n     * \n     * @returns \n     */\n    static get Flat(): typeof A_Dependency_Flat {\n        return A_Dependency_Flat;\n    }\n\n    protected _name: string;\n\n    /**\n     * Class instances allows to indentify dependencies by name and use them for better type checking\n     * \n     * @param name \n     */\n    constructor(\n        name: string\n    ) {\n        this._name = name;\n    }\n\n    /**\n     * Gets the dependency name\n     * \n     * Can be identifier, url or any string value\n     * \n     * @returns \n     */\n    get name(): string {\n        return this._name;\n    }\n}","import { A_Error } from \"@adaas/a-concept/global/A-Error/A_Error.class\";\n\n\nexport class A_InjectError extends A_Error {\n    static readonly InvalidInjectionTarget = 'Invalid target for A-Inject decorator';\n\n    static readonly MissingInjectionTarget = 'Missing target for A-Inject decorator';\n}","import {\n    A_TYPES__A_InjectDecorator_EntityInjectionInstructions,\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__A_InjectDecoratorReturn,\n    A_TYPES__InjectableConstructors,\n    A_TYPES__InjectableTargets\n} from \"./A-Inject.types\";\nimport { A_Component } from \"@adaas/a-concept/global/A-Component/A-Component.class\";\nimport { A_Fragment } from \"@adaas/a-concept/global/A-Fragment/A-Fragment.class\";\nimport { A_Context } from \"@adaas/a-concept/global/A-Context/A-Context.class\";\nimport { A_TYPES__Component_Constructor } from \"@adaas/a-concept/global/A-Component/A-Component.types\";\nimport { A_Meta } from \"@adaas/a-concept/global/A-Meta/A-Meta.class\";\nimport { A_Entity } from \"@adaas/a-concept/global/A-Entity/A-Entity.class\";\nimport { A_TYPES__Feature_Constructor } from \"@adaas/a-concept/global/A-Feature/A-Feature.types\";\nimport { A_Caller } from \"@adaas/a-concept/global/A-Caller/A_Caller.class\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/global/A-Component/A-Component.constants\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/global/A-Container/A-Container.constants\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_InjectError } from \"./A-Inject.error\";\nimport { A_TYPES__Entity_Constructor } from \"@adaas/a-concept/global/A-Entity/A-Entity.types\";\nimport { A_TYPES__Fragment_Constructor } from \"@adaas/a-concept/global/A-Fragment/A-Fragment.types\";\nimport { A_Scope } from \"@adaas/a-concept/global/A-Scope/A-Scope.class\";\nimport { A_TYPES__Scope_Constructor } from \"@adaas/a-concept/global/A-Scope/A-Scope.types\";\nimport { A_Feature } from \"@adaas/a-concept/global/A-Feature/A-Feature.class\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_TYPES__Error_Constructor } from \"../A-Error/A_Error.types\";\nimport { A_Error } from \"../A-Error/A_Error.class\";\nimport { A_TYPES__EntityMetaKey } from \"../A-Entity/A-Entity.constants\";\n\n\n/**\n * A-Inject decorator\n * \n * This Decorator allows to inject dependencies into the module like \n * - Namespaces \n * - Other Concepts \n * - or maybe Components\n * \n * @param params - see overloads\n * @returns - decorator function\n */\nexport function A_Inject<T extends A_Scope>(\n    /***\n     * Provide the Scope constructor that will be associated with the injection.\n     *\n     * [!] It returns an instance of the Scope where the Entity/Component/Container is defined.\n     */\n    scope: A_TYPES__Scope_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Error>(\n    /***\n     * Provide the Error constructor that will be associated with the injection.\n     *\n     * [!] It returns an Instance of the Error what is executed.\n     */\n    error: A_TYPES__Error_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Feature>(\n    /**\n     * Provide the Feature constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Feature what is executed. \n     */\n    feature: A_TYPES__Feature_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the Component constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Component from current Scope or from Parent Scopes.\n     */\n    component: A_TYPES__Component_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\n//  Allows to inject just one A_FeatureCaller\nexport function A_Inject(\n    /**\n     * Provide the A_Caller constructor to inject the Caller instance\n     *\n     * [!] It returns initiator of the call, e.g. Container/Component/Command who called Feature \n     */\n    caller: typeof A_Caller\n): A_TYPES__A_InjectDecoratorReturn\n// Allows to inject just one Context Fragment\nexport function A_Inject<T extends A_Fragment>(\n    /**\n     * Provide the Fragment constructor to inject the Fragment instance\n     *\n     * [!] It returns the Fragment instance from current Scope or from Parent Scopes.\n     */\n    fragment: A_TYPES__Fragment_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Entity>(\n    /**\n     * Provide the Entity constructor to inject the Entity instance\n     * \n     * [!] Note: It returns the Entity instance from current Scope or from Parent Scopes.\n     * [!] Note: If instance has more than one Entity of the same type It returns FIRST found Entity\n     * [!] Note: Use 'config' to specify to inject specific one or even Array of Entities\n     */\n    entity: A_TYPES__Entity_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     * \n     * [!] Default Pagination is 1 if it's necessary to get multiple Entities please customize it in the instructions\n     */\n    config?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions<T>>\n): A_TYPES__A_InjectDecoratorReturn<T>\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the name of Component constructor to inject the Component instance\n     * \n     * [!] You can use both customized one or original depending on your overriding strategy\n     */\n    ctor: string\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject(\n    param1: A_TYPES__InjectableConstructors,\n    param2?: Partial<A_TYPES__A_InjectDecorator_EntityInjectionInstructions>\n): A_TYPES__A_InjectDecoratorReturn {\n\n    //  pre call checks\n    if (!param1) {\n        throw new A_InjectError(\n            A_InjectError.MissingInjectionTarget,\n            `A-Inject decorator is missing the target to inject`\n        );\n    }\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_InjectError(\n                A_InjectError.InvalidInjectionTarget,\n                `A-Inject cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = {\n            target: param1,\n            instructions: param2\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}"]}