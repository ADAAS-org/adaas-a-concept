{"version":3,"sources":["../../src/lib/A-Fragment/A-Fragment.class.ts","../../src/lib/A-Feature/A-Feature.types.ts","../../src/helpers/A_Formatter.helper.ts","../../src/helpers/A_Identity.helper.ts","../../src/helpers/A_BasicTypeGuards.helper.ts","../../src/lib/ASEID/ASEID.class.ts","../../src/lib/A-Error/A_Error.constants.ts","../../src/env/env.base.ts","../../src/constants/env.constants.ts","../../src/env/env-browser.ts","../../src/lib/A-Error/A_Error.class.ts","../../src/lib/A-Entity/A-Entity.error.ts","../../src/lib/A-Entity/A-Entity.class.ts","../../src/lib/A-Meta/A-Meta.decorator.ts","../../src/lib/A-Meta/A-Meta.class.ts","../../src/lib/A-Entity/A-Entity.constants.ts","../../src/lib/A-Entity/A-Entity.meta.ts","../../src/lib/A-Container/A-Container.class.ts","../../src/lib/A-Container/A-Container.constants.ts","../../src/lib/A-Container/A-Container.meta.ts","../../src/lib/A-Feature/A-Feature.error.ts","../../src/helpers/A_Common.helper.ts","../../src/lib/A-Caller/A_Caller.error.ts","../../src/lib/A-Caller/A_Caller.class.ts","../../src/lib/A-Dependency/A-Dependency.error.ts","../../src/lib/A-Dependency/A-Dependency-Default.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Flat.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Load.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Parent.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Require.decorator.ts","../../src/lib/A-Dependency/A-Dependency-All.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Query.decorator.ts","../../src/lib/A-Dependency/A-Dependency.class.ts","../../src/helpers/A_TypeGuards.helper.ts","../../src/lib/A-Feature/A-Feature-Define.decorator.ts","../../src/lib/A-Feature/A-Feature-Extend.decorator.ts","../../src/lib/A-Stage/A-Stage.types.ts","../../src/lib/A-Stage/A-Stage.error.ts","../../src/lib/A-Stage/A-Stage.class.ts","../../src/lib/A-StepManager/A-StepManager.error.ts","../../src/lib/A-StepManager/A-StepManager.class.ts","../../src/lib/A-Feature/A-Feature.class.ts","../../src/lib/A-Component/A-Component.class.ts","../../src/lib/A-Component/A-Component.constants.ts","../../src/lib/A-Component/A-Component.meta.ts","../../src/lib/A-Scope/A-Scope.class.ts","../../src/lib/A-Scope/A-Scope.error.ts","../../src/lib/A-Context/A-Context.error.ts","../../src/lib/A-Context/A-Context.class.ts","../../src/lib/A-Abstraction/A-Abstraction.error.ts","../../src/lib/A-Abstraction/A-Abstraction-Extend.decorator.ts","../../src/lib/A-Abstraction/A-Abstraction.class.ts","../../src/lib/A-Concept/A-Concept.constants.ts","../../src/lib/A-Concept/A-Concept.class.ts","../../src/lib/A-Concept/A-Concept.meta.ts","../../src/lib/A-Inject/A-Inject.error.ts","../../src/lib/A-Inject/A-Inject.decorator.ts"],"names":["A_Fragment","params","A_TYPES__FeatureState","A_FormatterHelper","str","part","index","A_IdentityHelper","parts","time","random","id","timePart","randomPart","number","maxZeros","formattedNumber","input","hash","i","chr","A_BasicTypeGuards","_A_BasicTypeGuards","value","param","scope","_ASEID","identity","aseid1","aseid2","aseidObj1","aseidObj2","param1","A_Context","concept","body","version","entity","idCandidate","shard","ASEID","A_CONSTANTS__ERROR_CODES","A_CONSTANTS__ERROR_DESCRIPTION","A_CONCEPT_BASE_ENV","name","A_CONSTANTS__DEFAULT_ENV_VARIABLES","A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY","A_CONCEPT_ENV","allEnv","key","variable","keys","A_Error","_A_Error","param2","error","message","serialized","title","description","rootError","A_EntityError","A_Entity","props","x","override","feature","A_Feature","aseid","newEntity","A_MetaDecorator","constructor","target","A_Meta","_A_Meta","iterator","meta","inheritedValue","results","regex","obj","k","v","item","res","json","A_TYPES__EntityMetaKey","A_TYPES__EntityFeatures","A_EntityMeta","handler","A_Container","config","A_TYPES__ContainerMetaKey","A_ContainerMeta","abstraction","steps","abstractions","injections","extensions","extension","args","A_FeatureError","A_CommonHelper","resolve","childClass","parentClass","current","parents","chain","paths","result","removeProperties","currPath","currKey","path","pathKeys","source","visited","clone","component","UNKNOWN","ANONYMOUS","fnAny","match","objAny","s","A_CallerError","A_Caller","A_TypeGuards","A_DependencyError","A_Dependency_Default","methodName","parameterIndex","componentName","method","metaKey","existedMeta","paramsArray","A_Dependency_Flat","A_Dependency_Load","A_Dependency_Parent","layerOffset","A_Dependency_Require","A_Dependency_All","A_Dependency_Query","query","pagination","A_Dependency","resolutionStrategy","strategy","_A_TypeGuards","ctor","A_Component","A_Scope","instance","A_ComponentMeta","A_Feature_Define","propertyKey","descriptor","invoke","originalMethod","A_Feature_Extend","targetRegexp","behavior","before","after","include","exclude","throwOnError","buildTargetRegexp","existedDefinitions","existedMetaValue","handlers","indexInAnother","existedIndex","includePart","el","excludePart","pattern","A_TYPES__A_Stage_Status","A_StageError","A_Stage","step","resolverConstructor","dependency","callArgs","targetScope","reject","wrappedError","A_StepManagerError","A_StepsManager","entities","self","entityId","node","neighbor","_A_Feature","componentScope","externalScope","template","stages","stage","stageIndex","reason","param3","featureScope","A_TYPES__ComponentMetaKey","currentParent","parentScope","A_ScopeError","_components","_errors","_entities","ent","_fragments","_meta","fragment","parent","circularCheck","scopes","found","c","f","e","resolved","newDependency","dep","count","from","startSliceIndex","endSliceIndex","slice","protoComponent","protoEntity","protoFragment","importedScope","importedConstructor","instances","importedValue","issuer","fragmentInstancePresented","resolvedArgs","newComponent","code","acc","inheritanceChain","A_ContextError","_A_Context","importing","newScope","property","metaType","inheritedMeta","currentProperty","existingMeta","callNames","allowedComponents","callName","cmp","declaration","inherited","items","currentClass","other","otherClass","A_AbstractionError","A_Abstraction_Extend","setName","A_Abstraction","container","A_TYPES__ConceptAbstractions","A_TYPES__ConceptMetaKey","A_Concept","A_ConceptMeta","containers","A_InjectError","A_Inject"],"mappings":"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","file":"index.mjs","sourcesContent":["import { A_TYPES__Fragment_Init, A_TYPES__Fragment_Serialized } from \"./A-Fragment.types\";\n\n\n/**\n * A_Fragment is a core architectural component that represents a singleton execution context\n * within the A-Concept framework. It serves as a shared memory container that can be passed\n * between Components, Entities, and Commands throughout the application pipeline.\n * \n * Key Features:\n * - Singleton pattern: Only one instance per fragment type per scope\n * - Meta storage: Built-in key-value storage for pipeline data\n * - Type-safe: Full TypeScript generics support for meta items and serialization\n * - Serializable: Can be converted to JSON for persistence or transmission\n * \n * @template _MetaItems - Type definition for the meta storage structure\n * @template _SerializedType - Type definition for the serialized output format\n * \n * @example\n * ```typescript\n * // Basic usage with typed meta\n * class UserFragment extends A_Fragment<{ userId: string; role: string }> {\n *   constructor() {\n *     super({ name: 'UserFragment' });\n *   }\n * }    \n * \n * // Custom serialization\n * class SessionFragment extends A_Fragment<\n *   { sessionId: string; timestamp: number },\n *   { name: string; sessionData: string }\n * > {\n *   toJSON() {\n *     return {\n *       name: this.name,\n *       sessionData: `${this.get('sessionId')}-${this.get('timestamp')}`\n *     };\n *   }\n * }\n * ```\n */\nexport class A_Fragment<\n    _SerializedType extends A_TYPES__Fragment_Serialized = A_TYPES__Fragment_Serialized\n> {\n    /**\n     * The unique identifier/name for this fragment instance.\n     * Used for identification and debugging purposes.\n     */\n    protected _name: string;\n\n    /**\n     * Creates a new A_Fragment instance.\n     * \n     * A_Fragment implements the singleton pattern for execution contexts, allowing\n     * shared state management across different parts of the application pipeline.\n     * Each fragment serves as a memory container that can store typed data and be\n     * serialized for persistence or transmission.\n     * \n     * Key Benefits:\n     * - Centralized state management for related operations\n     * - Type-safe meta operations with full IntelliSense support\n     * - Serialization support for data persistence \n     * - Singleton pattern ensures consistent state within scope\n     * \n     * @param params - Initialization parameters\n     * @param params.name - Optional custom name for the fragment (defaults to class name)\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string }>({ \n     *   name: 'UserSessionFragment' \n     * });\n     * fragment.set('userId', '12345');\n     * ```\n     */\n    constructor(params: Partial<A_TYPES__Fragment_Init> = {}) {\n        this._name = params.name || this.constructor.name;\n    }\n\n    /**\n     * Gets the fragment's unique name/identifier.\n     * \n     * @returns The fragment name\n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Serializes the fragment to a JSON-compatible object.\n     * \n     * This method combines the fragment's name with all meta data to create\n     * a serializable representation. The return type is determined by the\n     * _SerializedType generic parameter, allowing for custom serialization formats.\n     * \n     * @returns A serialized representation of the fragment\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string, role: string }>({\n     *   name: 'UserFragment'\n     * });\n     * fragment.set('userId', '12345');\n     * fragment.set('role', 'admin');\n     * \n     * const json = fragment.toJSON();\n     * // Result: { name: 'UserFragment', userId: '12345', role: 'admin' }\n     * ```\n     */\n    toJSON(): _SerializedType {\n        const result = {\n            name: this.name,\n        };\n\n        return result as _SerializedType;\n    }\n}","import {\n    A_Stage,\n    A_TYPES__A_StageStep,\n    A_TYPES_StageExecutionBehavior\n} from \"@adaas/a-concept/a-stage\"\nimport { A_Entity } from \"@adaas/a-concept/a-entity\"\nimport {\n    A_Container,\n    A_TYPES__Container_Constructor\n} from \"@adaas/a-concept/a-container\"\nimport {\n    A_Component,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\"\nimport { A_TYPES__Entity_Constructor } from \"@adaas/a-concept/a-entity\"\nimport { A_Feature } from \"./A-Feature.class\"\nimport {\n    A_TYPES__Ctor,\n    A_TYPES__Required\n} from \"@adaas/a-concept/types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\"\nimport { A_TYPES__Error_Init } from \"@adaas/a-concept/a-error\"\n\n\n// ============================================================================\n// --------------------------- Primary Types ----------------------------------\n// ============================================================================\n/**\n * Feature constructor type\n * Uses the generic type T to specify the type of the feature\n */\nexport type A_TYPES__Feature_Constructor<T = A_Feature> = A_TYPES__Ctor<T>;\n/**\n * Feature initialization type\n */\nexport type A_TYPES__Feature_Init<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = A_TYPES__Feature_InitWithComponent<T> | A_TYPES__Feature_InitWithTemplate<T>\n/**\n * Feature initialization type using component\n */\nexport type A_TYPES__Feature_InitWithComponent<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component: T,\n\n    /**\n     * In case when Entity is not attached to the scope can be used to transparently show dependencies\n     * \n     * \n     */\n    scope?: A_Scope\n}\n/**\n * Feature initialization type using template\n */\nexport type A_TYPES__Feature_InitWithTemplate<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The scope from where to retrieve dependent components, entities and containers. \n     * \n     * [!] Important for proper scoping. \n     */\n    scope: A_Scope\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component?: T,\n    /**\n     * Optional Feature template to be used instead of building it from decorators\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n\n/**\n * Feature serialized type\n */\nexport type A_TYPES__Feature_Serialized = {}\n\n\n/**\n * Feature lifecycle states\n */\nexport enum A_TYPES__FeatureState {\n    /**\n     * The feature has been initialized\n     */\n    INITIALIZED = \"INITIALIZED\",\n    /**\n     * The feature is currently being processed\n     */\n    PROCESSING = \"PROCESSING\",\n    /**\n     * The feature has been completed\n     */\n    COMPLETED = \"COMPLETED\",\n    /**\n     * The feature has been interrupted\n     */\n    INTERRUPTED = \"INTERRUPTED\",\n    /**\n     * The feature has failed\n     */\n    FAILED = \"FAILED\"\n}\n\n// ===========================================================================\n// --------------------------- Error Types ------------------------------------\n// ===========================================================================\n\nexport type A_TYPES__FeatureError_Init = {\n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n} & A_TYPES__Error_Init\n\n\n\n// ===========================================================================-\n// --------------------------- Available Types -------------------------------\n// ===========================================================================\n\n/**\n * A list of component where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableComponents = InstanceType<A_TYPES__FeatureAvailableConstructors>\n/**\n * A list of constructors where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableConstructors = A_TYPES__Component_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Container_Constructor\n\n\n\n// ===========================================================================\n// --------------------------- Decorator Types -------------------------------\n// ===========================================================================\n// ---------------------------------------------------------------------------\n// --------------------Feature Define Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Indicates a type of Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorDescriptor =\n    TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n/**\n * Describes additional configuration properties to be used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorConfig = {\n    /**\n     * Feature name\n     * \n     * [!] By default uses the method name\n     */\n    name: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n/**\n * Describes a single template item used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorTemplateItem = A_TYPES__Required<Partial<A_TYPES__A_StageStep>, ['name', 'handler', 'dependency']>\n/**\n * Describes a target where Feature Define decorator can be applied\n * \n * [!] The feature can be defined on Container, Entity, Component or Command\n */\nexport type A_TYPES__FeatureDefineDecoratorTarget = A_Container\n    | A_Entity\n    | A_Component\n/**\n * A type of Meta information stored by Feature Define decorator\n * This information then uses by A-Context to build a proper feature template\n */\nexport type A_TYPES__FeatureDefineDecoratorMeta = {\n    /**\n     * Feature name\n     * mainly it's a unique combination of the class name and method name\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__A_StageStep>\n}\n// ---------------------------------------------------------------------------\n// --------------------Feature Extend Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Descriptor type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorDescriptor =\n    TypedPropertyDescriptor<() => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<() => Promise<any>>\n/**\n * Target type for A_Extend decorator\n * \n * [!] Can be applied only on A-Components\n */\nexport type A_TYPES__FeatureExtendDecoratorTarget = A_Component | A_Container | A_Entity\n\n/**\n * Configuration type for A_Extend decorator\n * \n * This is an INPUT parameter provided by the user\n */\nexport type A_TYPES__FeatureExtendDecoratorConfig = {\n    /**\n     * Name of the container Lifecycle method to be extended.\n     * \n     * [!] If not provided will be used the name of the method.\n     * [!!] If name contains \".\" dot it will be considered as a path to the method.\n     */\n    name: string,\n    /**\n     * Container class or container name uses to identify the proper container in case when the name is not unique.\n     * \n     * [!] If not provided will be applied to all containers with the same name.\n     * [!!] By default uses OR to join all provided items. If you need more complex Logic, please use Regexp instead\n     * \n     * [!!!] In case if you need to exclude some containers, entities or components, please use \"exclude\" property\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      scope: {\n     *          include: [A_Container1, A_Entity1],\n     *          exclude: [A_Component1]\n     *      }\n     *  })\n     * ```\n     */\n    scope: Array<A_TYPES__FeatureExtendDecoratorScopeItem> | Partial<A_TYPES__FeatureExtendDecoratorScopeConfig>,\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: /Component2\\..+/\n     *  })\n     * ```\n     */\n    before: Array<string> | RegExp\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: /Component2\\..+/\n     *  })\n     * ```\n     * \n     */\n    after: Array<string> | RegExp\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: Array<string> | RegExp\n}\n/**\n * Scope item that can be used in A_Extend decorator configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeConfig = {\n    /**\n     * A list of components, entities or containers to include in the scope of the extension\n     */\n    include?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>,\n    /**\n     * A list of components, entities or containers to exclude from the scope of the extension\n     */\n    exclude?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>\n}\n/**\n * A single item that can be used in scope configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeItem = A_TYPES__Container_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Component_Constructor\n\n\n\n// =======================================================================\n// --------------------------META TYPES-----------------------------------\n// =======================================================================\n/**\n * Meta type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorMeta = {\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean,\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: string\n}\n\n\n","\n/**\n * A_FormatterHelper\n * \n * Helper class for formatting strings into different cases.\n */\nexport class A_FormatterHelper {\n    /**\n     * Convert string to UPPER_SNAKE_CASE\n     * \n     * @param str \n     * @returns \n     */\n    static toUpperSnakeCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1_$2')  // Handle camelCase\n            .replace(/[^a-zA-Z0-9]+/g, '_')       // Replace non-alphanumeric with underscores\n            .replace(/_+/g, '_')                  // Collapse multiple underscores\n            .replace(/^_|_$/g, '')                // Remove leading/trailing underscores\n            .toUpperCase();\n    }\n    /**\n     * Convert string to camelCase\n     * \n     * @param str \n     * @returns \n     */\n    static toCamelCase(str: string): string {\n        return str\n            .trim()\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map((part, index) => {\n                if (index === 0) {\n                    return part.toLowerCase();\n                }\n                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n            })\n            .join('');\n    }\n    /**\n     * Convert string to PascalCase\n     * \n     * @param str \n     * @returns \n     */\n    static toPascalCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1 $2')  // Insert space before uppercase in camelCase\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n    /**\n     * Convert string to kebab-case\n     * \n     * @param str \n     * @returns \n     */\n    static toKebabCase(str: string): string {\n        return str\n            // 1. Replace all non-alphanumeric (underscore, dot, etc.) with a space\n            .replace(/[^a-zA-Z0-9]+/g, ' ')\n            // 2. Insert space before any uppercase preceded by lowercase or digit\n            .replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n            // 3. Trim spaces at both ends and replace remaining spaces with dashes\n            .trim()\n            .replace(/\\s+/g, '-')\n            // 4. Lowercase everything\n            .toLowerCase();\n    }\n}","import { A_ID_TYPES__TimeId_Parts } from \"@adaas/a-concept/types\";\n\n\n\n\nexport class A_IdentityHelper {\n    /**\n   * Generates a short, time-based unique ID.\n   * Encodes current time (ms since epoch) and random bits in base36.\n   * Example: \"mb4f1g-7f9a1c\"\n   */\n    static generateTimeId(\n        parts: A_ID_TYPES__TimeId_Parts = { timestamp: new Date(), random: Math.random().toString(36).slice(2, 8) }\n    ): string {\n        const time = parts.timestamp.getTime().toString(36); // base36-encoded timestamp\n        const random = parts.random; // use provided random string\n        return `${time}-${random}`;\n    }\n\n    /**\n     * Parses a short ID back into its parts.\n     * Returns an object with the original timestamp (as Date) and random string.\n     */\n    static parseTimeId(id: string): A_ID_TYPES__TimeId_Parts {\n        const [timePart, randomPart] = id.split('-');\n        const timestamp = new Date(parseInt(timePart, 36));\n        return { timestamp, random: randomPart };\n    }\n\n\n    /**\n     *  Format a number with leading zeros to a fixed length\n     * \n     * @param number \n     * @param maxZeros \n     * @returns \n     */\n    static formatWithLeadingZeros(number, maxZeros = 10) {\n        const formattedNumber = String(number).padStart(maxZeros + 1, '0');\n        return formattedNumber.slice(-maxZeros);\n    }\n\n    /**\n     * Remove leading zeros from a formatted number\n     */\n    static removeLeadingZeros(formattedNumber) {\n        return String(Number(formattedNumber)); // Convert to number and back to string to remove leading zeros\n    }\n\n    /**\n     * Generates a simple hash string from the input string.\n     * \n     * \n     * @param input \n     * @returns\n     */\n    static hashString(input: string): string {\n        let hash = 0, i, chr;\n        if (input.length === 0) return hash.toString();\n        for (i = 0; i < input.length; i++) {\n            chr = input.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n\n}","/**\n * Basic TypeGuards that don't create circular dependencies\n * These are used by A_Error and other core classes\n */\nexport class A_BasicTypeGuards {\n\n    /**\n     * Check if value is a string\n     * \n     * @param value \n     * @returns \n     */\n    static isString(value: any): value is string {\n        return typeof value === 'string' || value instanceof String;\n    }\n\n    /**\n     * Check if value is a number\n     * \n     * @param value \n     * @returns \n     */\n    static isNumber(value: any): value is number {\n        return typeof value === 'number' && isFinite(value);\n    }\n\n    /**\n     * Check if value is a boolean\n     * \n     * @param value \n     * @returns \n     */\n    static isBoolean(value: any): value is boolean {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Check if value is an object\n     * \n     * @param value \n     * @returns \n     */\n    static isObject<T = object>(value: any): value is T {\n        return value !== null && typeof value === 'object' && !Array.isArray(value);\n    }\n\n    /**\n     * Check if value is an array\n     * \n     * @param value \n     * @returns \n     */\n    static isArray(value: any): value is any[] {\n        return Array.isArray(value);\n    }\n\n    /**\n     * Allows to check if the provided param is of constructor type.\n     * \n     * @param param \n     * @returns \n     */\n    static isErrorConstructorType<T = any>(param: any): param is T {\n        return !!param && A_BasicTypeGuards.isObject(param) && !(param instanceof Error) && \"title\" in param;\n    }\n\n    static isErrorSerializedType<T = any>(param: any): param is T {\n        return !!param && A_BasicTypeGuards.isObject(param) && !(param instanceof Error) && \"aseid\" in param && A_BasicTypeGuards.isString((param as any).aseid);\n    }\n\n    /**\n     * Check if scope is of type A_Scope instance\n     * \n     * @param scope \n     * @returns \n     */\n    static isScopeInstance(scope: any): boolean {\n        // Basic check without importing A_Scope to avoid circular dependency\n        return !!scope && typeof scope === 'object' && 'name' in scope && 'aseid' in scope;\n    }\n}","import {\n    A_TYPES__ASEID_Constructor,\n    A_TYPES__ASEID_JSON\n} from \"./ASEID.types\";\nimport { A_IdentityHelper} from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport { A_BasicTypeGuards} from \"@adaas/a-concept/helpers/A_BasicTypeGuards.helper\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\n// import { ASEID_Error } from \"./ASEID.error\";\nimport { A_TYPES__Required } from \"@adaas/a-concept/types\";\n\n\nexport class ASEID {\n\n\n    //==========================================================================\n    //============================= STATIC METHODS ===========================\n    //==========================================================================\n    /**\n     * ASEID Regular Expression\n     */\n    static readonly regexp: RegExp = new RegExp(`^[a-z|A-Z|0-9|-]+@[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\\\.|-]+(@v[0-9|\\\\.]+|@lts)?$`)\n    /**\n     * Tests if the identity string is an ASEID\n     * \n     * @param identity \n     * @returns \n     */\n    static isASEID(identity: string): boolean {\n        return this.regexp.test(identity)\n    }\n\n\n    static compare(aseid1: ASEID | string | undefined, aseid2: ASEID | string | undefined): boolean {\n\n        if (!aseid1 || !aseid2) {\n            return false;\n        }\n\n        if (A_BasicTypeGuards.isString(aseid1) && this.isASEID(aseid1) === false) {\n            throw new Error(`Invalid ASEID format provided: ${aseid1}`);\n        }\n\n        if (A_BasicTypeGuards.isString(aseid2) && this.isASEID(aseid2) === false) {\n            throw new Error(`Invalid ASEID format provided: ${aseid2}`);\n        }\n\n        const aseidObj1 = aseid1 instanceof ASEID ? aseid1 : new ASEID(aseid1);\n        const aseidObj2 = aseid2 instanceof ASEID ? aseid2 : new ASEID(aseid2);\n\n        return aseidObj1.toString() === aseidObj2.toString();\n    }\n\n\n    // ====================================================================\n    // ==================== Hidden ASEID Information ======================\n    // ====================================================================\n    /**\n     * Concept for the ASEID\n     * Generally it is the application name or code, should correspond to the concept where the entity is used\n     * Could be ID or ASEID\n     */\n    private _concept!: string;\n    /**\n     * Entity Scope the primary location of the resource \n     * Organization, or organization Unit\n     * Could be ID or ASEID\n     * \n     */\n    private _scope!: string\n    /**\n     * Entity Type the type of the resource\n     */\n    private _entity!: string\n    /**\n     * Entity ID the unique identifier of the resource\n     */\n    private _id!: string\n    /**\n     * Version of the entity (optional)\n     */\n    private _version?: string\n    /**\n     * Shard of the entity (optional)\n     */\n    private _shard?: string\n\n\n\n\n\n\n    /**\n     * ASEID is a structured identifier for entities in the A-Concept system. \n     * using the format:\n     *  A - A-Concept\n     *  S - System \n     *  E - Entity\n     *  I - Identifier\n     *  D - iDentifier\n     * \n     * Structure: CONCEPT_NAME + @ + SCOPE + : ENTITY_NAME + : + ID + @ + VERSION \n     * \n     * Example:\n     *  - root@core:usr:0000000001\n     * \n     * [!] Concept is optional, if not provided will be used the current concept name\n     * [!] Scope is optional, if not provided will be used the root scope of the current concept\n     * [!] Version is optional, if not provided will be considered as latest version\n     * \n     * @param aseid - ASEID string representation or ASEID components as object\n     */\n    constructor(\n        /**\n         * ASEID string representation\n         */\n        aseid: string\n    )\n    constructor(\n        /**\n         * ASEID components as object \n         */\n        props: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    )\n    constructor(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this.verifyInput(param1);\n\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1);\n    }\n\n    /**\n     * Getters for ASEID components\n     */\n    get concept(): string {\n        return this._concept || A_Context.concept;\n    }\n    /**\n     * Get the scope of the ASEID\n     */\n    get scope(): string {\n        return this._scope || A_Context.root.name;\n    }\n    /**\n     * Get the entity of the ASEID\n     */\n    get entity(): string {\n        return this._entity;\n    }\n    /**\n     * Get the id of the ASEID\n     */\n    get id(): string {\n        return this._id;\n    }\n    /**\n     * Get the version of the ASEID (if any)\n     */\n    get version(): string | undefined {\n        return this._version;\n    }\n    /**\n     * Get the shard of the ASEID (if any)\n     */\n    get shard(): string | undefined {\n        return this._shard;\n    }\n\n    /**\n     * Get the hash of the ASEID, Unique identifier based on the ASEID string\n     * Useful when aseid details should not be exposed directly\n     */\n    get hash(): string {\n        return A_IdentityHelper.hashString(this.toString());\n    }\n\n    /**\n     * get Internal Initializer based on the type of the parameter provided\n     * \n     * @param param1 \n     * @returns \n     */\n    private getInitializer(\n        param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    ): (param1: any) => void | (() => void) {\n        switch (true) {\n            case A_BasicTypeGuards.isString(param1):\n                return this.fromString;\n\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1):\n                return this.fromObject;\n\n            default:\n                throw new Error(\n                    'Invalid parameters provided to ASEID constructor'\n                );\n        }\n    }\n\n\n    /**\n     * Initialize ASEID from string\n     * \n     * @param param1 \n     */\n    private fromString(param1: string) {\n        const [concept, body, version] = param1.split('@');\n        const [scope, entity, idCandidate] = body.split(':');\n\n        const shard = idCandidate.includes('.') ? idCandidate.split('.')[0] : undefined;\n        const id = idCandidate.includes('.') ? idCandidate.split('.')[1] : idCandidate;\n\n        this._concept = concept || A_Context.root.name;\n        this._scope = scope || A_Context.root.name;\n        this._entity = entity;\n        this._id = id;\n        this._version = version;\n        this._shard = shard;\n    }\n    /**\n     * Initialize ASEID from object\n     * \n     * @param param1 \n     */\n    private fromObject(param1: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this._concept = param1.concept\n            ? ASEID.isASEID(param1.concept)\n                ? new ASEID(param1.concept).id\n                : param1.concept\n            : A_Context.concept;\n\n        this._scope = param1.scope\n            ? A_BasicTypeGuards.isNumber(param1.scope)\n                ? A_IdentityHelper.formatWithLeadingZeros(param1.scope) :\n                ASEID.isASEID(param1.scope)\n                    ? new ASEID(param1.scope).id\n                    : param1.scope\n            : A_Context.root.name\n\n        this._entity = param1.entity;\n\n        this._id = A_BasicTypeGuards.isNumber(param1.id)\n            ? A_IdentityHelper.formatWithLeadingZeros(param1.id)\n            : param1.id;\n\n        this._version = param1.version;\n        this._shard = param1.shard;\n    }\n\n\n    /**\n     * String representation of the ASEID\n     * \n     * @returns \n     */\n    toString(): string {\n        return `${this.concept}@${this.scope}:${this.entity}:${this.shard ? (this.shard + '.' + this.id) : this.id}${this.version ? ('@' + this.version) : ''}`\n    }\n\n    /**\n     * JSON representation of the ASEID\n     * \n     * @returns \n     */\n    toJSON(): A_TYPES__ASEID_JSON {\n        return {\n            concept: this._concept,\n            scope: this._scope,\n            entity: this._entity,\n            id: this._id,\n            version: this._version,\n            shard: this._shard\n        }\n    }\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n\n\n    protected verifyInput(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n\n        switch (true) {\n            // 1) check for string and validate it as ASEID\n            case A_BasicTypeGuards.isString(param1) && !ASEID.isASEID(param1):\n                throw new Error( 'Invalid ASEID format provided')\n\n            // 2) check for object and validate required fields\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.id:\n                throw new Error('ASEID id is required')\n            // 3) check for object and validate required fields\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.entity:\n                throw new Error('ASEID entity is required')\n\n        }\n    }\n}","\n\n\nexport const A_CONSTANTS__ERROR_CODES = {\n    UNEXPECTED_ERROR: 'A-Error Unexpected Error',\n    VALIDATION_ERROR: 'A-Error Validation Error',\n} as const;\n\n\n\nexport const A_CONSTANTS__ERROR_DESCRIPTION = 'If you see this error please let us know.'","import { A_TYPES__ContextEnvironment } from \"@adaas/a-concept/a-context\";\nimport { A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY } from \"../constants/env.constants\";\n\nexport class A_CONCEPT_BASE_ENV {\n  // ----------------------------------------------------------\n  // A-Concept Core Environment Variables\n  // ----------------------------------------------------------\n  // These environment variables are used by A-Concept core to configure the application\n  // ----------------------------------------------------------\n  /**\n   * Name of the application\n   * \n   * DEFAULT value is 'a-concept'\n   * \n   * [!] Provided name will be used for all aseids in the application by default\n   */\n  static get A_CONCEPT_NAME() {\n    return \"a-concept\";\n  }\n  /**\n   * Root scope of the application\n   * \n   * DEFAULT value is 'root'\n   * \n   * [!] Provided name will be used for all aseids in the application by default\n   */\n  static get A_CONCEPT_ROOT_SCOPE() {\n    return \"root\";\n  }\n  /**\n   * Environment of the application e.g. development, production, staging\n   */\n  static get A_CONCEPT_ENVIRONMENT() {\n    return \"development\";\n  }\n  /**\n   * Runtime environment of the application e.g. browser, node\n   */\n  static get A_CONCEPT_RUNTIME_ENVIRONMENT(): A_TYPES__ContextEnvironment {\n    return \"unknown\";\n  }\n\n  /**\n   * Root folder of the application\n   * [!] Automatically set by A-Concept when the application starts\n   */\n  static get A_CONCEPT_ROOT_FOLDER() {\n    return \"/app\";\n  }\n\n  /**\n   * Allows to define a default error description for errors thrown without a description\n   */\n  static get A_ERROR_DEFAULT_DESCRIPTION() {\n    return \"If you see this error please let us know.\";\n  }\n\n  /**\n   * Generic getter for environment variables. This allows to access environment variables dynamically by name. It will return undefined if the variable does not exist.\n   * \n   * @param name \n   * @returns \n   */\n  static get(name: string) {\n    return (this as any)[name];\n  }\n  /**\n   * Generic setter for environment variables. This allows to set environment variables dynamically by name.\n   * \n   * @param name \n   * @param value \n   */\n  static set(name: string, value: string) {\n    (this as any)[name] = value;\n  }\n\n  /**\n   * This method returns all the environment variables that are available in the application. It combines the variables from process.env and the default environment variables defined in A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY.\n   * \n   * @returns \n   */\n  static getAll<T extends Record<string, any>>(): T {\n    return {} as T;\n  }\n\n  /**\n   * This method returns all the keys of the environment variables that are available in the application. It combines the keys from process.env and the default environment variables defined in A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY.\n   * \n   * @returns \n   */\n  static getAllKeys<T extends Array<string>>(): T {\n    return [] as any as T;\n  }\n\n} \n","export const A_CONSTANTS__DEFAULT_ENV_VARIABLES = {\n    // ----------------------------------------------------------\n    // A-Concept Core Environment Variables\n    // ----------------------------------------------------------\n    // These environment variables are used by A-Concept core to configure the application\n    // ----------------------------------------------------------\n    /**\n     * Name of the application\n     * \n     * DEFAULT value is 'a-concept'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_NAME: 'A_CONCEPT_NAME',\n    /**\n     * Root scope of the application\n     * \n     * DEFAULT value is 'root'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_ROOT_SCOPE: 'A_CONCEPT_ROOT_SCOPE',\n    /**\n     * Environment of the application e.g. development, production, staging\n     */\n    A_CONCEPT_ENVIRONMENT: 'A_CONCEPT_ENVIRONMENT',\n    /**\n     * Runtime environment of the application e.g. browser, node\n     */\n    A_CONCEPT_RUNTIME_ENVIRONMENT: 'A_CONCEPT_RUNTIME_ENVIRONMENT',\n    /**\n     * Root folder of the application\n     * [!] Automatically set by A-Concept when the application starts\n     */\n    A_CONCEPT_ROOT_FOLDER: 'A_CONCEPT_ROOT_FOLDER',\n    /**\n     * Allows to define a default error description for errors thrown without a description\n     */\n    A_ERROR_DEFAULT_DESCRIPTION: 'A_ERROR_DEFAULT_DESCRIPTION',\n} as const\n\n\n//should be an array\nexport type A_TYPES__ConceptENVVariables = (typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES)[keyof typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES][];\n\n\nexport const A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY = [\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_NAME,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ENVIRONMENT,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_RUNTIME_ENVIRONMENT,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_FOLDER,\n\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_ERROR_DEFAULT_DESCRIPTION,\n] as const;\n\n","import { A_TYPES__ContextEnvironment } from \"@adaas/a-concept/a-context\";\nimport { A_CONCEPT_BASE_ENV } from \"./env.base\";\nimport { A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY } from \"../constants/env.constants\";\n\n\nexport class A_CONCEPT_ENV extends A_CONCEPT_BASE_ENV {\n    static get A_CONCEPT_ENVIRONMENT() {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.A_CONCEPT_ENVIRONMENT || super.A_CONCEPT_ENVIRONMENT;\n    }\n    static get A_CONCEPT_RUNTIME_ENVIRONMENT(): A_TYPES__ContextEnvironment {\n        return 'browser';\n    }\n    static get A_CONCEPT_NAME() {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.A_CONCEPT_NAME || super.A_CONCEPT_NAME;\n    }\n    static get A_CONCEPT_ROOT_FOLDER() {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.A_CONCEPT_ROOT_FOLDER || super.A_CONCEPT_ROOT_FOLDER;\n    }\n    static get A_CONCEPT_ROOT_SCOPE() {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.A_CONCEPT_ROOT_SCOPE || super.A_CONCEPT_ROOT_SCOPE;\n    }\n    static get A_ERROR_DEFAULT_DESCRIPTION() {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.A_ERROR_DEFAULT_DESCRIPTION || super.A_ERROR_DEFAULT_DESCRIPTION;\n    }\n    static get(name: string) {\n        return window.__A_CONCEPT_ENVIRONMENT_ENV__?.[name] || (this as typeof A_CONCEPT_ENV)[name as keyof typeof A_CONCEPT_ENV];\n    }\n    static set(name: string, value: string) {\n        if (!window.__A_CONCEPT_ENVIRONMENT_ENV__) {\n            window.__A_CONCEPT_ENVIRONMENT_ENV__ = {};\n        }\n        window.__A_CONCEPT_ENVIRONMENT_ENV__[name] = value;\n    }\n\n    static getAll<T extends Record<string, string>>(): T {\n        const allEnv: Record<string, string> = {};\n\n        // Get all environment variables from the window object\n        if (window.__A_CONCEPT_ENVIRONMENT_ENV__) {\n            Object.keys(window.__A_CONCEPT_ENVIRONMENT_ENV__).forEach(key => {\n                allEnv[key] = window.__A_CONCEPT_ENVIRONMENT_ENV__![key];\n            });\n        }\n\n        // Get all default environment variables from the class\n        A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY.forEach(variable => {\n            allEnv[variable] = this.get(variable) as string;\n        });\n\n        return allEnv as T;\n    }\n\n    static getAllKeys<T extends Array<string>>(): T {\n        const keys = new Set<string>();\n\n        // Get all keys from the window object\n        if (window.__A_CONCEPT_ENVIRONMENT_ENV__) {\n            Object.keys(window.__A_CONCEPT_ENVIRONMENT_ENV__).forEach(key => {\n                keys.add(key);\n            });\n        }\n\n        // Get all default environment variable keys from the class\n        A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY.forEach(variable => {\n            keys.add(variable);\n        });\n\n        return Array.from(keys) as T;\n    }\n};\n","import { A_Context } from '@adaas/a-concept/a-context';\nimport {\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from './A_Error.types';\nimport {\n    A_CONSTANTS__ERROR_CODES,\n    A_CONSTANTS__ERROR_DESCRIPTION\n} from './A_Error.constants';\nimport { A_FormatterHelper } from '@adaas/a-concept/helpers/A_Formatter.helper';\nimport { A_BasicTypeGuards } from '@adaas/a-concept/helpers/A_BasicTypeGuards.helper';\nimport { ASEID } from '@adaas/a-concept/aseid';\nimport { A_CONCEPT_ENV } from '@adaas/a-concept/env';\n\n\nexport class A_Error<\n    _ConstructorType extends A_TYPES__Error_Init = A_TYPES__Error_Init,\n    _SerializedType extends A_TYPES__Error_Serialized = A_TYPES__Error_Serialized\n> extends Error {\n    // ====================================================================\n    // ================== Static A-Error Information ======================\n    // ====================================================================\n    /**\n     * Error Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Namespace of the error from environment variable A_CONCEPT_NAMESPACE\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n    // ====================================================================\n    // ================== Hidden A-Error Information ======================\n    // ====================================================================\n    /**\n     * ASEID of the error instance\n     */\n    protected _aseid!: ASEID;\n    /**\n     * Title of the error\n     */\n    protected _title!: string;\n    /**\n     * Possible Scope if needed to identify the error by it's execution environment\n     */\n    protected _scope?: string;\n    /**\n     * Unique code representing the type of error\n     */\n    protected _code?: string;\n    /**\n     * Detailed description of the error\n     */\n    protected _description?: string;\n    /**\n     * Original Error if any\n     */\n    protected _originalError?: Error | any\n    /**\n     * Link to the documentation or support page for the error\n     */\n    protected _link?: string;\n\n\n\n    /**\n     * A_Error is a custom error class for A_Concept framework.\n     * This error allows to have more structured error handling.\n     * Each error has a unique code, description and a link to the documentation.\n     * \n     * Example of usage: \n     * ```typescript\n     * \n     * // 1) all parameters will be used as provided\n     * throw new A_Error({\n     *    message: 'User not found',\n     *    code: 'USER_NOT_FOUND',\n     *    description: 'The user with the given ID was not found.',\n     *    link: 'https://support.adaas.org/error/USER_NOT_FOUND'\n     * });\n     * \n     * // or\n     * // 2) only message is provided, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'User not found' (same as message)\n     * //     - link: Empty\n     * throw new A_Error('User not found');\n     * \n     * // or\n     * // 3) Provided Message and Description, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'The user with the given ID was not found.' (as provided)\n     * //     - link: Empty\n     * throw new A_Error('User not found', 'The user with the given ID was not found.');\n     * \n     * \n     * ```\n     * [!] Note: The behavior of A_Error is similar to the A_Entity however it cannot have own A_Features.\n     * [!] Note: This class can be inherited to create custom error classes.\n     * \n     * @param message \n     */\n    constructor(\n        /**\n         * A_Error Constructor params\n         */\n        params: _ConstructorType\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        message: string\n    )\n    constructor(\n        /**\n         * Original JS Error\n         */\n        error: Error\n    )\n    constructor(\n        /**\n         * Original JS Error\n         */\n        error: unknown\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        title: string,\n        /**\n         * Detailed description of the error\n         */\n        description: string\n    )\n    constructor(\n        param1: _ConstructorType | Error | string | A_Error | any,\n        param2?: string\n    ) {\n        //  to prevent errors accumulation in the stack trace it returns the original error if provided param1 is A_Error\n        switch (true) {\n            case param1 instanceof A_Error:\n                return param1 as A_Error<_ConstructorType, _SerializedType>;\n\n            case param1 instanceof Error:\n                super(param1.message);\n                break;\n\n            case A_BasicTypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                super(param1.message);\n                break;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1) && 'description' in param1:\n                super(`[${param1.title}]: ${param1.description}`);\n                break;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1) && !('description' in param1):\n                super(param1.title);\n                break;\n\n            case A_BasicTypeGuards.isString(param1) && !param2:\n                super(param1);\n                break;\n\n            case A_BasicTypeGuards.isString(param1) && !!param2:\n                super(`[${param1}]: ${param2}`);\n                break;\n\n            default:\n                super('An unknown error occurred.');\n        }\n\n        const initializer = this.getInitializer(param1, param2);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n\n\n    // ====================================================================\n    // ================== Public A-Error Information ======================\n    // ====================================================================\n    /**\n     * Returns the ASEID of the error instance\n     */\n    get aseid(): ASEID {\n        return this._aseid;\n    }\n    /**\n     * Returns the title of the error\n     * \n     * Example: 'User not found', 'Validation error', 'Unauthorized access', etc.\n     * \n     * [!] Note: This title should be short and concise, less than 60 characters\n     * [!] Note: If title exceeds 60 characters, there would be an error thrown\n     * [!] Note: This title is intended to be human-readable and can be displayed in UI or logs\n     */\n    get title(): string {\n        return this._title;\n    }\n    /**\n     * Returns an Error message what is a brief title of the error\n     * \n     */\n    get message(): string {\n        return super.message;\n    }\n    /**\n     * Returns a unique code representing the type of error\n     * \n     * If code is not provided, it will generate a kebab-case of the message\n     * \n     * Example: 'validation-error', 'not-found', 'user-not-found', 'unauthorized' etc.\n     * \n     * [!] Note: It is recommended to use kebab-case for error codes\n     * [!] Note: If not provided would be used a kebab-case message of the error\n     */\n    get code(): string {\n        return this._code || A_FormatterHelper.toKebabCase(this.title);\n    }\n    /**\n     * Returns the type of the error which corresponds to the static entity of the class\n     * \n     * Example: 'a-error', 'validation-error', 'not-found-error', 'user-error', etc.\n     * \n     * Defaults to the kebab-case of the class name\n     * \n     * [!] Note: naming ad separation are fully dependent on the architecture of the application\n     * [!] Note: It is recommended to use kebab-case for error types\n     * [!] Note: This type is intended to group similar errors together\n     */\n    get type() {\n        return (this.constructor as typeof A_Error).entity;\n    }\n    /**\n     * Returns a link with possible documentation or support page for the error\n     * If link is not provided, it will generate a link based on the ASEID of the error that points to the A-Concept support page\n     * \n     * Example: https://adaas.support/a-concept/errors/{ASEID}\n     * \n     * [!] Note: ASEID is generated based on the static properties of the class (concept, scope, entity) and the code of the error\n     */\n    get link() {\n        if (this._link)\n            return this._link;\n\n        const url = new URL(`https://adaas.support/a-concept/errors/${this.aseid.toString()}`);\n\n        return url.toString();\n    }\n    /**\n     * The scope name of the error instance\n     * \n     * If scope is not provided, it will use the static scope of the class\n     * \n     * [!] Note: Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    get scope() {\n        return this._aseid.scope\n    }\n    /**\n     * A detailed description of the error\n     * If description is not provided, it will use the environment variable A_ERROR_DEFAULT_DESCRIPTION or a generic message\n     * \n     * Example: 'The user with the given ID was not found.', 'The provided data is invalid.', 'You do not have permission to access this resource.', etc.\n     * \n     * [!] Note: This description is intended to provide more context about the error and can be used for debugging or logging purposes\n     */\n    get description(): string {\n        return this._description || String(A_CONCEPT_ENV.A_ERROR_DEFAULT_DESCRIPTION) || A_CONSTANTS__ERROR_DESCRIPTION;\n    }\n    /**\n     * Returns the original error if any\n     * \n     * This can be useful for debugging purposes to see the original stack trace or error message\n     * \n     * [!] Note: Original error is optional and may not be present in all cases\n     */\n    get originalError(): Error | any | undefined {\n        return this._originalError;\n    }\n\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1: _ConstructorType | Error | string | any,\n        param2?: string\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n\n            case A_BasicTypeGuards.isString(param1) && !param2:\n                return this.fromMessage;\n\n            case A_BasicTypeGuards.isString(param1) && !!param2:\n                return this.fromTitle;\n\n            case param1 instanceof Error:\n                return this.fromError;\n\n            case A_BasicTypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                return this.fromJSON;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1):\n                return this.fromConstructor;\n\n            default: {\n                throw new A_Error(\n                    A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                    'Invalid parameters provided to A_Error constructor'\n                );\n            }\n        }\n    }\n\n    /**\n     * Initializes the A_Error instance from a standard Error object.\n     * \n     * @param error \n     */\n    protected fromError(error: Error): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._originalError = error;\n    }\n    /**\n     * Initializes the A_Error instance from a message.\n     * \n     * @param title \n     * @param description \n     */\n    protected fromMessage(message: string): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a serialized object.\n     * \n     * @param serialized\n     */\n    protected fromJSON(serialized: _SerializedType): void {\n        this._aseid = new ASEID(serialized.aseid);\n        super.message = serialized.message;\n        this._title = serialized.title;\n        this._code = serialized.code;\n        this._scope = serialized.scope;\n        this._description = serialized.description;\n        // Note: originalError is deserialized as message only\n        this._originalError = serialized.originalError ? new A_Error(serialized.originalError) : undefined;\n        this._link = serialized.link;\n    }\n\n\n\n    fromTitle(title: string, description: string): void {\n        this.validateTitle(title);\n\n        this._title = title;\n        this._description = description;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a constructor parameters object.\n     * \n     * @param params \n     */\n    protected fromConstructor(params: _ConstructorType): void {\n        this.validateTitle(params.title);\n\n        this._title = params.title;\n        this._code = params.code;\n        this._scope = params.scope ? (A_BasicTypeGuards.isScopeInstance(params.scope) ? (params.scope as any).name : params.scope) : undefined;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._description = params.description;\n        this._link = params.link;\n\n        // Handle originalError: if it's an A_Error, we should trace back to the root cause\n        // to avoid infinite nesting of A_Error instances\n        if (params.originalError instanceof A_Error) {\n            // Find the root original error by traversing the chain\n            let rootError = params.originalError;\n            while (rootError.originalError instanceof A_Error) {\n                rootError = rootError.originalError;\n            }\n            // Set the root cause as the original error\n            this._originalError = rootError.originalError || rootError;\n        } else {\n            this._originalError = params.originalError;\n        }\n    }\n\n    /**\n     * Serializes the A_Error instance to a plain object.\n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString(),\n            title: this.title,\n            code: this.code,\n            type: this.type,\n            message: this.message,\n            link: this.link,\n            scope: this.scope,\n            description: this.description,\n            originalError: this.originalError?.message\n        } as _SerializedType;\n    }\n\n\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n    /**\n     * Checks if the provided title exceeds 60 characters.\n     * If it does, throws a validation A_Error.\n     * \n     * @param title \n     */\n    protected validateTitle(title: string) {\n        if (title.length > 60) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title exceeds 60 characters limit.'\n            );\n        }\n        if (title.length === 0) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title cannot be empty.'\n            );\n        }\n    }\n}\n\n\n\n\n\n// message = title + description for better printing in the console\n// description = detailed information about the error\n// code = kebabcase (title)\n\n","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_EntityError extends A_Error {\n\n    /**\n     * Error code for validation errors.\n     */\n    static readonly ValidationError = 'A-Entity Validation Error';\n\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_TYPES__Entity_Serialized,\n    A_TYPES__Entity_Init,\n    A_TYPES__IEntity,\n} from \"./A-Entity.types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_FormatterHelper} from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_IdentityHelper} from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport {\n    ASEID,\n    A_TYPES__ASEID_Constructor\n} from \"@adaas/a-concept/aseid\";\nimport { A_EntityError } from \"./A-Entity.error\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\n\n\n/**\n * A_Entity is another abstraction that describes all major participants in the system business logic.\n * Each Entity should have a clear definition and a clear set of responsibilities. \n * However, entity may hide some of its responsibilities behind the interface to prevent overload. \n * \n * Each entity should be connected to the ContextFragment (Scope) and should be able to communicate with other entities.\n */\nexport class A_Entity<\n    _ConstructorType extends A_TYPES__Entity_Init = A_TYPES__Entity_Init,\n    _SerializedType extends A_TYPES__Entity_Serialized = A_TYPES__Entity_Serialized\n>\n    implements A_TYPES__IEntity {\n\n    // ====================================================================\n    // ================== Static A-Entity Information ============================\n    // ====================================================================\n    /**\n     * Entity Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Concept Name (Application Name) of the entity from environment variable A_CONCEPT_NAME\n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n\n\n    // ====================================================================\n    // ================== Instance A-Entity Information ====================\n    // ====================================================================\n\n    /**\n     * ASEID is an entity identifier that is unique across the system\n     * A - A_Concept or Application\n     * S - System or Scope\n     * E - Entity\n     * ID - Identifier\n     * \n     * [!] ASEID is immutable and should not be changed after the entity is created\n     * \n     * [!] ASEID is composed of the following parts:\n     * - concept: an application specific identifier from where the entity is coming from\n     * - scope: the scope of the entity from concept\n     * - entity: the name of the entity from concept\n     * - id: the unique identifier of the entity\n     *\n     * [!] For more information about ASEID, please refer to the ASEID class documentation]\n     */\n    aseid!: ASEID;\n\n\n\n    /**\n     * Create a new A_entity instance from Aseid String\n     * e.g. project@scope:entity:0000000001\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID string that represents the entity\n         */\n        aseid?: string\n    )\n    /**\n     * Create a new A_entity instance from Aseid instance\n     * e.g. new ASEID({concept: 'project', scope: 'default', entity: 'entity', id: '0000000001'})\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID instance that represents the entity\n         */\n        aseid: ASEID\n    )\n    /**\n     * Create a new A_entity instance from serialized object\n     * \n     * @param serialized \n     */\n    constructor(\n        /**\n         * Serialized object that represents the entity\n         */\n        serialized: _SerializedType\n    )\n    /**\n     * Create a new A_entity instance from constructor object\n     * \n     * @param newEntity \n     */\n    constructor(\n        /**\n         * Constructor object that represents the entity\n         */\n        newEntity?: _ConstructorType\n    )\n    constructor(props?: string | ASEID | _SerializedType | _ConstructorType) {\n\n        const initializer = this.getInitializer(props);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, props);\n    }\n    // ====================================================================\n    // ================== DUPLICATED ASEID Getters ========================\n    // ====================================================================\n\n    /**\n     * Extracts the ID from the ASEID\n     * ID is the unique identifier of the entity\n     */\n    get id(): string | number {\n        return this.aseid.id;\n    }\n\n    // ====================================================================\n    // ================== Constructor Helpers =============================\n    // ====================================================================\n\n\n    // --- Type guards used to classify `props` properly ---\n    protected isStringASEID(x: unknown): x is string {\n        return typeof x === \"string\" && ASEID.isASEID(x);\n    }\n\n    protected isASEIDInstance(x: unknown): x is ASEID {\n        return x instanceof ASEID;\n    }\n\n    /**\n     * A \"serialized\" object is considered such if it is a non-null object \n     * and contains an \"aseid\" property (this mirrors your original check). \n     * \n     * @param x \n     * @returns \n     */\n    protected isSerializedObject(x: unknown): x is _SerializedType {\n        return !!x && typeof x === \"object\" && \"aseid\" in (x as object);\n    }\n\n    /**\n     * Constructor-style props = a plain object which does NOT contain \"aseid\".\n     * This is the \"create from provided fields\" case.\n     * \n     * @param x \n     * @returns \n     */\n    protected isConstructorProps(x: unknown): x is _ConstructorType {\n        return !!x && typeof x === \"object\" && !(\"aseid\" in (x as object));\n    }\n\n    /**\n     * Determines the appropriate initializer method based on the type of `props`.\n     * The method checks if `props` is:  \n     * 1) a string that matches ASEID format -> fromASEID\n     * 2) an ASEID instance -> fromASEID\n     * 3) a serialized object (has 'aseid') -> fromJSON\n     * 4) a plain object with no 'aseid' -> treat as constructor props -> fromNew\n     * \n     * [!] If `props` is undefined, it will call fromUndefined method\n     * \n     * If none of the above, it throws an error indicating incorrect constructor usage.\n     * \n     * \n     * To get a custom initializer, override this method in the child class.\n     * Example:\n     * ```typescript\n     * protected getInitializer(\n     *   props?: string | ASEID | _SerializedType | _ConstructorType\n     * ): (props: any) => void | (() => void) {\n     *   if('customField' in props) {\n     *       return this.fromCustomField.bind(this);\n     *   }\n     *   return super.getInitializer(props);\n     * }\n     * ```\n     * @param props\n     * @returns The appropriate initializer method\n     */\n    protected getInitializer(\n        props?: string | ASEID | _SerializedType | _ConstructorType\n    ): (props: any) => void | (() => void) {\n\n        if (!props) {\n            return this.fromUndefined\n        }\n\n        // 1) string that matches ASEID format -> fromASEID\n        if (this.isStringASEID(props)) {\n            return this.fromASEID as (p: string) => void;\n        }\n\n        // 2) ASEID instance -> fromASEID\n        if (this.isASEIDInstance(props)) {\n            return this.fromASEID as (p: ASEID) => void;\n        }\n\n        // 3) serialized object (has 'aseid') -> fromJSON\n        if (this.isSerializedObject(props)) {\n            return this.fromJSON as (p: _SerializedType) => void;\n        }\n\n        // 4) plain object with no 'aseid' -> treat as constructor props -> fromNew\n        if (this.isConstructorProps(props)) {\n            return this.fromNew as (p: _ConstructorType) => void;\n        }\n\n        // none of the above -> throw consistent error\n        throw new A_EntityError(A_EntityError.ValidationError, 'Unable to determine A-Entity constructor initialization method. Please check the provided parameters.');\n    }\n\n    /**\n     * Generates a new ASEID for the entity. \n     * It uses class definitions for concept, scope, and entity,\n     * and allows overriding any of these values.\n     * \n     * @param override \n     * @returns \n     */\n    protected generateASEID(override?: Partial<A_TYPES__ASEID_Constructor>): ASEID {\n        return new ASEID({\n            concept: override?.concept || (this.constructor as typeof A_Entity).concept,\n            scope: override?.scope || (this.constructor as typeof A_Entity).scope,\n            entity: override?.entity || (this.constructor as typeof A_Entity).entity,\n            id: override?.id || A_IdentityHelper.generateTimeId()\n        });\n    }\n\n\n    /**\n     * Call a feature of the component with the provided scope\n     * \n     * [!] If the provided scope is not inherited from the entity scope, it will be inherited\n     * \n     * @param lifecycleMethod \n     * @param args \n     */\n    async call(\n        feature: string,\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this,\n            scope\n        });\n\n        return await newFeature.process(scope);\n    }\n\n\n    // ====================================================================\n    // ================== Entity Base Methods =============================\n    // ====================================================================\n\n    /**\n     * The default method that can be called and extended to load entity data.\n     */\n    async load(\n        scope?: A_Scope,\n    ) {\n        return this.call('load', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to destroy entity data.\n     */\n    async destroy(scope?: A_Scope) {\n        return this.call('destroy', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to save entity data.\n     */\n    async save(scope?: A_Scope) {\n        return this.call('save', scope);\n    }\n\n\n\n    // ====================================================================\n    // ================== Entity Serialization ============================\n    // ====================================================================\n\n    /**\n     * Create a new entity from ASEID string or instance\n     * [!] Executed when the constructor is called with a string or ASEID instance that represents the ASEID\n     * [!] Executes By Default with new A_Entity('aseid-string') or new A_Entity(new ASEID(...)) if getInitializer has not been overridden\n     * \n     * @param aseid \n     */\n    fromASEID(aseid: string | ASEID): void {\n        if (aseid instanceof ASEID)\n            this.aseid = aseid;\n        else\n            this.aseid = new ASEID(aseid);\n    }\n\n    /**\n     * Handles the case when no props are provided to the constructor.\n     * This method can be overridden in child classes to set default values or perform specific initialization logic.\n     * By default, it does nothing.\n     * \n     * \n     * @returns \n     */\n    fromUndefined(): void {\n        this.aseid = this.generateASEID();\n\n        return;\n    }\n\n    /**\n     * Create a new entity from constructor object\n     * [!] Executed when the constructor is called with an object that does not contain \"aseid\" property\n     * [!] Executes By Default with new A_Entity({}) if getInitializer has not been overridden\n     * \n     * @param newEntity \n     * @returns \n     */\n    fromNew(newEntity: _ConstructorType): void {\n        this.aseid = this.generateASEID();\n\n        return;\n    }\n\n\n    /**\n     * Creates a new entity from serialized object\n     * \n     * [!] Executed when the constructor is called with an object that contains \"aseid\" property\n     * [!] Executes By Default with new A_Entity({ aseid: '...' }) if getInitializer has not been overridden\n     * \n     * \n     * @param serialized \n     * @returns \n     */\n    fromJSON(serialized: _SerializedType): void {\n        this.aseid = new ASEID(serialized.aseid);\n        return;\n    }\n\n\n\n    /**\n     * Converts the entity to a JSON object \n     * [!] This method should be extended in the child classes to include all properties of the entity\n     * [!] Includes aseid by default \n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString()\n        } as _SerializedType;\n    }\n\n\n    /**\n     * Returns the string representation of the entity\n     * what is basically the ASEID string\n     * \n     * @returns \n     */\n    toString(): string {\n        return this.aseid ? this.aseid.toString() : this.constructor.name;\n    }\n}","import { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"./A-Meta.class\";\nimport { A_TYPES__MetaLinkedComponentConstructors } from \"./A-Meta.types\";\n\n\n\n\n/**\n * \n * This decorator should allow to set a default meta type for the class, this helps to avoid\n * the need to create custom meta classes for each class.\n * \n * @returns \n */\nexport function A_MetaDecorator<T extends A_Meta>(\n    constructor: A_TYPES__Ctor<T>\n) {\n    return function <TTarget extends A_TYPES__MetaLinkedComponentConstructors>(\n        target: TTarget\n    ): TTarget {\n        // Store meta info on the target class itself for the Meta decorator to pick up\n        A_Context.setMeta(target, new constructor());\n\n        return target;\n    };\n}","import { A_MetaDecorator } from \"./A-Meta.decorator\";\nimport { A_TYPES__Meta_Constructor } from \"./A-Meta.types\";\n\n/**\n * A Meta is an entity that stores all the metadata for the specific entity like container, component, feature, etc. \n * \n * [!] Meta can be different depending on the type of input data\n */\nexport class A_Meta<\n    _StorageItems extends Record<any, any> = any,\n    _SerializedType extends Record<string, any> = Record<string, any>\n> implements Iterable<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n\n    /**\n     * Allows to set a custom meta class for the Component or Container or Entity, or anything else. \n     * \n     * @param target \n     * @returns \n     */\n    static Define<T extends A_Meta>(target: A_TYPES__Meta_Constructor<T>) {\n        return A_MetaDecorator(target);\n    }\n\n\n\n    protected meta: Map<keyof _StorageItems, _StorageItems[keyof _StorageItems]> = new Map();\n\n\n    /**\n     * Method to get the iterator for the meta object\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const iterator = this.meta.entries();\n        return {\n            next: () => iterator.next()\n        };\n    }\n\n\n\n    // ===================================================================================================\n    // ================================ META OPERATIONS ==================================================\n    // ===================================================================================================\n    /**\n     * Allows to replicate received meta object by replacing internal meta to the received one\n     * \n     * @param meta \n     * @returns \n     */\n    from(\n        meta: A_Meta<_StorageItems>\n    ): A_Meta<_StorageItems> {\n        this.meta = new Map(meta.meta);\n\n        return this;\n    }\n\n\n    /**\n     * Method to set values in the map\n     * \n     * @param key \n     * @param value \n     */\n    set<K extends keyof _StorageItems>(key: K, value: _StorageItems[K]) {\n\n        const inheritedValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? []\n            : (value as any) instanceof Map\n                ? new Map()\n                : {};\n        const targetValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? [\n                ...inheritedValue as any\n            ] : (value as any) instanceof Map\n                ? new Map(inheritedValue as any)\n                : { ...inheritedValue };\n\n        this.meta.set(key, value);\n\n    }\n\n\n\n    /**\n     * Method to get values from the map\n     * \n     * @param key \n     * @returns \n     */\n    get<K extends keyof _StorageItems>(key: K): _StorageItems[K] | undefined {\n        return this.meta.get(key) as _StorageItems[K];\n    }\n\n\n    /**\n     * Method to delete values from the map\n     * \n     * @param key \n     * @returns \n     */\n    delete(key: keyof _StorageItems): boolean {\n        return this.meta.delete(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    size(): number {\n        return this.meta.size;\n    }\n\n\n    /**\n     * This method is needed to convert the key to a regular expression and cover cases like: \n     * \n     * simple * e.g. \"a*\" instead of \"a.*\"\n     * \n     * simple ? e.g. \"a?\" instead of \"a.\"\n     * \n     * etc. \n     * \n     * @param key \n     * @returns \n     */\n    private convertToRegExp(key: string | RegExp): RegExp {\n        return key instanceof RegExp\n            ? key\n            : new RegExp(key);\n    }\n\n\n    /**\n     * Method to find values in the map by name.\n     * \n     * Converts the Key in Map to a regular expression and then compares to the name\n     * \n     * @param name \n     * @returns \n     */\n    find(name: string) {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (this.convertToRegExp(String(key)).test(name)) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to find values in the map by regular expression\n     * \n     * Compares Map Key to the input regular expression\n     * \n     * @param regex \n     * @returns \n     */\n    findByRegex(regex: RegExp): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (regex.test(String(key))) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to check if the map has a specific key\n     * \n     * @param key \n     * @returns \n     */\n    has(key: keyof _StorageItems): boolean {\n        return this.meta.has(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    entries(): IterableIterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return this.meta.entries();\n    }\n\n\n    /**\n     * Method to clear the map\n     */\n    clear(): void {\n        this.meta.clear();\n    }\n\n\n    toArray(): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return Array.from(this.meta.entries());\n    }\n\n\n    protected recursiveToJSON(value: any): any {\n        switch (true) {\n            case value instanceof A_Meta:\n                return value.toJSON();\n\n            case value instanceof Map:\n                const obj: Record<string, any> = {};\n                for (const [k, v] of value.entries()) {\n                    obj[String(k)] = this.recursiveToJSON(v);\n                }\n                return obj;\n\n            case Array.isArray(value):\n                return value.map((item) => this.recursiveToJSON(item));\n\n            case !!value && typeof value === 'object':\n                const res: Record<string, any> = {};\n                for (const [k, v] of Object.entries(value)) {\n                    res[k] = this.recursiveToJSON(v);\n                }\n                return res;\n\n            default:\n                return value;\n        }\n    }\n\n    /**\n     * Serializes the meta to a JSON object\n     * Uses internal storage to convert to JSON\n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        const json: Record<string, any> = {};\n\n        for (const [key, value] of this.meta.entries()) {\n            json[String(key)] = this.recursiveToJSON(value);\n        }\n        return json as _SerializedType;\n    }\n}","export enum A_TYPES__EntityMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    ABSTRACTIONS = 'a-component-abstractions',\n    INJECTIONS = 'a-component-injections',\n}\n\nexport enum A_TYPES__EntityFeatures {\n    SAVE = 'save',\n    DESTROY = 'destroy',\n    LOAD = 'load'\n}","import { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__EntityMeta } from \"./A-Entity.types\";\nimport { A_TYPES__EntityMetaKey } from \"./A-Entity.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\n\n\nexport class A_EntityMeta extends A_Meta<A_TYPES__EntityMeta> {\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__EntityMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__EntityMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_TYPES__Container_Init } from \"./A-Container.types\";\n\n\n\nexport class A_Container {\n\n    /**\n     * Configuration of the container that will be used to run it.\n     */\n    protected readonly config!: Partial<A_TYPES__Container_Init>;\n    /**\n     * Name of the container\n     */\n    get name() {\n        return this.config?.name || this.constructor.name;\n    }\n    /**\n     * Returns the scope where the container is registered\n     */\n    get scope(): A_Scope {\n        return A_Context.scope(this);\n    }\n\n\n    /**\n     * This class should combine Components to achieve the goal withing Concept\n     * \n     * Container is a direct container that should be \"run\" to make Concept work. \n     * So because of that Container can be:\n     * - HTTP Server\n     * - BASH Script\n     * - Database Connection\n     * - Microservice\n     * - etc.\n     * \n     * @param config - Configuration of the container that will be used to run it.\n     */\n    constructor(\n        /**\n         * Configuration of the container that will be used to run it.\n         */\n        config: Partial<A_TYPES__Container_Init> = {}\n    ) {\n        this.config = config;\n\n        A_Context.allocate(this, this.config);\n    }\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    async call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return await newFeature.process(scope);\n    }\n}","export enum A_TYPES__ContainerMetaKey {\n    FEATURES = 'a-container-features',\n    INJECTIONS = 'a-container-injections',\n    ABSTRACTIONS = 'a-container-abstractions',\n    EXTENSIONS  = 'a-container-extensions',\n}","import {\n    A_TYPES__ContainerMeta,\n    A_TYPES__ContainerMetaExtension,\n} from \"./A-Container.types\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\nimport {\n    A_TYPES__ConceptAbstractionMeta,\n    A_TYPES__ConceptAbstractions\n} from \"@adaas/a-concept/a-concept\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ContainerMetaKey } from \"./A-Container.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\n\n\n\nexport class A_ContainerMeta extends A_Meta<A_TYPES__ContainerMeta> {\n\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ContainerMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Container during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: A_TYPES__ConceptAbstractions\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ContainerMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ContainerMetaExtension[] {\n        const steps: A_TYPES__ContainerMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ContainerMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override: ''\n\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\nimport { A_Stage } from \"@adaas/a-concept/a-stage\";\nimport { A_TYPES__FeatureError_Init } from \"./A-Feature.types\";\n\n\n\nexport class A_FeatureError extends A_Error<A_TYPES__FeatureError_Init> {\n\n    /**\n     * Indicates that the Feature has been interrupted\n     */\n    static readonly Interruption = 'Feature Interrupted';\n    /**\n     * Indicates that there was an error initializing the Feature\n     * \n     * Failed during the A-Feature initialization process\n     */\n    static readonly FeatureInitializationError = 'Unable to initialize A-Feature';\n    /**\n     * Indicates that there was an error processing the Feature\n     * \n     * Failed during the A-Feature processing\n     */\n    static readonly FeatureProcessingError = 'Error occurred during A-Feature processing';\n\n    // =======================================================================\n    // ---------------------- Decorator Errors -----------------------------\n    // =======================================================================\n    /**\n     * Indicates that there was an error defining the Feature\n     * \n     * Failed during the @A_Feature.Define() decorator execution\n     */\n    static readonly FeatureDefinitionError = 'Unable to define A-Feature';\n    /**\n     * Indicates that there was an error extending the Feature\n     * \n     * Failed during the @A_Feature.Extend() decorator execution\n     */\n    static readonly FeatureExtensionError = 'Unable to extend A-Feature';\n\n    \n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n\n    protected fromConstructor(params: A_TYPES__FeatureError_Init): void {\n        super.fromConstructor(params);\n\n        this.stage = params.stage;\n    }\n}","import { A_TYPES__DeepPartial } from \"@adaas/a-concept/types\";\n\nexport class A_CommonHelper {\n\n    /**\n     * A simple promise that resolves immediately.\n     * Can be used in async functions to create a resolved promise.\n     */\n    static resolve() {\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    /**\n     * Check if a class is inherited from another class\n     * \n     * @param childClass \n     * @param parentClass \n     * @returns \n     */\n    static isInheritedFrom(childClass: any, parentClass: any): boolean {\n        let current = childClass;\n\n        // Traverse the prototype chain\n        while (current) {\n            if (current === parentClass) {\n                return true;\n            }\n            current = Object.getPrototypeOf(current);\n        }\n        return false;\n    }\n\n\n    /**\n     * Get all parent classes of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClasses(childClass: any): any[] {\n\n        // first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        const parents = [] as any[];\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            parents.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return parents;\n\n    }\n\n    /**\n     * Get the class inheritance chain as an array of class names\n     * \n     * @param childClass \n     * @returns \n     */\n    static getClassInheritanceChain(childClass: any): any[] {\n\n        //  first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        //  then if input is instance we have to include its own class name\n        const chain = typeof childClass === 'function'\n            ? [childClass]\n            : [childClass.constructor];\n\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            chain.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return chain;\n    }\n\n    /**\n     * Get the parent class of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClass(childClass: any): any {\n        return Object.getPrototypeOf(childClass);\n    }\n\n    /**\n     *  Omit properties from an object or array with nested objects\n     * \n     * @param input \n     * @param paths \n     * @returns \n     */\n    static omitProperties<T, S extends string>(\n        input: T,\n        paths: string[]\n\n    ): Omit<T, S> {\n\n        // Deep clone the input object or array\n        const result = JSON.parse(JSON.stringify(input));\n\n        // Helper function to recursively remove properties\n        function removeProperties(target: Record<string, any> | any[], currPath: string[]) {\n            const currKey = currPath[0];\n            if (currPath.length === 1) {\n                // If current path has only one key, delete the property\n                delete target[currKey];\n            } else if (target[currKey] !== undefined && typeof target[currKey] === 'object') {\n                // If current key exists and is an object, recursively call removeProperties\n                removeProperties(target[currKey], currPath.slice(1));\n            }\n        }\n\n        // Iterate through each path and remove corresponding properties from the result\n        paths.forEach(path => {\n            const pathKeys = path.split('.');\n            removeProperties(result, pathKeys);\n        });\n\n        return result as Omit<T, S>;\n    }\n\n\n    static isObject(item: unknown): item is Record<string, any> {\n        return item !== null && typeof item === 'object' && !Array.isArray(item);\n    }\n\n    static deepMerge<T = any>(target: any, source: any, visited = new Map<any, any>()): T {\n        if (this.isObject(target) && this.isObject(source)) {\n            for (const key in source) {\n                if (this.isObject(source[key])) {\n                    if (!target[key]) {\n                        target[key] = {};\n                    }\n                    // Check if the source object has already been visited\n                    if (!visited.has(source[key])) {\n                        visited.set(source[key], {});\n                        this.deepMerge(target[key], source[key], visited);\n                    } else {\n                        target[key] = visited.get(source[key]);\n                    }\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    }\n\n\n    static deepClone<T>(target: T): T {\n        // Check if the value is null or undefined\n        if (target === null || target === undefined) {\n            return target;\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target;\n        }\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepClone(item)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (target.hasOwnProperty(key)) {\n                    clone[key] = this.deepClone(target[key]);\n                }\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n\n    static deepCloneAndMerge<T>(target: A_TYPES__DeepPartial<T>, source: T): T {\n        if (\n            (source === null || source === undefined) &&\n            (target === null || target === undefined))\n            return target;\n\n        // Check if the value is null or undefined\n        if ((target === null || target === undefined) &&\n            source\n        ) {\n            return this.deepClone(source);\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target\n        }\n\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepCloneAndMerge(item, source)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (\n                    source[key] !== null\n                    &&\n                    source[key] !== undefined\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key as any], source[key]);\n                else\n                    clone[key as any] = this.deepClone(target[key]);\n            }\n\n            for (const key in source) {\n                if (\n                    target[key] !== undefined\n                    &&\n                    target[key] !== null\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key], source[key]);\n                else\n                    clone[key] = this.deepClone(source[key]);\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n    /**\n     * Get a readable name for a component (string, class, function, React element, instance, etc.)\n     *\n     * Covers:\n     * - string tags (\"div\")\n     * - symbols (Symbol.for('xxx'))\n     * - functions and classes (with name or displayName)\n     * - React elements (object with `type`)\n     * - component instances (constructor.name)\n     * - objects with custom toString returning meaningful info\n     *\n     * Falls back to sensible defaults (\"Unknown\" / \"Anonymous\").\n     */\n    static getComponentName(component: any): string {\n        const UNKNOWN = 'Unknown';\n        const ANONYMOUS = 'Anonymous';\n\n        if (component === null || component === undefined) {\n            return UNKNOWN;\n        }\n\n        // Strings (HTML tags or explicit names)\n        if (typeof component === 'string') {\n            return component || UNKNOWN;\n        }\n\n        // Symbols\n        if (typeof component === 'symbol') {\n            try {\n                return component.toString();\n            } catch {\n                return UNKNOWN;\n            }\n        }\n\n        // Arrays - try to derive from first element\n        if (Array.isArray(component)) {\n            if (component.length === 0) return UNKNOWN;\n            return this.getComponentName(component[0]);\n        }\n\n        // Functions and classes\n        if (typeof component === 'function') {\n            const fnAny = component as any;\n            // Common React convention\n            if (fnAny.displayName) return String(fnAny.displayName);\n            if (fnAny.name) return String(fnAny.name);\n\n            if (fnAny.constructor && fnAny.constructor.name) {\n                return String(fnAny.constructor.name);\n            }\n\n            // Try to extract a name from source if possible\n            try {\n                const src = Function.prototype.toString.call(component);\n                // class Foo { ... } or function foo() { ... } or foo => ...\n                const match = src.match(/^(?:class\\s+([A-Za-z0-9_$]+)|function\\s+([A-Za-z0-9_$]+)|([A-Za-z0-9_$]+)\\s*=>)/);\n                if (match) {\n                    return match[1] || match[2] || match[3] || ANONYMOUS;\n                }\n            } catch {\n                // fallthrough\n            }\n            return ANONYMOUS;\n        }\n\n        // Objects (instances, React elements, plain objects)\n        if (typeof component === 'object') {\n            const objAny = component as any;\n\n            // React element: { type: ComponentOrString, props: ... }\n            if (objAny.type) {\n                return this.getComponentName(objAny.type);\n            }\n\n            // React forwardRef / memo wrappers often expose displayName\n            if (objAny.displayName) return String(objAny.displayName);\n            if (objAny.name) return String(objAny.name);\n\n            // Instance: use constructor name if available and not Object\n            if (objAny.constructor && objAny.constructor.name && objAny.constructor.name !== 'Object') {\n                return String(objAny.constructor.name);\n            }\n\n            // If object implements a meaningful toString, try it\n            try {\n                const s = objAny.toString();\n                if (typeof s === 'string' && s !== '[object Object]') {\n                    return s;\n                }\n            } catch {\n                // ignore\n            }\n\n            return ANONYMOUS;\n        }\n\n        // Fallback for other types\n        try {\n            return String(component);\n        } catch {\n            return UNKNOWN;\n        }\n    }\n}","export class A_CallerError extends Error {\n\n    /**\n     * This error code indicates that there was an issue initializing the A-Caller\n     */\n    static readonly CallerInitializationError = 'Unable to initialize A-Caller';\n}","import { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__FeatureAvailableComponents } from \"@adaas/a-concept/a-feature\";\nimport { A_CallerError } from \"./A_Caller.error\";\n\n\n\n/**\n * This is a common class that uses to return an entity that initiates a feature call\n * \n * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n * \n * [!] the class itself may be retrieved, but may require additional processing inside the feature\n * \n */\nexport class A_Caller<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    /**\n     * The component that initiated the feature call\n     */\n    protected _component: T;\n\n\n    /**\n     * A_Caller allows to get the component that initiated the feature call\n     * \n     * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n     * \n     * [!] If Scope is not provided, a new empty scope will be created and inherited from the global scope\n     * \n     * @param component \n     * @param scope \n     */\n    constructor(\n        component: T\n    ) {\n        this.validateParams(component);\n\n        this._component = component;\n    }\n\n    get component(): T {\n        return this._component;\n    }\n\n\n    /**\n     * Validates the provided parameters and Ensures that the component is of an allowed type\n     * \n     * @param component \n     */\n    protected validateParams(\n        component: T\n    ) {\n        if (!A_TypeGuards.isAllowedForFeatureCall(component)) {\n            throw new A_CallerError(\n                `[${A_CallerError.CallerInitializationError}]: Invalid A-Caller component provided of type: ${typeof component} with value: ${JSON.stringify(component).slice(0, 100)}...`\n            );\n        }\n    }\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_DependencyError extends A_Error {\n\n    static readonly InvalidDependencyTarget = 'Invalid Dependency Target';\n\n    static readonly InvalidLoadTarget = 'Invalid Load Target';\n\n    static readonly InvalidLoadPath = 'Invalid Load Path';\n\n\n    static readonly InvalidDefaultTarget = 'Invalid Default Target';\n\n\n    static readonly ResolutionParametersError = 'Dependency Resolution Parameters Error';\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_DefaultDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Default is required\n */\nexport function A_Dependency_Default(\n    /**\n     * Constructor Parameters that will be used to create the default instance\n     */\n    ...args: any[]\n): A_TYPES__A_Dependency_DefaultDecoratorReturn {\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDefaultTarget,\n                `A-Default cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            create: true,\n            args: args\n        }\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_FlatDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Flat(): A_TYPES__A_Dependency_FlatDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            flat: true,\n        }\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_LoadDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Load is required\n */\nexport function A_Dependency_Load(\n\n): A_TYPES__A_Dependency_LoadDecoratorReturn {\n\n    // if (!path || typeof path !== 'string') {\n    //     throw new A_DependencyError(\n    //         A_DependencyError.InvalidLoadPath,\n    //         `A-Load decorator requires a valid path string to the dependency`\n    //     );\n    // }\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target);\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidLoadTarget,\n                `A-Load cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            load: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_ParentDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Parent(\n    /**\n     * Indicates how many layers up the parent dependency should be resolved from current dependency\n     * \n     * Default: -1 (one layer up)\n     */\n    layerOffset: number = -1\n): A_TYPES__A_Dependency_ParentDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n                \n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            parent: layerOffset\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_RequireDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Require(): A_TYPES__A_Dependency_RequireDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            require: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_AllDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * Should indicate which All is required\n */\nexport function A_Dependency_All(): A_TYPES__A_Dependency_AllDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-All cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            pagination: {\n                ...paramsArray[parameterIndex].resolutionStrategy.pagination,\n                count: -1\n            }\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_EntityInjectionPagination, A_TYPES__A_Dependency_EntityInjectionQuery, A_TYPES__A_Dependency_EntityResolutionConfig, A_TYPES__A_Dependency_QueryDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport type { A_Entity } from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * Query Decorator is only applicable for Entities since Scope instance may have multiple entities but only one component or container, so there is no need for such complex resolution strategies for them, but for entities it is a common case to have multiple instances and need to specify which one(s) to inject.\n * \n * \n * @param query \n * @returns \n */\nexport function A_Dependency_Query<T extends A_Entity = A_Entity>(\n    query: Partial<A_TYPES__A_Dependency_EntityInjectionQuery<T>>,\n    pagination?: Partial<A_TYPES__A_Dependency_EntityInjectionPagination>\n): A_TYPES__A_Dependency_QueryDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-All cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            query: {\n                ...paramsArray[parameterIndex].resolutionStrategy.query,\n                ...query\n            },\n            pagination: {\n                ...paramsArray[parameterIndex].resolutionStrategy.pagination,\n                ...pagination\n            }\n        }\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_Dependency_Default } from \"./A-Dependency-Default.decorator\";\nimport { A_Dependency_Flat } from \"./A-Dependency-Flat.decorator\";\nimport { A_Dependency_Load } from \"./A-Dependency-Load.decorator\";\nimport { A_Dependency_Parent } from \"./A-Dependency-Parent.decorator\";\nimport { A_Dependency_Require } from \"./A-Dependency-Require.decorator\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport {\n    A_TYPES__A_Dependency_EntityInjectionPagination,\n    A_TYPES__A_Dependency_EntityInjectionQuery,\n    A_TYPES__A_Dependency_Serialized,\n    A_TYPES__A_DependencyInjectable,\n    A_TYPES__A_DependencyResolutionStrategy\n} from \"./A-Dependency.types\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_Dependency_All } from \"./A-Dependency-All.decorator\";\nimport { A_Dependency_Query } from \"./A-Dependency-Query.decorator\";\n\n\nexport class A_Dependency<\n    T extends A_TYPES__A_DependencyInjectable = A_TYPES__A_DependencyInjectable\n> {\n    /**\n     * Allows to indicate which Injected parameter is required\n     * \n     * [!] If parameter marked as required is not provided, an error will be thrown\n     * \n     * @returns \n     */\n    static get Required(): typeof A_Dependency_Require {\n        return A_Dependency_Require;\n    }\n    /**\n     * Allows to indicate which dependency should be loaded from a specific path\n     * \n     * @returns \n     */\n    static get Loaded(): typeof A_Dependency_Load {\n        return A_Dependency_Load;\n    }\n    /**\n     * Allows to indicate which dependency default parameters should be used\n     * \n     * @returns \n     */\n    static get Default(): typeof A_Dependency_Default {\n        return A_Dependency_Default;\n    }\n    /**\n     * Allows to indicate which parent dependency should be resolved\n     * e.g. from which layer up the parent should be taken\n     * \n     * @returns \n     */\n    static get Parent(): typeof A_Dependency_Parent {\n        return A_Dependency_Parent;\n    }\n\n    /**\n     * Allows to indicate that the dependency should be resolved in a flat manner\n     * Only in the same scope, without going up to parent scopes\n     * \n     * @returns \n     */\n    static get Flat(): typeof A_Dependency_Flat {\n        return A_Dependency_Flat;\n    }\n\n    /**\n     * Allows to indicate that all instances of the dependency should be resolved\n     * \n     * @returns\n     */\n    static get All(): typeof A_Dependency_All {\n        return A_Dependency_All;\n    }\n\n    /**\n     * Allows to indicate that the dependency should be resolved by specific query parameters\n     * e.g. by ASEID, name, type, custom properties, etc.\n     * \n     * @returns\n     */\n    static get Query(): typeof A_Dependency_Query {\n        return A_Dependency_Query;\n    }\n\n    protected _name: string;\n    protected _target?: A_TYPES__Ctor<T>;\n    protected _resolutionStrategy!: A_TYPES__A_DependencyResolutionStrategy;\n\n    protected _defaultPagination: A_TYPES__A_DependencyResolutionStrategy['pagination'] = {\n        count: 1,\n        from: 'start',\n    };\n    protected _defaultResolutionStrategy: A_TYPES__A_DependencyResolutionStrategy = {\n        require: false,\n        load: false,\n        parent: 0,\n        flat: false,\n        create: false,\n        args: [],\n        query: {},\n        pagination: this._defaultPagination,\n    };\n\n    get flat(): boolean {\n        return this._resolutionStrategy.flat;\n    }\n    get require(): boolean {\n        return this._resolutionStrategy.require;\n    }\n    get load(): boolean {\n        return this._resolutionStrategy.load;\n    }\n    /**\n     * Indicates cases when it's necessary to search across all instances\n     */\n    get all(): boolean {\n        return this._resolutionStrategy.pagination.count !== 1 || Object.keys(this._resolutionStrategy.query).length > 0\n    }\n    get parent(): number {\n        return this._resolutionStrategy.parent;\n    }\n    get create(): any {\n        return this._resolutionStrategy.create;\n    }\n    get args(): any[] {\n        return this._resolutionStrategy.args;\n    }\n    get query(): Partial<A_TYPES__A_Dependency_EntityInjectionQuery<T>> {\n        return this._resolutionStrategy.query as Partial<A_TYPES__A_Dependency_EntityInjectionQuery<T>>;\n    }\n    get pagination(): A_TYPES__A_Dependency_EntityInjectionPagination {\n        return this._resolutionStrategy.pagination;\n    }\n\n\n\n\n    /**\n     * Class instances allows to identify dependencies by name and use them for better type checking\n     * \n     * @param name \n     */\n    constructor(\n        name: string | A_TYPES__Ctor<T>,\n        resolutionStrategy?: Partial<Omit<A_TYPES__A_DependencyResolutionStrategy<T>, 'pagination'> & { pagination: Partial<A_TYPES__A_Dependency_EntityInjectionPagination> }>\n    ) {\n        this._name = typeof name === 'string' ? name : A_CommonHelper.getComponentName(name);\n\n        this._target = typeof name === 'string' ? undefined : name;\n\n        this.resolutionStrategy = resolutionStrategy || {};\n\n        this.initCheck();\n    }\n\n    /**\n     * Gets the dependency name\n     * \n     * Can be identifier, url or any string value\n     * \n     * @returns \n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Returns the original class of the dependency if provided\n     * \n     */\n    get target(): A_TYPES__Ctor<T> | undefined {\n        return this._target;\n    }\n\n    /**\n     * Gets the dependency resolution strategy\n     */\n    get resolutionStrategy(): A_TYPES__A_DependencyResolutionStrategy<T> {\n        return this._resolutionStrategy!;\n    }\n\n    /**\n     * Sets the dependency resolution strategy\n     */\n    set resolutionStrategy(strategy: Partial<Omit<A_TYPES__A_DependencyResolutionStrategy<T>, 'pagination'> & { pagination: Partial<A_TYPES__A_Dependency_EntityInjectionPagination> }>) {\n        this._resolutionStrategy = {\n            ...this._defaultResolutionStrategy,\n            ...this._resolutionStrategy,\n            ...strategy,\n            pagination: {\n                ...this._defaultPagination,\n                ...(this._resolutionStrategy || {}).pagination,\n                ...(strategy.pagination || {})\n            },\n        };\n    }\n\n\n    /**\n     * Method for the parameters check and all input data before usage\n     * \n     * @returns \n     */\n    private initCheck(): this {\n        if (!this._resolutionStrategy) {\n            throw new A_DependencyError(\n                A_DependencyError.ResolutionParametersError,\n                `Resolution strategy parameters are not provided for dependency: ${this._name}`\n            );\n        }\n\n        return this;\n    }\n\n\n    /**\n     * Serializes the dependency to a JSON object\n     * \n     * @returns \n     */\n    toJSON(): A_TYPES__A_Dependency_Serialized<T> {\n        return {\n            name: this._name,\n            all: this.all,\n            require: this.require,\n            load: this.load,\n            parent: this.parent,\n            flat: this.flat,\n            create: this.create,\n            args: this.args,\n            query: this.query,\n            pagination: this.pagination,\n        }\n    }\n}\n\n\n\n","import { A_CommonHelper } from \"./A_Common.helper\";\nimport {\n    A_TYPES__Feature_Constructor,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureExtendDecoratorTarget\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_TYPES__Error_Constructor,\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from \"@adaas/a-concept/a-error\";\nimport {\n    A_Component,\n    A_ComponentMeta,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Container,\n    A_ContainerMeta,\n    A_TYPES__Container_Constructor\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Entity,\n    A_EntityMeta,\n    A_TYPES__Entity_Constructor\n} from \"@adaas/a-concept/a-entity\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_TYPES__Fragment_Constructor,\n    A_Fragment\n} from \"@adaas/a-concept/a-fragment\";\nimport {\n    A_Scope,\n    A_TYPES__Scope_Constructor,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES__ScopeLinkedConstructors\n} from \"@adaas/a-concept/a-scope\";\nimport {\n    A_Caller,\n    A_TYPES__Caller_Constructor\n} from \"@adaas/a-concept/a-caller\";\nimport { A_TYPES__AbstractionAvailableComponents } from \"@adaas/a-concept/a-abstraction\";\nimport { A_TYPES__InjectableTargets } from \"@adaas/a-concept/a-inject\";\nimport { ASEID } from \"@adaas/a-concept/aseid\";\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable\n} from \"@adaas/a-concept/a-dependency\";\n\n\n\nexport class A_TypeGuards {\n    // ===========================================================================\n    // ============================= BASE Type Guards ============================\n    // ===========================================================================\n    /**\n     * Check if value is a string\n     * \n     * @param value \n     * @returns \n     */\n    static isString(value: any): value is string {\n        return typeof value === 'string' || value instanceof String;\n    }\n    /**\n     * Check if value is a number\n     * \n     * @param value \n     * @returns \n     */\n    static isNumber(value: any): value is number {\n        return typeof value === 'number' && isFinite(value);\n    }\n    /**\n     * Check if value is a boolean\n     * \n     * @param value \n     * @returns \n     */\n    static isBoolean(value: any): value is boolean {\n        return typeof value === 'boolean';\n    }\n    /**\n     * Check if value is an array\n     * \n     * @param value \n     * @returns \n     */\n    static isArray(value: any): value is Array<any> {\n        return Array.isArray(value);\n    }\n    /**\n     * Check if value is an object\n     * \n     * @param value \n     * @returns \n     */\n    static isObject<T extends Object = Object>(value: any): value is T {\n        return value && typeof value === 'object' && !Array.isArray(value);\n    }\n    /**\n     * Check if value is a function\n     * \n     * @param value \n     * @returns \n     */\n    static isFunction(value: any): value is Function {\n        return typeof value === 'function';\n    }\n\n    static isUndefined(value: any): value is undefined {\n        return typeof value === 'undefined';\n    }\n\n    static isRegExp(value: any): value is RegExp {\n        return value instanceof RegExp;\n    }\n\n\n    // ===========================================================================\n    // ==========================A-Concept Type Guards ===========================\n    // ===========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Container\n     * \n     * @param ctor \n     * @returns \n     */\n    static isContainerConstructor(ctor: any): ctor is A_TYPES__Container_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Container);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Component\n     * \n     * @param ctor \n     * @returns \n     */\n    static isComponentConstructor(ctor: any): ctor is A_TYPES__Component_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Component);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFragmentConstructor(ctor: any): ctor is A_TYPES__Fragment_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Fragment);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity\n     * \n     * @param ctor \n     * @returns \n     */\n    static isEntityConstructor(ctor: any): ctor is A_TYPES__Entity_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Entity);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isScopeConstructor(ctor: any): ctor is A_TYPES__Scope_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Scope);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isErrorConstructor(ctor: any): ctor is A_TYPES__Error_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, Error);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Feature\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFeatureConstructor(ctor: any): ctor is A_TYPES__Feature_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Feature);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Caller\n     * \n     * @param ctor \n     * @returns \n     */\n    static isCallerConstructor(ctor: any): ctor is A_TYPES__Caller_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Caller);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Dependency\n     * \n     * @param ctor \n     * @returns \n     */\n    static isDependencyConstructor<T extends A_TYPES__A_DependencyInjectable>(ctor: any): ctor is A_Dependency<T> {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Dependency);\n    }\n    // ----------------------------------------------------------------------------\n    // Instance type guards\n    // ----------------------------------------------------------------------------\n    /**\n     * Type guard to check if the instance is of type A_Dependency\n     * \n     * @param instance \n     * @returns \n     */\n    static isDependencyInstance<T extends A_TYPES__A_DependencyInjectable>(instance: any): instance is A_Dependency<T> {\n        return instance instanceof A_Dependency;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Container\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerInstance(instance: any): instance is A_Container {\n        return instance instanceof A_Container;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Component\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentInstance(instance: any): instance is A_Component {\n        return instance instanceof A_Component;\n    }\n\n    /**\n     * Type guard to check if the instance is of type A_Feature\n     * \n     * @param instance \n     * @returns \n     */\n    static isFeatureInstance(instance: any): instance is A_Feature {\n        return instance instanceof A_Feature;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Fragment\n     * \n     * @param instance \n     * @returns \n     */\n    static isFragmentInstance(instance: any): instance is A_Fragment {\n        return instance instanceof A_Fragment;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Entity\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityInstance(instance: any): instance is A_Entity {\n        return instance instanceof A_Entity;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Scope\n     * \n     * @param instance \n     * @returns \n     */\n    static isScopeInstance(instance: any): instance is A_Scope {\n        return instance instanceof A_Scope;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Error\n     * \n     * @param instance \n     * @returns \n     */\n    static isErrorInstance(instance: any): boolean {\n        return instance instanceof Error;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ComponentMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentMetaInstance(instance: any): instance is A_ComponentMeta {\n        return instance instanceof A_ComponentMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ContainerMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerMetaInstance(instance: any): instance is A_ContainerMeta {\n        return instance instanceof A_ContainerMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_EntityMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityMetaInstance(instance: any): instance is A_EntityMeta {\n        return instance instanceof A_EntityMeta;\n    }\n\n\n\n    // ==========================================================================\n    // ========================= SPECIAL Type Guards =============================\n    // ===========================================================================\n    static hasASEID(value: any): value is A_Entity | { aseid: any } {\n        return value && typeof value === 'object' && 'aseid' in value && (A_TypeGuards.isEntityInstance(value) || A_TypeGuards.isErrorInstance(value));\n    }\n\n\n    static isConstructorAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedConstructors {\n        return A_TypeGuards.isContainerConstructor(target)\n            || A_TypeGuards.isFeatureConstructor(target);\n    }\n    static isInstanceAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isFeatureInstance(target);\n    }\n\n    static isConstructorAvailableForAbstraction(target: any): target is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isComponentInstance(target);\n    }\n\n\n    static isTargetAvailableForInjection(target: any): target is A_TYPES__InjectableTargets {\n        return A_TypeGuards.isComponentConstructor(target)\n            || A_TypeGuards.isComponentInstance(target)\n            || A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isEntityInstance(target)\n    }\n\n    static isAllowedForFeatureCall(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureDefinition(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureExtension(param: any): param is A_TYPES__FeatureExtendDecoratorTarget {\n        return A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForAbstractionDefinition(param: any): param is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param);\n    }\n\n    static isAllowedForDependencyDefaultCreation(param: any): param is A_TYPES__Entity_Constructor | A_TYPES__Fragment_Constructor {\n        return A_TypeGuards.isFragmentConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Fragment)\n            || A_TypeGuards.isEntityConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Entity)\n\n    }\n\n    /**\n     * Allows to check if the provided param is of constructor type.\n     * \n     * @param param \n     * @returns \n     */\n    static isErrorConstructorType<T extends A_TYPES__Error_Init>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"title\" in param;\n    }\n\n\n    static isErrorSerializedType<T extends A_TYPES__Error_Serialized>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"aseid\" in param && ASEID.isASEID(param.aseid);\n    }\n\n\n    static isPromiseInstance<T>(value: any): value is Promise<T> {\n        return value instanceof Promise;\n    }\n}","import {\n    A_TYPES__FeatureDefineDecoratorConfig,\n    A_TYPES__FeatureDefineDecoratorDescriptor,\n    A_TYPES__FeatureDefineDecoratorMeta,\n    A_TYPES__FeatureDefineDecoratorTarget\n} from \"./A-Feature.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_EntityMeta,\n    A_TYPES__EntityMetaKey\n} from \"@adaas/a-concept/a-entity\";\nimport {\n    A_ContainerMeta,\n    A_TYPES__ContainerMetaKey\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_ComponentMeta,\n    A_TYPES__ComponentMetaKey\n} from \"@adaas/a-concept/a-component\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * A-Feature decorator\n * \n * This decorator allows to define a custom lifecycle stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Feature and A-Feature decorators is that A-Feature methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\nexport function A_Feature_Define(\n    config: Partial<A_TYPES__FeatureDefineDecoratorConfig> = {}\n) {\n    return function (\n        target: A_TYPES__FeatureDefineDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureDefineDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureDefinitionError,\n                `A-Feature cannot be defined on the ${componentName} level`\n            );\n\n        const meta: A_EntityMeta | A_ContainerMeta | A_ComponentMeta = A_Context.meta(target.constructor as any);\n\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n        }\n\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            /**\n             * Where Key is the name of the feature\n             * \n             * Where value is the list of features\n             */\n            [Key: string]: A_TYPES__FeatureDefineDecoratorMeta\n        }> = meta.get(metaKey) || new A_Meta();\n\n\n        const name = config.name || propertyKey;\n        //  default to false\n        const invoke = config.invoke || false;\n\n\n        // Set the metadata of the method to define a custom Feature with name \n        existedMeta.set(propertyKey, {\n            name: `${target.constructor.name}.${name}`,\n            handler: propertyKey,\n            invoke: invoke,\n            template: config.template && config.template.length ? config.template.map(\n                item => ({\n                    ...item,\n                    before: item.before || '',\n                    after: item.after || '',\n                    behavior: item.behavior || 'sync',\n                    throwOnError: true,\n                    override: item.override || ''\n                })\n            ) : [],\n        });\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target.constructor as any)\n            .set(\n                metaKey,\n                existedMeta\n            );\n\n        const originalMethod = descriptor.value!;\n\n        // Wrap the original method to add the call to `call`\n        // this helps to automatically call the container/entity/component method when it's called\n        descriptor.value = function (...args: any[]) {\n\n            // Call the original method\n            if (!invoke)\n                return originalMethod.apply(this, args);\n            else\n                originalMethod.apply(this, args);\n\n            // Call your `call` with the function name\n            if (typeof (this as A_TYPES__FeatureDefineDecoratorTarget).call === \"function\" && invoke)\n                return (this as A_TYPES__FeatureDefineDecoratorTarget).call(name);\n\n        };\n\n        return descriptor;\n    };\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport {\n    A_TYPES__FeatureExtendDecoratorConfig,\n    A_TYPES__FeatureExtendDecoratorDescriptor,\n    A_TYPES__FeatureExtendDecoratorScopeItem,\n    A_TYPES__FeatureExtendDecoratorTarget\n} from \"./A-Feature.types\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\n\n\n\n\n/**\n * A-Extend decorator\n * \n * This decorator allows to define a custom Extend stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Extend and A-Extend decorators is that A-Extend methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\n/**\n * Use regexp in case if you need more flexibility and control over the name of the method\n * \n * @param regexp \n */\nexport function A_Feature_Extend(\n    /**\n     * The regular expression to match the name of the Feature method to be extended\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend(/.*\\.load/)\n     * ```\n     */\n    regexp: RegExp\n)\n/**\n * In this case the name configurations will be used as an input to get scope and name of target function\n * [!] Not that for all SCOPE will be used OR operator\n * \n * @param config \n */\nexport function A_Feature_Extend(\n    /**\n     * Configuration for the A-Feature-Extend decorator\n     */\n    config: Partial<A_TYPES__FeatureExtendDecoratorConfig>\n)\n/**\n * In this case the name of function will be used as a name of the Feature.\n * [!] AND it will be applicable for ANY element where the name is the same as the name of the function\n */\nexport function A_Feature_Extend()\nexport function A_Feature_Extend(\n    param1?: Partial<A_TYPES__FeatureExtendDecoratorConfig> | RegExp\n) {\n    return function (\n        target: A_TYPES__FeatureExtendDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureExtendDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isAllowedForFeatureExtension(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be applied on the ${componentName} level`\n            );\n\n        let targetRegexp: RegExp;\n        let behavior: 'sync' | 'async' = 'sync';\n        let before: string = '';\n        let after: string = '';\n        let override: string = '';\n        let include: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let exclude: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let throwOnError: boolean = true;\n        let metaKey;\n\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.EXTENSIONS;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.EXTENSIONS\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.EXTENSIONS\n                break;\n        }\n\n\n        switch (true) {\n            case A_TypeGuards.isRegExp(param1):\n                targetRegexp = param1;\n                break;\n\n            case !!param1 && typeof param1 === 'object':\n\n                if (Array.isArray(param1.scope))\n                    include = param1.scope;\n                else if (!!param1.scope && typeof param1.scope === 'object') {\n                    if (Array.isArray(param1.scope.include))\n                        include = param1.scope.include;\n                    if (Array.isArray(param1.scope.exclude))\n                        exclude = param1.scope.exclude;\n                }\n\n\n                targetRegexp = buildTargetRegexp(param1, include, exclude, propertyKey);\n\n                behavior = param1.behavior || behavior;\n                throwOnError = param1.throwOnError !== undefined ? param1.throwOnError : throwOnError;\n\n                before = A_TypeGuards.isArray(param1.before)\n                    ? new RegExp(`^${param1.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.before instanceof RegExp\n                        ? param1.before.source\n                        : ''\n                after = A_TypeGuards.isArray(param1.after)\n                    ? new RegExp(`^${param1.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.after instanceof RegExp\n                        ? param1.after.source\n                        : ''\n\n                override = A_TypeGuards.isArray(param1.override)\n                    ? new RegExp(`^${param1.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.override instanceof RegExp\n                        ? param1.override.source\n                        : ''\n                break;\n\n            default:\n                targetRegexp = new RegExp(`^.*${propertyKey.replace(/\\./g, '\\\\.')}$`);\n                break;\n        }\n\n\n        const existedDefinitions = A_Context\n            .meta(target)\n            .get(metaKey);\n\n        // Get the existed metadata or create a new one\n        const meta = A_Context.meta(target)\n\n        const existedMeta = meta.get(metaKey)\n            ? new A_Meta().from(meta.get(metaKey)!)\n            : new A_Meta();\n\n        if (existedDefinitions\n            && existedDefinitions.size()\n            && existedDefinitions.has(propertyKey)\n            && existedDefinitions.get(propertyKey)!.invoke\n        ) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be used on the method \"${propertyKey}\" because it is already defined as a Feature with \"invoke\" set to true. Please remove the A-Feature-Extend decorator or set \"invoke\" to false in the A-Feature decorator.`\n            );\n        }\n\n        const existedMetaValue = [\n            ...(existedMeta.get(targetRegexp.source) || [])\n        ];\n\n        //  ensure that other regexps are preserved\n        for (const [key, handlers] of existedMeta.entries()) {\n\n            const indexInAnother = handlers.findIndex(item => item.handler === propertyKey);\n\n            //  if the same handler exists in another regexp, remove it\n            if (key !== targetRegexp.source && indexInAnother !== -1) {\n                handlers.splice(indexInAnother, 1);\n                //  if no handlers left for this regexp, remove the regexp entry\n                if (handlers.length === 0) {\n                    existedMeta.delete(key);\n                } else {\n                    existedMeta.set(key, handlers);\n                }\n            }\n        }\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const extension = {\n            name: targetRegexp.source,\n            handler: propertyKey,\n            behavior,\n            before,\n            after,\n            throwOnError,\n            override\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = extension;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(extension);\n        }\n\n\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(targetRegexp.source, existedMetaValue);\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target)\n            .set(metaKey, existedMeta);\n    };\n}\n\n\n/**\n * Builds a target regular expression based on the provided parameters.\n * \n * @param param1 - The first parameter, which can be a string or an object.\n * @param include - An array of items to include in the regular expression.\n * @param exclude - An array of items to exclude from the regular expression.\n * @param propertyKey - The property key to use in the regular expression.\n * @returns A regular expression object.\n */\nexport function buildTargetRegexp(\n    param1: any,\n    include: any[],\n    exclude: any[],\n    propertyKey: string\n) {\n    const includePart = include.length\n        ? `(${include.map(el => el.name).join('|')})`\n        : `.*`;\n\n    const excludePart = exclude.length\n        ? `(?!${exclude.map(el => el.name).join('|')})`\n        : ``;\n\n    const pattern = param1.scope\n        ? `^${excludePart}${includePart}\\\\.${param1.name || propertyKey}$`\n        : `.*\\\\.${param1.name || propertyKey}$`;\n\n    return new RegExp(pattern);\n}","import type { A_Dependency } from \"@adaas/a-concept/a-dependency\"\n\n\n\nexport enum A_TYPES__A_Stage_Status {\n    /**\n     * The stage is currently being processed\n     */\n    PROCESSING = 'PROCESSING',\n    /**\n     * The stage has been completed\n     */\n    COMPLETED = 'COMPLETED',\n    /**\n     * The stage has failed\n     */\n    FAILED = 'FAILED',\n    /**\n     * The stage has been skipped\n     */\n    SKIPPED = 'SKIPPED',\n    /**\n     * The stage has been paused\n     */\n    // PAUSED = 'PAUSED',\n    /**\n     * The stage has been stopped\n     */\n    // STOPPED = 'STOPPED',\n    /**\n     * The stage has been started\n     */\n    // STARTED = 'STARTED',\n    /**\n     * The stage has been initialized\n     */\n    INITIALIZED = 'INITIALIZED',\n    /**\n     * The stage has been aborted\n     */\n    ABORTED = 'ABORTED'\n}\n\nexport type A_TYPES_StageExecutionBehavior = 'async' | 'sync'\n\n\nexport type A_TYPES__A_StageStep = {\n    /**\n     * The component to be called\n     */\n    dependency: A_Dependency,\n    /**\n     * The method to be called on the component\n     */\n    handler: string,\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     * \n     */\n    name: string,\n\n    /**\n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string,\n\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * \n     */\n    override: string\n}\n\n\n\nexport type A_TYPES__Stage_Serialized = {\n\n    /**\n     * The name of the stage\n     */\n    name: string,\n\n    /**\n     *  The status of the stage\n     * \n     */\n    status: A_TYPES__A_Stage_Status,\n\n\n}\n\n\n\nexport type A_TYPES__A_StageStepProcessingExtraParams = {\n    steps: A_TYPES__A_StageStep[]\n    filter: (step: A_TYPES__A_StageStep) => boolean\n}\n","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\nexport class A_StageError extends A_Error {\n\n    static readonly ArgumentsResolutionError = 'A-Stage Arguments Resolution Error';\n\n\n    static get CompileError(): string {\n        return 'Unable to compile A-Stage';\n    }\n\n}\n","import {\n    A_TYPES__A_Stage_Status,\n    A_TYPES__A_StageStep,\n    A_TYPES__Stage_Serialized\n} from \"./A-Stage.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport type { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport type { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_StageError } from \"./A-Stage.error\";\nimport { A_Error } from \"@adaas/a-concept/a-error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport type { A_TYPES__Container_Constructor } from \"@adaas/a-concept/a-container\";\nimport type { A_TYPES__Component_Constructor } from \"@adaas/a-concept/a-component\";\nimport type { A_TYPES__A_DependencyInjectable } from \"@adaas/a-concept/a-dependency\";\n\n\n\nexport class A_Stage {\n\n    /**\n     * The feature that owns this stage\n     */\n    private readonly _feature!: A_Feature;\n    /**\n     * Initial Instructions to process the stage\n     */\n    private readonly _definition!: A_TYPES__A_StageStep;\n    /**\n     * Possible errors during stage processing\n     */\n    private _error?: A_Error;\n    /**\n     * Indicates the current status of the stage\n     */\n    private _status: A_TYPES__A_Stage_Status = A_TYPES__A_Stage_Status.INITIALIZED;\n\n\n    /**\n     * A_Stage is a callable A_Function within A_Feature that should be run with specific parameters.\n     * [!] Depending on the Stage Definition type sync/async function can be executed correspondingly.\n     * \n     * A-Stage is a common object that uses to simplify logic and re-use of A-Feature internals for better composition. \n     */\n    constructor(\n        /**\n         * The feature that owns this stage\n         */\n        feature: A_Feature,\n        /**\n         * The step definitions of the stage\n         */\n        step: A_TYPES__A_StageStep\n    ) {\n        this._feature = feature;\n        this._definition = step;\n    }\n\n    /**\n     * Returns the name of the stage\n     */\n    get name(): string {\n        return this.toString();\n    }\n    /**\n     * Returns the definition of the stage\n     */\n    get definition(): A_TYPES__A_StageStep {\n        return this._definition;\n    }\n    /**\n     * Returns the current status of the stage\n     */\n    get status(): A_TYPES__A_Stage_Status {\n        return this._status;\n    }\n    /**\n     * Returns the feature that owns this stage\n     */\n    get feature(): A_Feature {\n        return this._feature;\n    }\n    /**\n     * Returns true if the stage is processed (completed, failed, or skipped)\n     */\n    get isProcessed(): boolean {\n        return this._status === A_TYPES__A_Stage_Status.COMPLETED\n            || this._status === A_TYPES__A_Stage_Status.FAILED\n            || this._status === A_TYPES__A_Stage_Status.SKIPPED;\n    }\n    /**\n     * Returns the error of the stage\n     */\n    get error(): A_Error | undefined {\n        return this._error;\n    }\n\n    /**\n     * Resolves the arguments of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected getStepArgs(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        let resolverConstructor: A_TYPES__Container_Constructor | A_TYPES__Component_Constructor =\n            (step.dependency.target as A_TYPES__Container_Constructor | A_TYPES__Component_Constructor)\n            || scope.resolveConstructor(step.dependency.name);\n\n        return A_Context\n            .meta(resolverConstructor)\n            .injections(step.handler)\n            .map(dependency => {\n                switch (true) {\n                    case A_TypeGuards.isCallerConstructor(dependency.target):\n                        return this._feature.caller.component;\n\n                    case A_TypeGuards.isFeatureConstructor(dependency.target):\n                        return this._feature;\n\n                    default: {\n                        return scope.resolve(dependency);\n                    }\n                }\n            })\n    }\n\n\n    /**\n     * Resolves the component of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected getStepComponent(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        const { dependency, handler } = step;\n\n        let instance: A_TYPES__A_DependencyInjectable | undefined =\n            (scope.resolve(dependency) || this.feature.scope.resolve(dependency)) as A_TYPES__A_DependencyInjectable\n\n\n        if (!instance)\n            throw new A_StageError(\n                A_StageError.CompileError,\n                `Unable to resolve component ${dependency.name} from scope ${scope.name}`\n            );\n\n        if (!instance[handler])\n            throw new A_StageError(\n                A_StageError.CompileError,\n                `Handler ${handler} not found in ${instance.constructor.name}`\n            );\n\n        return instance;\n    }\n\n\n\n    /**\n     * Calls the handler of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected callStepHandler(\n        step: A_TYPES__A_StageStep,\n        scope: A_Scope\n    ): {\n        handler: Function,\n        params: any[]\n    } {\n        // 1) Resolve component\n        const component = this.getStepComponent(scope, step);\n        // 2) Resolve arguments\n        const callArgs = this.getStepArgs(scope, step);\n\n        // 3) Call handler\n        return {\n            handler: component[step.handler].bind(component),\n            params: callArgs\n        }\n    }\n\n\n    skip() {\n        this._status = A_TYPES__A_Stage_Status.SKIPPED;\n    }\n\n\n    /**\n     * This method processes the stage by executing all the steps\n     * \n     * @param scope - Scope to be used to resolve the steps dependencies\n     */\n    process(\n        /**\n         * Scope to be used to resolve the steps dependencies\n         */\n        scope?: A_Scope,\n    ): Promise<void> | void {\n\n        const targetScope = A_TypeGuards.isScopeInstance(scope)\n            ? scope\n            : this._feature.scope;\n\n        if (!this.isProcessed) {\n            this._status = A_TYPES__A_Stage_Status.PROCESSING;\n\n            const { handler, params } = this.callStepHandler(this._definition, targetScope);\n\n            const result = handler(...params);\n\n            if (A_TypeGuards.isPromiseInstance(result)) {\n\n                return new Promise<void>(\n                    async (resolve, reject) => {\n                        try {\n                            await result;\n\n                            this.completed();\n\n                            return resolve();\n                        } catch (error) {\n                            const wrappedError = new A_Error(error as any);\n\n                            this.failed(wrappedError);\n\n                            if (this._definition.throwOnError) {\n                                return resolve();\n                            } else {\n                                return reject(wrappedError);\n                            }\n                        }\n                    });\n            } else {\n                this.completed();\n            }\n        }\n\n    }\n\n\n    // ==========================================\n    // ============ Status methods =============\n    // ==========================================\n\n    protected completed() {\n        this._status = A_TYPES__A_Stage_Status.COMPLETED;\n    }\n\n    protected failed(\n        error: Error | A_Error | any\n    ) {\n        this._error = new A_Error(error);\n\n        this._status = A_TYPES__A_Stage_Status.FAILED;\n    }\n\n\n\n    // ==========================================\n    // ============ Serialization ===============\n    // ==========================================\n    /**\n     * Serializes the stage to JSON\n     * \n     */\n    toJSON(): A_TYPES__Stage_Serialized {\n        return {\n            name: this.name,\n            status: this.status,\n        }\n    }\n\n    /**\n     * Returns a string representation of the stage\n     * \n     * @returns \n     */\n    toString() {\n        return `A-Stage(${this._feature.name}::${this._definition.behavior}@${this._definition.handler})`;\n    }\n}   ","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_StepManagerError extends A_Error {\n\n\n    static readonly CircularDependencyError = 'A-StepManager Circular Dependency Error';\n\n}","import type {\n    A_Feature,\n    A_TYPES__FeatureDefineDecoratorTemplateItem\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Stage,\n    A_TYPES__A_StageStep\n} from \"@adaas/a-concept/a-stage\";\nimport { A_StepManagerError } from \"./A-StepManager.error\";\n\nexport class A_StepsManager {\n\n    public entities: A_TYPES__A_StageStep[];\n    public graph: Map<string, Set<string>>;\n    public visited: Set<string>;\n    public tempMark: Set<string>;\n    public sortedEntities: string[];\n\n\n    private _isBuilt: boolean = false;\n\n    constructor(entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>) {\n        this.entities = this.prepareSteps(entities);\n\n        this.graph = new Map();\n        this.visited = new Set();\n        this.tempMark = new Set();\n        this.sortedEntities = [];\n\n    }\n\n    private prepareSteps(\n        entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n    ): Array<A_TYPES__A_StageStep> {\n        return entities\n            .map(step => ({\n                ...step,\n\n                behavior: step.behavior || 'sync',\n                before: step.before || '',\n                after: step.after || '',\n                override: step.override || '',\n                throwOnError: false\n            }));\n    }\n\n    private ID(step: A_TYPES__A_StageStep) {\n        return `${step.dependency.name}.${step.handler}`;\n    }\n\n    private buildGraph() {\n        if (this._isBuilt) return;\n        this._isBuilt = true;\n\n        // Filter override\n        this.entities = this.entities\n            .filter((step, i, self) =>\n                !self.some(s => s.override ? new RegExp(s.override).test(this.ID(step)) : false)\n            );\n\n        // Initialize graph nodes\n        this.entities.forEach(entity => this.graph.set(this.ID(entity), new Set()));\n\n        // Add directed edges based on 'before' and 'after'\n        this.entities.forEach(entity => {\n            const entityId = this.ID(entity);\n\n            // Add edges for 'before' dependencies\n            // If entity should execute before targets, then targets depend on entity\n            // So we add edges: target -> entity (target depends on entity)\n            if (entity.before) {\n                const targets = this.matchEntities(entityId, entity.before);\n                targets.forEach(target => {\n                    if (!this.graph.has(target)) this.graph.set(target, new Set());\n                    this.graph.get(target)!.add(entityId); // target depends on entity\n                });\n            }\n\n            // Add edges for 'after' dependencies  \n            // If entity should execute after sources, then entity depends on sources\n            // So we add edges: entity -> source (entity depends on source)\n            if (entity.after) {\n                const sources = this.matchEntities(entityId, entity.after);\n\n                sources.forEach(source => {\n                    if (!this.graph.has(entityId)) this.graph.set(entityId, new Set());\n                    this.graph.get(entityId)!.add(source); // entity depends on source\n                });\n            }\n        });\n    }\n\n    // Match entities by name or regex\n    private matchEntities(entityId: string, pattern: string): string[] {\n        const regex = new RegExp(pattern);\n\n        return this.entities\n            .filter(entity => regex.test(this.ID(entity)) && this.ID(entity) !== entityId)\n            .map(entity => this.ID(entity));\n    }\n\n    // Topological sort with cycle detection\n    private visit(node: string): void {\n        if (this.tempMark.has(node)) {\n            return;\n            // TODO: maybe we have to keep this error but only for partial cases\n            throw new A_StepManagerError(\n                A_StepManagerError.CircularDependencyError,\n                `Circular dependency detected involving step: ${node}. Make sure that your 'before' and 'after' dependencies do not create cycles.`\n            );\n        }\n\n        if (!this.visited.has(node)) {\n            this.tempMark.add(node);\n\n\n            (this.graph.get(node) || []).forEach(neighbor => this.visit(neighbor));\n            this.tempMark.delete(node);\n            this.visited.add(node);\n            this.sortedEntities.push(node);\n\n            // // Visit neighbors in stable order (preserving original order)\n            // const neighbors = Array.from(this.graph.get(node) || []);\n            // // neighbors.sort((a, b) => {\n            // //     const orderA = this.originalOrder.get(a) || 0;\n            // //     const orderB = this.originalOrder.get(b) || 0;\n            // //     return orderA - orderB;\n            // // });\n\n            // neighbors.forEach(neighbor => this.visit(neighbor));\n            // this.tempMark.delete(node);\n            // this.visited.add(node);\n            // this.sortedEntities.push(node);\n        }\n    }\n\n\n    toSortedArray(): Array<string> {\n        this.buildGraph();\n\n        // Start topological sort\n        this.entities.forEach(entity => {\n            if (!this.visited.has(this.ID(entity))) this.visit(this.ID(entity));\n        });\n\n        return this.sortedEntities;\n    }\n\n    // Sort the entities based on dependencies\n    toStages(feature: A_Feature): Array<A_Stage> {\n\n\n        const sortedNames = this.toSortedArray();\n\n\n        // Map sorted names back to entity objects\n        return sortedNames\n            .map(id => {\n                const step = this.entities.find(entity => this.ID(entity) === id)!;\n\n\n                return new A_Stage(feature, step);\n            });\n    }\n}\n\n\n","import {\n    A_TYPES__Feature_Init,\n    A_TYPES__Feature_InitWithComponent,\n    A_TYPES__Feature_InitWithTemplate,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureState,\n} from \"./A-Feature.types\";\nimport { A_Feature_Define } from \"./A-Feature-Define.decorator\";\nimport { A_Feature_Extend } from \"./A-Feature-Extend.decorator\";\nimport {\n    A_Stage,\n    A_StageError\n} from \"@adaas/a-concept/a-stage\";\nimport { A_StepsManager } from \"@adaas/a-concept/a-step-manager\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Caller } from \"@adaas/a-concept/a-caller\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_Component } from \"@adaas/a-concept/a-component\";\n\n\n/**\n * A_Feature is representing a feature that can be executed across multiple components\n * This class stores the steps of the feature and executes them in order of appearance\n * \n * Using A_Feature.Define and A_Feature.Extend decorators to define and extend the feature methods \n * across the different, distributed components\n * \n */\nexport class A_Feature<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    // =============================================================================\n    // --------------------------- Static Methods ---------------------------------\n    // =============================================================================\n    /**\n     * Define a new A-Feature\n     */\n    static get Define(): typeof A_Feature_Define {\n        return A_Feature_Define;\n    }\n\n    /**\n     * Extend an existing A-Feature\n     */\n    static get Extend(): typeof A_Feature_Extend {\n        return A_Feature_Extend;\n    }\n    // =============================================================================\n    // --------------------------- Internal Properties ----------------------------\n    // =============================================================================\n    /**\n     * The name of the Feature\n     */\n    protected _name!: string;\n    /**\n     * List of stages that are part of this Feature\n     */\n    protected _stages: Array<A_Stage> = [];\n    /**\n     * The Stage currently being processed\n     */\n    protected _current?: A_Stage;\n    /**\n     * Actual Index of the current Stage being processed\n     */\n    protected _index: number = 0;\n    /**\n     * Steps Manager to organize the steps into stages\n     */\n    protected _SM!: A_StepsManager;\n    /**\n     * The Caller that initiated the Feature call\n     */\n    protected _caller!: A_Caller<T>;\n    /**\n     * The current state of the Feature\n     */\n    protected _state: A_TYPES__FeatureState = A_TYPES__FeatureState.INITIALIZED;\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    protected _error?: A_FeatureError\n\n\n\n    /**\n     * A-Feature is a pipeline distributed by multiple components that can be easily attached or detached from the scope. \n     * Feature itself does not have scope, but attached to the caller who dictates how feature should be processed. \n     * \n     * Comparing to A-Command Feature does not store any state except statuses for better analysis. \n     * \n     * [!] Note: If A-Feature should have result use A-Fragment \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Feature Initialization parameters\n         */\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        this.validateParams(params);\n\n        const initializer = this.getInitializer(params);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, params);\n    }\n\n\n    /**\n     * The name of the Feature\n     */\n    get name(): string { return this._name; }\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    get error(): A_FeatureError | undefined { return this._error; }\n    /**\n     * The current state of the Feature\n     */\n    get state(): A_TYPES__FeatureState { return this._state; }\n    /**\n     * Sets the current state of the Feature\n     */\n    get index(): number { return this._index; }\n    /**\n     * Returns the current A-Feature Stage\n     */\n    get stage(): A_Stage | undefined { return this._current; }\n    /**\n     * The Caller that initiated the Feature call\n     */\n    get caller(): A_Caller<T> { return this._caller; }\n    /**\n     * The Scope allocated for the Feature Execution\n     */\n    get scope(): A_Scope { return A_Context.scope(this); }\n    /**\n     * The number of stages in the feature\n     */\n    get size(): number {\n        return this._stages.length;\n    }\n\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.stage\n            || this._index >= this._stages.length;\n    }\n    /**\n     * Indicates whether the feature has been processed (completed, failed, or interrupted)\n     */\n    get isProcessed(): boolean {\n        return this.state === A_TYPES__FeatureState.COMPLETED\n            || this.state === A_TYPES__FeatureState.FAILED\n            || this.state === A_TYPES__FeatureState.INTERRUPTED;\n    }\n    /**\n     * Iterator to iterate over the steps of the feature\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<A_Stage, any> {\n        return {\n            next: (): IteratorResult<A_Stage, any> => {\n                if (!this.isDone) {\n                    this._current = this._stages[this._index];\n                    this._index++;\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    // ============================================================================\n    // ------------------------ Initialization Methods ----------------------------\n    // ============================================================================\n    /**\n     * Validates the provided parameters for A-Feature initialization\n     * \n     * @param params \n     */\n    protected validateParams(\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        if (!params || typeof params !== 'object') {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n            );\n        }\n    }\n    /**\n     * Returns the appropriate initializer method based on the provided parameters\n     * \n     * @param params \n     * @returns \n     */\n    protected getInitializer(\n        params: A_TYPES__Feature_Init<T>\n    ): (param1: any) => void | (() => void) {\n\n        switch (true) {\n            case !('template' in params):\n                return this.fromComponent;\n\n            case 'template' in params:\n                return this.fromTemplate;\n            default:\n                throw new A_FeatureError(\n                    A_FeatureError.FeatureInitializationError,\n                    `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n                );\n        }\n    }\n    /**\n     * Initializes the A-Feature from the provided template\n     * \n     * @param params \n     */\n    protected fromTemplate(\n        params: A_TYPES__Feature_InitWithTemplate<T>\n    ) {\n        if (!params.template || !Array.isArray(params.template)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature template provided of type: ${typeof params.template} with value: ${JSON.stringify(params.template).slice(0, 100)}...`\n            );\n        }\n\n        if (!params.component && (!params.scope || !(params.scope instanceof A_Scope))) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature scope provided of type: ${typeof params.scope} with value: ${JSON.stringify(params.scope).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            if (params.component)\n                componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        //   - Just to prevent issues with undefined caller in features without component\n        //   - TODO: maybe would be better to allow passing caller in params?\n        this._caller = new A_Caller<T>(params.component || new A_Component() as T);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(params.template);\n\n        // 7) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 8) set the first stage as current\n        this._current = this._stages[0];\n    }\n    /**\n     * Initializes the A-Feature from the provided component\n     * \n     * @param params \n     */\n    protected fromComponent(\n        params: A_TYPES__Feature_InitWithComponent<T>\n    ) {\n        if (!params.component || !A_TypeGuards.isAllowedForFeatureDefinition(params.component)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature component provided of type: ${typeof params.component} with value: ${JSON.stringify(params.component).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        this._caller = new A_Caller<T>(params.component);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) retrieve the template from the context\n        const template = A_Context.featureTemplate(this._name, this._caller.component, scope);\n\n        // 7) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(template);\n\n        // 8) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 9) set the first stage as current\n        this._current = this._stages[0];\n    }\n\n\n    // ============================================================================\n    // ----------------------- Main Processing Methods ----------------------------\n    // ============================================================================\n    /**\n     * This method processes the feature by executing all the stages\n     * \n     */\n    process(\n        /**\n         * Optional scope to be used to resolve the steps dependencies\n         * If not provided, the scope of the caller component will be used\n         */\n        scope?: A_Scope,\n    ): Promise<void> | void {\n        try {\n            // It seems like this is a bad idea to enforce scope inheritance here\n            // ---------------------------------------------------------------\n            // if (scope && !scope.isInheritedFrom(A_Context.scope(this)))\n            //     scope.inherit(A_Context.scope(this));\n\n            if (this.isProcessed)\n                return;\n\n            this._state = A_TYPES__FeatureState.PROCESSING;\n\n            // Convert iterator to array to get all stages\n            const stages = Array.from(this);\n\n            return this.processStagesSequentially(stages, scope, 0);\n\n        } catch (error) {\n            throw this.failed(new A_FeatureError({\n                title: A_FeatureError.FeatureProcessingError,\n                description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${this.stage?.name || 'N/A'}.`,\n                stage: this.stage,\n                originalError: error\n            }));\n        }\n    }\n\n    /**\n     * Process stages one by one, ensuring each stage completes before starting the next\n     */\n    private processStagesSequentially(\n        stages: A_Stage[],\n        scope: A_Scope | undefined,\n        index: number\n    ): Promise<void> | void {\n        try {\n            // Check if feature has been interrupted before processing next stage\n            if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n                return;\n            }\n\n            // If we've processed all stages, complete the feature\n            if (index >= stages.length) {\n                this.completed();\n                return;\n            }\n\n            const stage = stages[index];\n            const result = stage.process(scope);\n\n            if (A_TypeGuards.isPromiseInstance(result)) {\n                // Async stage - return promise that processes remaining stages\n                return result\n                    .then(() => {\n                        // Check for interruption after async stage completes\n                        if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n                            return;\n                        }\n                        return this.processStagesSequentially(stages, scope, index + 1);\n                    })\n                    .catch(error => {\n                        throw this.failed(new A_FeatureError({\n                            title: A_FeatureError.FeatureProcessingError,\n                            description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${stage.name}.`,\n                            stage: stage,\n                            originalError: error\n                        }));\n                    });\n            } else {\n                // Sync stage - continue to next stage immediately\n                return this.processStagesSequentially(stages, scope, index + 1);\n            }\n        } catch (error) {\n            throw this.failed(new A_FeatureError({\n                title: A_FeatureError.FeatureProcessingError,\n                description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${this.stage?.name || 'N/A'}.`,\n                stage: this.stage,\n                originalError: error\n            }));\n        }\n    }\n    /**\n     * This method moves the feature to the next stage\n     * \n     * @param stage \n     */\n    next(stage) {\n        const stageIndex = this._stages.indexOf(stage);\n\n        this._index = stageIndex + 1;\n\n        if (this._index >= this._stages.length) {\n            this.completed();\n        }\n    }\n    /**\n     * This method marks the feature as completed and returns the result\n     * Uses to interrupt or end the feature processing\n     * \n     * @param result \n     * @returns \n     */\n    completed(): void {\n        if (this.isProcessed) return;\n\n        // Don't complete if interrupted\n        if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n            return;\n        }\n\n        this._state = A_TYPES__FeatureState.COMPLETED;\n\n        this.scope.destroy();\n    }\n    /**\n     * This method marks the feature as failed and returns the error\n     * Uses to mark the feature as failed\n     * \n     * @param error \n     * @returns The error that caused the failure\n     */\n    failed(error: A_FeatureError): A_FeatureError {\n        if (this.isProcessed) return this._error!;\n\n        this._state = A_TYPES__FeatureState.FAILED;\n\n        this._error = error;\n\n        this.scope.destroy();\n\n        return this._error;\n    }\n    /**\n     * This method marks the feature as interrupted and throws an error\n     * Uses to interrupt or end the feature processing\n     * \n     * @param error \n     */\n    interrupt(\n        /**\n         * The reason of feature interruption\n         */\n        reason?: string | A_StageError | Error\n    ): A_FeatureError {\n        if (this.isProcessed) return this._error!;\n\n        this._state = A_TYPES__FeatureState.INTERRUPTED;\n\n        switch (true) {\n            case A_TypeGuards.isString(reason):\n                this._error = new A_FeatureError(A_FeatureError.Interruption, reason as string);\n                break;\n\n            case A_TypeGuards.isErrorInstance(reason):\n                this._error = new A_FeatureError({\n                    code: A_FeatureError.Interruption,\n                    title: (reason as any).title || 'Feature Interrupted',\n                    description: (reason as any).description || (reason as Error).message,\n                    stage: this.stage,\n                    originalError: reason\n                });\n                break;\n\n            default:\n                this._error = new A_FeatureError(A_FeatureError.Interruption, 'Feature was interrupted');\n                break;\n        }\n\n        this.scope.destroy();\n\n        return this._error;\n    }\n\n\n    /**\n     * Allows to chain the feature to another feature. \n     * In this case the parent feature scope (if new not provided), stages, caller will be used.\n     * \n     * [!] Note: Chained feature will use the same caller as the parent feature.\n     * \n     * @param feature \n     */\n    chain(\n        /**\n         * A Feature to be chained\n         */\n        feature: A_Feature,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        /**\n         * Component whose feature should be chained\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * A Feature Name to be chained\n         */\n        feature: string,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        param1: A_TYPES__FeatureAvailableComponents | A_Feature,\n        param2?: string | A_Scope,\n        param3?: A_Scope\n    ) {\n        let feature: A_Feature;\n        let scope: A_Scope | undefined;\n\n        if (param1 instanceof A_Feature) {\n            feature = param1;\n            scope = param2 instanceof A_Scope ? param2 : undefined;\n        } else {\n            feature = new A_Feature({\n                name: param2 as string,\n                component: param1 as T\n            });\n            scope = param3 instanceof A_Scope ? param3 : undefined;\n        }\n\n        const featureScope = scope || this.scope;\n\n        // create new caller for the chained feature\n        feature._caller = this._caller;\n\n        const result = feature.process(featureScope);\n\n        // If the chained feature processing returns a promise, ensure errors are propagated\n        if (A_TypeGuards.isPromiseInstance(result)) {\n            return result.catch(error => {\n                // Re-throw to ensure chained feature errors propagate to caller\n                throw error;\n            });\n        }\n\n        return result;\n    }\n\n\n\n\n    toString(): string {\n        return `A-Feature(${this.caller.component?.constructor?.name || 'Unknown'}::${this.name})`;\n    }\n}","import { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\n\n\n\n/**\n * A-Component is a primary \"extendable\" object in the system\n * A unique combination of Components creates completely new functionality\n * \n * The most important thing is that A-Component is STATELESS, it means that it doesn't store any state in itself\n * \n * \n * [!] Every A-Component is a singleton, so if you need to create multiple instances of the same logic - use A-Container\n * [!] So one scope can have only one instance of the same A-Component\n * [!] Every A-Component can be extended by features and extensions\n * [!] ONLY A-Component can have A-Feature extensions\n *\n */\nexport class A_Component {\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * Scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ): Promise<any> | void {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return newFeature.process(scope);\n    }\n}\n\n\n\n","\n\n\nexport enum A_TYPES__ComponentMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    INJECTIONS = 'a-component-injections',\n    ABSTRACTIONS = 'a-component-abstractions',\n}","import { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\nimport { A_TYPES__ConceptAbstractionMeta } from \"@adaas/a-concept/a-concept\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMeta, A_TYPES__ComponentMetaExtension } from \"./A-Component.types\";\nimport { A_TYPES__ComponentMetaKey } from \"./A-Component.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\n\n\nexport class A_ComponentMeta<T extends A_TYPES__ComponentMeta = A_TYPES__ComponentMeta> extends A_Meta<T> {\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ComponentMetaExtension[] {\n        const steps: A_TYPES__ComponentMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ComponentMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override: ''\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n    /**\n     * Returns all features defined in the Component\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ComponentMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Component during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: any\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ComponentMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        // component: constructor,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n}","import {\n    A_TYPES__ScopeConfig,\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES__Scope_Constructor,\n    A_TYPES__ScopeLinkedConstructors\n} from './A-Scope.types'\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_Component,\n    A_TYPES__Component_Constructor,\n    A_TYPES__ComponentMetaKey\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Entity,\n    A_TYPES__Entity_Constructor\n} from \"@adaas/a-concept/a-entity\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FormatterHelper} from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport {\n    A_Error,\n    A_TYPES__Error_Constructor\n} from \"@adaas/a-concept/a-error\";\nimport { A_ScopeError } from '@adaas/a-concept/a-scope';\nimport { A_Meta } from '@adaas/a-concept/a-meta';\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable\n} from '@adaas/a-concept/a-dependency';\nimport { A_TYPES__Ctor } from '@adaas/a-concept/types';\nimport { ASEID } from '@adaas/a-concept/aseid';\n\n\n\n\nexport class A_Scope<\n    _MetaItems extends Record<string, any> = any,\n    _ComponentType extends A_TYPES__Component_Constructor[] = A_TYPES__Component_Constructor[],\n    _ErrorType extends A_TYPES__Error_Constructor[] = A_TYPES__Error_Constructor[],\n    _EntityType extends A_TYPES__Entity_Constructor[] = A_TYPES__Entity_Constructor[],\n    _FragmentType extends A_Fragment[] = A_Fragment[],\n> {\n\n    /**\n     * Scope Name uses for identification and logging purposes\n     */\n    protected _name!: string;\n    /**\n     * Parent scope reference, used for inheritance of components, fragments, entities and commands\n     */\n    protected _parent?: A_Scope;\n    /**\n     * Internal meta storage using A_Meta for type-safe key-value operations.\n     * This stores all the scope's runtime data that can be accessed and modified\n     * throughout the execution pipeline or within running containers.\n     */\n    protected _meta: A_Meta<_MetaItems> = new A_Meta<_MetaItems>();\n\n    // ===========================================================================\n    // --------------------ALLowed Constructors--------------------------------\n    // ===========================================================================\n    /**\n     * A set of allowed components, A set of constructors that are allowed in the scope\n     *      \n     */\n    protected _allowedComponents = new Set<_ComponentType[number]>();\n    /**\n     * A set of allowed errors, A set of constructors that are allowed in the scope\n     */\n    protected _allowedErrors = new Set<_ErrorType[number]>();\n    /**\n     * A set of allowed entities, A set of constructors that are allowed in the scope\n     */\n    protected _allowedEntities = new Set<_EntityType[number]>();\n    /**\n     * A set of allowed fragments, A set of constructors that are allowed in the scope\n     */\n    protected _allowedFragments = new Set<A_TYPES__Fragment_Constructor<_FragmentType[number]>>();\n\n\n\n    // ===========================================================================\n    // --------------------Internal Storage--------------------------------\n    // ===========================================================================\n    /**\n     * Storage for the components, should be strong as components are unique per scope\n     */\n    protected _components: Map<_ComponentType[number], InstanceType<_ComponentType[number]>> = new Map();\n    /**\n     * Storage for the errors, should be strong as errors are unique per code\n     */\n    protected _errors: Map<string, InstanceType<_ErrorType[number]>> = new Map();\n    /**\n     * Storage for the entities, should be strong as entities are unique per aseid\n     */\n    protected _entities: Map<string, InstanceType<_EntityType[number]>> = new Map();\n    /**\n     * Storage for the fragments, should be weak as fragments are singletons per scope\n     */\n    protected _fragments: Map<A_TYPES__Fragment_Constructor<_FragmentType[number]>, _FragmentType[number]> = new Map();\n    /**\n     * Storage for imported scopes \n     */\n    protected _imports: Set<A_Scope> = new Set();\n\n\n\n    // ===========================================================================\n    // --------------------Readonly Allowed Properties----------------------------\n    // ===========================================================================\n    /**\n     * Returns the name of the scope\n     */\n    get name() { return this._name }\n    /**\n     * Returns the meta object of the scope\n     */\n    get meta() { return this._meta }\n    /**\n     * Returns a list of Constructors for A-Components that are available in the scope\n     */\n    get allowedComponents() { return this._allowedComponents }\n    /**\n     * Returns a list of Constructors for A-Entities that are available in the scope\n     */\n    get allowedEntities() { return this._allowedEntities }\n    /**\n     * Returns a list of Constructors for A-Fragments that are available in the scope\n     */\n    get allowedFragments() { return this._allowedFragments }\n    /**\n     * Returns a list of Constructors for A-Errors that are available in the scope\n     */\n    get allowedErrors() { return this._allowedErrors }\n    // ===========================================================================\n    // --------------------Readonly Registered Properties--------------------------\n    // ===========================================================================\n    /**\n     * Returns an Array of entities registered in the scope\n     * \n     * [!] One entity per aseid\n     */\n    get entities(): Array<InstanceType<_EntityType[number]>> { return Array.from(this._entities.values()) }\n    /**\n     * Returns an Array of fragments registered in the scope\n     * \n     * [!] One fragment per scope\n     */\n    get fragments(): Array<_FragmentType[number]> { return Array.from(this._fragments.values()) }\n    /**\n     * Returns an Array of components registered in the scope\n     * \n     * [!] One component instance per scope\n     */\n    get components(): Array<InstanceType<_ComponentType[number]>> { return Array.from(this._components.values()) }\n    /**\n     * Returns an Array of errors registered in the scope\n     * \n     * [!] One error per code\n     */\n    get errors(): Array<InstanceType<_ErrorType[number]>> { return Array.from(this._errors.values()) }\n    /**\n     * Returns an Array of imported scopes\n     * [!] Imported scopes are scopes that have been imported into the current scope using the import() method\n     */\n    get imports(): Array<A_Scope> { return Array.from(this._imports.values()) }\n\n    /**\n     * Returns the parent scope of the current scope\n     * \n     * @param setValue \n     * @returns \n     */\n    get parent(): A_Scope | undefined {\n        return this._parent;\n    }\n    \n    /**\n     * A_Scope is a unique A-Concept Structure that allows to operate with A-Concept Primitives and Models in a specific context and with specific rules.  \n     *  It refers to the visibility and accessibility of :\n     * - variables, \n     * - Components, \n     * - Context Fragments \n     * - Entities\n     * - and objects in different parts of your code. \n     * Scope determines where a particular piece of data (like a variable or function) \n     * can be accessed, modified, or referenced, and it plays a crucial role in avoiding naming collisions and ensuring data integrity. \n     * \n     * [!] The scope behavior is similar to tree structure where each scope can have a parent scope and inherit its components, fragments, entities and errors\n     * \n     * @param params \n     * @param config \n     */\n    constructor()\n    constructor(\n        /**\n         * A set of constructors that are allowed in the scope\n         */\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        /**\n         * Configuration options for the scope\n         */\n        config?: Partial<A_TYPES__ScopeConfig>\n    )\n    constructor(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ) {\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n    /**\n     * Generator to iterate through all parent scopes\n     */\n    *parents(): Generator<A_Scope> {\n        let currentParent = this._parent;\n        while (currentParent) {\n            yield currentParent;\n            currentParent = currentParent._parent;\n        }\n    }\n\n    /**\n     * This method is used to retrieve a parent scope at a specific level\n     * \n     * [!] Note that if the level is out of bounds, undefined is returned\n     * [!!] Uses negative values for levels (e.g. -1 for immediate parent, -2 for grandparent, etc.)\n     * \n     * @param level \n     * @returns \n     */\n    parentOffset<T extends A_Scope>(\n        /**\n         * Level of the parent scope to retrieve\n         * \n         * Examples:\n         * - level 0 - this scope\n         * - level -1 - parent\n         * - level -2 - grandparent\n         */\n        layerOffset: number\n    ): T | undefined {\n        let parentScope: A_Scope | undefined = this;\n\n        while (layerOffset <= -1 && parentScope) {\n            parentScope = parentScope.parent;\n            layerOffset++;\n        }\n\n        return parentScope as T\n    }\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n            case !param1 && !param2: ;\n                return this.defaultInitialized;\n\n            case !!param1:\n                return this.defaultInitialized;\n            default:\n                throw new A_ScopeError(A_ScopeError.ConstructorError, 'Invalid parameters provided to A_Scope constructor');\n        }\n    }\n\n\n\n    protected defaultInitialized(\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>> = {},\n        config: Partial<A_TYPES__ScopeConfig> = {}\n    ) {\n        this._name = params.name || this.constructor.name\n\n        this.initComponents(params.components);\n        this.initErrors(params.errors);\n        this.initFragments(params.fragments);\n        this.initEntities(params.entities);\n        this.initMeta(params.meta);\n\n        if (config.parent) {\n            this._parent = config.parent;\n        }\n    }\n\n\n    //==========================================================================\n    // --------------------Scope Initialization Methods---------------------------\n    //==========================================================================\n\n    /**\n     * This method is used to initialize the components in the scope\n     * To save memory components are initialized only when they are requested\n     * \n     * This method only registers the component in the scope in case they are not registered yet\n     * \n     * @param _components \n     */\n    protected initComponents(_components?: _ComponentType) { _components?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the errors in the scope\n     * \n     * This method only registers the errors in the scope in case they are not registered yet\n     * \n     * @param _errors \n     */\n    protected initErrors(_errors?: _ErrorType) { _errors?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the entities in the scope\n     * \n     * This method only registers the entities in the scope in case they are not registered yet\n     * \n     * @param _entities \n     */\n    protected initEntities(_entities?: [\n        ..._EntityType,\n        ...InstanceType<_EntityType[number]>[]\n    ]) { _entities?.forEach(ent => this.register(ent as any)); }\n    /**\n     * This method is used to initialize the fragments in the scope\n     * \n     * This method only registers the fragments in the scope in case they are not registered yet\n     * \n     * @param _fragments \n     */\n    protected initFragments(_fragments?: _FragmentType) { _fragments?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the meta in the scope\n     * \n     * This method only sets the meta values in the scope in case they are not set yet\n     * \n     * @param _meta \n     */\n    protected initMeta(_meta?: Partial<_MetaItems>) {\n        if (_meta) {\n            Object.entries(_meta).forEach(([key, value]) => {\n                this._meta.set(key as keyof _MetaItems, value as _MetaItems[keyof _MetaItems]);\n            });\n        }\n    }\n\n\n    // ==========================================================================\n    // --------------------Scope Public Methods-----------------------------------\n    // ==========================================================================\n    /**\n     * This method is used to destroy the scope and all its registered components, fragments and entities\n     * \n     * [!] This method deregisters all components, fragments and entities from the A-Context\n     * [!] This method also clears all internal registries and collections\n     */\n    destroy() {\n        this._components.forEach(component => A_Context.deregister(component));\n        this._fragments.forEach(fragment => A_Context.deregister(fragment));\n        this._entities.forEach(entity => A_Context.deregister(entity));\n\n        this._components.clear();\n        this._errors.clear();\n        this._fragments.clear();\n        this._entities.clear();\n        this._imports.clear();\n\n        if (this.issuer()) {\n            A_Context.deallocate(this);\n        }\n    }\n\n\n    /**\n     * Retrieves a value from the scope's meta.\n     * \n     * @param param - The key to retrieve\n     * @returns The value associated with the key, or undefined if not found\n     * \n     * @example\n     * ```typescript\n     * const userId = scope.get('userId');\n     * if (userId) {\n     *   console.log(`Current user: ${userId}`);\n     * }\n     * ```\n     */\n    get<K extends keyof _MetaItems>(param: K): _MetaItems[K] | undefined {\n        return this._meta.get(param);\n    }\n\n    /**\n     * Stores a value in the scope's meta.\n     * \n     * @param param - The key to store the value under\n     * @param value - The value to store\n     * \n     * @example\n     * ```typescript\n     * scope.set('userId', '12345');\n     * scope.set('role', 'admin');\n     * ```\n     */\n    set<K extends keyof _MetaItems>(param: K, value: _MetaItems[K]): void {\n        this._meta.set(param, value);\n    }\n\n\n    /**\n     * Returns the issuer of the scope, useful for debugging and tracking purposes\n     * \n     * Issuer can be:\n     * - A Container that allocated the scope\n     * - A Feature that allocated the scope\n     * \n     * [!] Note that the issuer is the direct allocator of the scope, so if a Container allocated a Feature that allocated the scope, the issuer will be the Feature\n     * \n     * @returns \n     */\n    issuer<T extends A_TYPES__ScopeLinkedComponents>(): T | undefined {\n        return A_Context.issuer(this) as T;\n    }\n\n\n\n    /**\n     * This method is used to inherit from a parent scope\n     * \n     * [!] This method checks for circular inheritance and throws an error if detected\n     * \n     * @param parent \n     * @returns \n     */\n    inherit(parent: A_Scope): A_Scope {\n        if (!parent)\n            throw new A_ScopeError(\n                A_ScopeError.InitializationError,\n                `Invalid parent scope provided`\n            );\n\n        if (parent === this)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Unable to inherit scope ${this.name} from itself`\n            );\n\n        if (parent === this._parent)\n            return this;\n\n        // Prevent circular inheritance\n        const circularCheck = this.checkCircularInheritance(parent);\n\n        if (circularCheck)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Circular inheritance detected: ${[...circularCheck, parent.name].join(' -> ')}`\n            );\n\n\n        this._parent = parent;\n        return this;\n    }\n\n\n    /**\n     * This method allows to import other scopes, to make their dependencies available in the current scope\n     * \n     * [!] Import doesn't create a parent-child relationship between scopes, it just copies the dependencies from the imported scopes\n     * [!] It doesn't change the entities ownership, so entities remain unique to their original scopes\n     * \n     * @param scopes \n     * @returns \n     */\n    import(...scopes: A_Scope[]): A_Scope {\n\n        scopes.forEach(scope => {\n            if (scope === this)\n                throw new A_ScopeError(\n                    A_ScopeError.CircularImportError,\n                    `Unable to import scope ${this.name} into itself`\n                );\n\n            if (this._imports.has(scope))\n                return;\n\n            this._imports.add(scope);\n        });\n\n        return this;\n    }\n\n    /**\n     * This method allows to deimport other scopes, to remove their dependencies from the current scope\n     * \n     * \n     * @param scopes \n     * @returns \n     */\n    deimport(...scopes: A_Scope[]): A_Scope {\n\n        scopes.forEach(scope => {\n            if (this._imports.has(scope))\n                this._imports.delete(scope);\n        });\n        return this;\n    }\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component in the current scope and all parent scopes\n     * \n     * @param component \n     * @returns \n     */\n    has<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    has<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    has<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    has<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    has(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    has<T extends A_TYPES__A_DependencyInjectable>(\n        ctor: A_TYPES__Ctor<T> | string\n    ): boolean\n    has<T extends A_TYPES__A_DependencyInjectable>(\n        ctor: A_TYPES__Ctor<T> | string\n    ): boolean {\n\n        let found = this.hasFlat(ctor as any);\n\n        if (!found && !!this._parent)\n            try {\n                return this._parent.has(ctor as any);\n            } catch (error) {\n                return false;\n            }\n\n        return found;\n    }\n\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component ONLY in the current scope\n     * \n     * @param component \n     * @returns \n     */\n    hasFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    hasFlat(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    hasFlat(\n        ctor: unknown\n    ): boolean {\n\n        let found = false;\n\n        switch (true) {\n            // 1) Check if it's a Scope. It's always true since it returns itself\n            case A_TypeGuards.isScopeConstructor(ctor):\n                return true;\n\n            // 2) Check by string name.  \n            case A_TypeGuards.isString(ctor): {\n\n                // 2.1 Check if it's a component name\n                const possibleComponent = Array.from(this.allowedComponents).find(c => c.name === ctor);\n                if (possibleComponent) found = true;\n\n                // 2.2 Check if it's a fragment name\n                const possibleFragment = Array.from(this.allowedFragments).find(f => f.name === ctor);\n                if (possibleFragment) found = true;\n\n                // 2.3 Check if it's an entity name or entity static entity property\n                const possibleEntity = Array.from(this.allowedEntities).find(e => e.name === ctor);\n                if (possibleEntity) found = true;\n\n                // 2.4 Check if it's an error name\n                const possibleError = Array.from(this.allowedErrors).find(e => e.name === ctor);\n                if (possibleError) found = true;\n\n                break;\n            }\n            // 3) Check if it's a Component\n            case A_TypeGuards.isComponentConstructor(ctor): {\n                found = this.isAllowedComponent(ctor)\n                    || !![...this.allowedComponents]\n                        .find(c => A_CommonHelper.isInheritedFrom(c, ctor));\n\n                break;\n            }\n            // 4) Check if it's an Entity\n            case A_TypeGuards.isEntityConstructor(ctor): {\n                found = this.isAllowedEntity(ctor)\n                    || !![...this.allowedEntities]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n            // 5) Check if it's a Fragment\n            case A_TypeGuards.isFragmentConstructor(ctor): {\n                found = this.isAllowedFragment(ctor)\n                    || !![...this.allowedFragments]\n                        .find(f => A_CommonHelper.isInheritedFrom(f, ctor));\n\n                break;\n            }\n\n            // 6) Check if it's an Error\n            case A_TypeGuards.isErrorConstructor(ctor): {\n                found = this.isAllowedError(ctor)\n                    || !![...this.allowedErrors]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n\n            // 7) Check scope issuer\n            case this.issuer()\n                && (this.issuer()!.constructor === ctor\n                    || A_CommonHelper.isInheritedFrom(this.issuer()!.constructor, ctor\n                    )\n                ): {\n                    found = true;\n                    break;\n                }\n        }\n\n        return found;\n    }\n\n\n    /**\n     * Allows to resolve a specific dependency \n     * \n     * @param dependency \n     * @returns \n     */\n    resolveDependency<T extends A_TYPES__A_DependencyInjectable>(\n        dependency: A_Dependency<T>\n    ): T | Array<T> | undefined {\n\n        let result: Array<T> = [];\n        let targetScope: A_Scope = this.parentOffset(dependency.parent) || this;\n\n        //  first deal with level conditions and \n        switch (true) {\n            // 1) Flat resolution\n            case dependency.flat && !dependency.all: {\n                const resolved = targetScope.resolveFlatOnce<T>(dependency.target || dependency.name);\n                if (resolved)\n                    result = [resolved];\n                break;\n            }\n            case dependency.flat && dependency.all: {\n                result = targetScope.resolveFlatAll<T>(dependency.target || dependency.name);\n                break;\n            }\n            case !dependency.flat && !dependency.all: {\n                const resolved = targetScope.resolveOnce<T>(dependency.target || dependency.name);\n                if (resolved)\n                    result = [resolved];\n                break;\n            }\n            case !dependency.flat && dependency.all: {\n                result = targetScope.resolveAll<T>(dependency.target || dependency.name);\n                break;\n            }\n\n            default:\n                result = [];\n        }\n\n        //  2) create if not found and allowed\n        if (dependency.create\n            && !result.length\n            && A_TypeGuards.isAllowedForDependencyDefaultCreation(dependency.target)\n        ) {\n\n            const newDependency = new dependency.target(...dependency.args);\n\n            targetScope.register(newDependency);\n\n            result.push(newDependency as T);\n        }\n\n        //  3) handle required dependencies\n        if (dependency.require && !result.length) {\n            throw new A_ScopeError(\n                A_ScopeError.ResolutionError,\n                `Dependency ${dependency.name} is required but could not be resolved in scope ${targetScope.name}`\n            );\n        }\n\n\n        // 4) Apply filters\n        if (dependency.query.aseid)\n            //  in this case we should return only one dependency by aseid\n            result = result.filter(dep => A_TypeGuards.hasASEID(dep) && ASEID.compare(dep.aseid, dependency.query.aseid));\n\n        else if (Object.keys(dependency.query).length > 0)\n            result = result\n                .filter(dep => {\n                    const query = dependency.query;\n                    if (!query) return true;\n\n                    return Object.entries(query).every(([key, value]) => {\n                        return (dep as any)[key] === value;\n                    });\n                });\n\n\n        // 5) apply pagination\n\n        const count = dependency.pagination.count;\n        const from = dependency.pagination.from;  // from start or from end\n\n\n\n        const startSliceIndex = from === 'end'\n            ? (count === -1 ? 0 : Math.max(result.length - count, 0))\n            : 0;\n\n        //  end slice should handle -1 for all items\n        const endSliceIndex = from === 'end'\n            ? result.length\n            : (count === -1 ? result.length : Math.min(count, result.length));\n\n        const slice = result.slice(startSliceIndex, endSliceIndex);\n\n        /**\n         * Default behavior is to return single instance if count is 1\n         * \n         * If Directive All (-1) is provided or count > 1, an array is returned\n         * \n         * If no instances found, undefined is returned\n         */\n        return slice.length === 1\n            && count !== -1\n            ? slice[0]\n            : slice.length\n                ? slice\n                : undefined;\n    }\n\n\n    /**\n     * Allows to retrieve the constructor of the component or entity by its name\n     * \n     * [!] Notes:\n     * - In case of search for A-Entity please ensure that provided string corresponds to the static entity property of the class. [!] By default it's the kebab-case of the class name\n     * - In case of search for A_Component please ensure that provided string corresponds to the class name in PascalCase\n     * \n     * @param name \n     * @returns \n     */\n    resolveConstructor<T extends A_Entity>(\n        /**\n         * Provide the entity name or static entity property to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Entity_Constructor<T>\n    resolveConstructor<T extends A_Component>(\n        /**\n         * Provide the component name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Component_Constructor<T>\n    resolveConstructor<T extends A_Fragment>(\n        /**\n         * Provide the fragment name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Fragment_Constructor<T>\n    resolveConstructor<T extends A_TYPES__A_DependencyInjectable>(name: string): A_TYPES__Entity_Constructor<T> | A_TYPES__Component_Constructor<T> | A_TYPES__Fragment_Constructor<T> | undefined\n    resolveConstructor<T extends A_TYPES__A_DependencyInjectable>(name: string): A_TYPES__Entity_Constructor<T> | A_TYPES__Component_Constructor<T> | A_TYPES__Fragment_Constructor<T> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n\n        if (component) return component as A_TYPES__Component_Constructor<T>;\n        else\n        // 1.2) Check components prototypes\n        {\n            const protoComponent = Array.from(this.allowedComponents).find(\n\n                //  it should go rthough prototyopes and check their names to be equal to the provided name\n                c => {\n                    let current = c;\n\n                    while (current) {\n                        if (current.name === name\n                            || current.name === A_FormatterHelper.toPascalCase(name)\n                        ) {\n                            return true;\n                        }\n                        current = Object.getPrototypeOf(current);\n                    }\n\n                    return false;\n\n                }\n            );\n            if (protoComponent) return protoComponent as A_TYPES__Component_Constructor<T>;\n        }\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return entity as A_TYPES__Entity_Constructor<T>;\n        else\n        // 2.2) Check entities prototypes\n        {\n            const protoEntity = Array.from(this.allowedEntities).find(\n                e => A_CommonHelper.isInheritedFrom(e, name as any)\n            );\n            if (protoEntity) return protoEntity as A_TYPES__Entity_Constructor<T>;\n        }\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return fragment as A_TYPES__Fragment_Constructor<T>;\n        else\n        // 3.2) Check fragments prototypes\n        {\n            const protoFragment = Array.from(this.allowedFragments).find(\n                f => A_CommonHelper.isInheritedFrom(f, name as any)\n            );\n            if (protoFragment) return protoFragment as A_TYPES__Fragment_Constructor<T>;\n        }\n\n        // If not found in current scope, check imported scopes\n        for (const importedScope of this._imports) {\n            const importedConstructor = importedScope.resolveConstructor<T>(name);\n            if (importedConstructor) {\n                return importedConstructor;\n            }\n        }\n\n        // Then, finally check parent scope\n        if (!!this._parent) {\n            return this._parent.resolveConstructor(name) as any;\n        }\n\n        return undefined;\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): Array<T> {\n\n        const results: Set<T> = new Set();\n\n        // 1) Resolve all in the current scope\n        const currentResults = this.resolveFlatAll<T>(param1 as any);\n        currentResults.forEach(result => results.add(result));\n\n        // 2) resolve all in the imported scopes\n        this._imports.forEach(importedScope => {\n\n            if (importedScope.has(param1 as any)) {\n                const importedResults = importedScope.resolveFlatAll<T>(param1 as any);\n\n\n                importedResults.forEach(result => results.add(result));\n            }\n        });\n\n        // 3) Resolve all in the parent scope\n        let parentScope = this._parent;\n\n        while (parentScope && parentScope.has(param1 as any)) {\n\n            const parentResults = parentScope.resolveAll<T>(param1 as any);\n            parentResults.forEach(result => results.add(result));\n\n            // Move to the next parent scope\n            parentScope = parentScope._parent;\n        }\n\n\n\n        return Array.from(results);\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlatAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): Array<T> {\n\n        const results: Array<T> = [];\n\n        switch (true) {\n            // 1) if a parameter is a component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                // 1) Check components\n                this.allowedComponents.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolveOnce<T>(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n            // 2) if a parameter is a fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                // 2) Check fragments\n                this.allowedFragments.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolveOnce<T>(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isEntityConstructor(param1): {\n                // 3) Check entities\n                this.entities.forEach(entity => {\n\n                    if (A_CommonHelper.isInheritedFrom(entity.constructor, param1)) {\n                        results.push(entity as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isString(param1): {\n                // 4) Check by name\n                const ctor = this.resolveConstructor(param1);\n                if (!A_TypeGuards.isComponentConstructor(ctor)\n                    && !A_TypeGuards.isEntityConstructor(ctor)\n                    && !A_TypeGuards.isFragmentConstructor(ctor)\n                )\n                    throw new A_ScopeError(\n                        A_ScopeError.ResolutionError,\n                        `Unable to resolve all instances for name: ${param1} in scope ${this.name} as no matching component, entity or fragment constructor found`);\n\n\n                if (ctor) {\n                    const instances = this.resolveAll<T>(ctor as any);\n                    if (instances)\n                        results.push(...instances);\n                }\n                break;\n            }\n\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Invalid parameter provided to resolveAll method: ${param1} in scope ${this.name}`);\n        }\n\n\n        return results;\n    }\n\n\n\n    /**\n     * This method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * @param component \n     * @returns \n     */\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Ctor<T>\n    ): T | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a target dependency to resolve its instance from the scope\n         * \n         * [!] In this case its possible to provide a custom resolution strategy via A_Dependency options\n         */\n        dependency: A_Dependency<T>\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: string\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<T> | A_Dependency<T> | string\n    ): T | Array<T> | undefined {\n\n        const dependency = A_TypeGuards.isDependencyInstance(param1) ?\n            param1 as A_Dependency<T> :\n            new A_Dependency<T>(param1)\n\n        return this.resolveDependency<T>(dependency);\n    }\n\n    /**\n     * This method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * @param component \n     * @returns \n     */\n    resolveOnce<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): T | undefined {\n\n        const value = this.resolveFlatOnce(param1);\n\n        // if not found in the current scope, check imported scopes\n        if (!value) {\n            for (const importedScope of this._imports) {\n                if (importedScope.has(param1 as any)) {\n                    const importedValue = importedScope.resolveFlatOnce<T>(param1 as any);\n                    if (importedValue) {\n                        return importedValue;\n                    }\n                }\n            }\n        }\n\n        //  The idea here that in case when Scope has no exact component we have to resolve it from the _parent\n        //  That means that we should ensure that there's no components that are children of the required component\n        if (!value && !!this.parent) {\n            return this.parent.resolveOnce<T>(param1);\n        }\n\n        return value as T;\n    }\n\n\n    /**\n     * This polymorphic method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable>,\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): T | undefined {\n        return this.resolveFlatOnce(param1) as T;\n    }\n\n\n    /**\n     * Resolves a component, fragment or entity from the scope without checking parent scopes\n     * \n     * @param component \n     * @param instructions \n     */\n    resolveFlatOnce<T extends A_TYPES__A_DependencyInjectable>(\n        component: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): T | undefined {\n\n        let value: T | undefined = undefined;\n\n        const componentName = A_CommonHelper.getComponentName(component);\n\n\n        if (!component || !this.has(component)) {\n            return undefined;\n        }\n\n        switch (true) {\n            case A_TypeGuards.isString(component): {\n                value = this.resolveByName(component) as T;\n                break;\n            }\n            case A_TypeGuards.isConstructorAllowedForScopeAllocation(component): {\n                value = this.resolveIssuer(component) as T;\n                break;\n            }\n            case A_TypeGuards.isScopeConstructor(component): {\n                value = this.resolveScope(component) as T\n                break;\n            }\n            case A_TypeGuards.isEntityConstructor(component): {\n                value = this.resolveEntity(component) as T\n                break;\n            }\n            case A_TypeGuards.isFragmentConstructor(component): {\n                value = this.resolveFragment(component) as T;\n                break;\n            }\n            case A_TypeGuards.isComponentConstructor(component): {\n                value = this.resolveComponent(component) as T;\n                break;\n            }\n            case A_TypeGuards.isErrorConstructor(component): {\n                value = this.resolveError(component) as T;\n                break;\n            }\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Injected Component ${componentName} not found in the scope`\n                );\n        }\n\n        return value\n    }\n\n\n\n    // ==================================================================================================\n    // --------------------------------------------------------------------------------------------------\n    // -------------------------------------INTERNAL RESOLVERS-------------------------------------------\n    // --------------------------------------------------------------------------------------------------\n    // ==================================================================================================\n    /**\n     * This method is used internally to resolve a component, fragment or entity by its constructor name\n     * \n     * [!] Note that this method checks for the component, fragment or entity in the current scope and all parent scopes\n     * [!!] Note: No parent scopes are checked\n     * \n     * @param name  - name of the component, fragment or entity to resolve (constructor name for components and fragments, static entity property for entities, static code property for commands)\n     * @returns \n     */\n    private resolveByName(\n        /**\n         * Provide the name of the component, fragment or entity to resolve\n         */\n        name: string\n    ): _EntityType[number] | InstanceType<_ComponentType[number]> | _FragmentType[number] |\n        InstanceType<_ErrorType[number]> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (component) return this.resolveOnce(component) as InstanceType<_ComponentType[number]>;\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return this.resolveOnce(entity) as InstanceType<_EntityType[number]>;\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return this.resolveOnce(fragment) as _FragmentType[number];\n\n        // 4) Check errors\n        const error = Array.from(this.allowedErrors).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).code === name\n                || (e as any).code === A_FormatterHelper.toKebabCase(name)\n        );\n        if (error) return this.resolveOnce(error) as InstanceType<_ErrorType[number]>;\n\n        return undefined;\n    }\n\n\n    /**\n     * Resolves the issuer of the scope by provided constructor\n     * \n     * [!] Note that this method checks ONLY for the direct issuer of the scope\n     * [!!] No parent scopes are checked\n     * \n     * \n     * @param ctor \n     * @returns \n     */\n    private resolveIssuer(\n        ctor: A_TYPES__ScopeLinkedConstructors\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const issuer = this.issuer();\n\n        if (issuer\n            && (\n                issuer.constructor === ctor\n                || A_CommonHelper.isInheritedFrom(issuer?.constructor, ctor)\n            )) {\n            return issuer!;\n        }\n\n\n        return undefined;\n    }\n\n    /**\n     * This method is used internally to resolve a single entity from the scope based on the provided instructions\n     * \n     * [!] Note that this method can return either a single entity or an array of entities depending on the instructions provided\n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param entity \n     * @param instructions \n     * @returns \n     */\n    private resolveEntity<T extends A_Entity>(\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | Array<T> | undefined {\n\n        /**\n         * 1) In case when no instructions provided, return the first found entity of the provided type\n         * \n         * [!] Note that it returns ONLY ONE entity\n         * [!!] In case when no entity found in the current scope, it tries to resolve it from the parent scope (if exists)\n         */\n\n        return this.entities.find(e => e instanceof entity) as T | undefined;\n\n    }\n    /**\n     * This method is used internally to resolve a single error from the scope\n     * \n     * [!] Note that errors are singleton instances within the scope\n     * [!!] No parent scopes are checked\n     * \n     * @param error \n     * @returns \n     */\n    private resolveError<T extends A_Error>(error: A_TYPES__Error_Constructor<T>): T | undefined {\n\n        return this.errors.find(e => e instanceof error) as T | undefined;\n    }\n    /**\n     * This method is used internally to resolve a single fragment from the scope\n     * \n     * [!] Note that this method checks for the fragment in the current scope and all parent scopes\n     * \n     * @param fragment \n     * @returns \n     */\n    private resolveFragment<T extends A_Fragment>(fragment: A_TYPES__Fragment_Constructor<T>): _FragmentType[number] | undefined {\n        const fragmentInstancePresented = this._fragments.get(fragment);\n\n        switch (true) {\n            case fragmentInstancePresented && this._fragments.has(fragment):\n                return fragmentInstancePresented;\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !fragmentInstancePresented && Array.from(this._allowedFragments).some(el => A_CommonHelper.isInheritedFrom(el, fragment)): {\n                const found = Array.from(this._allowedFragments).find(el => A_CommonHelper.isInheritedFrom(el, fragment))!;\n\n                return this.resolveFragment(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n    /**\n     *  This method is used internally to resolve a single scope from the current scope\n     * \n     * @param scope \n     * @returns \n     */\n    private resolveScope(scope: A_TYPES__Scope_Constructor): A_Scope {\n        return this;\n    }\n\n    /**\n     * This method is used internally to resolve a single component from the scope\n     * \n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param component \n     * @returns \n     */\n    private resolveComponent<T extends A_Component>(component: A_TYPES__Component_Constructor<T>): InstanceType<_ComponentType[number]> | undefined {\n\n\n        switch (true) {\n            // 1) In case when the component is available and exists in the scope\n            case this.allowedComponents.has(component) && this._components.has(component): {\n                return this._components.get(component)!;\n            }\n\n            // 2) In case the component available but does NOT exist in the scope\n            case this.allowedComponents.has(component) && !this._components.has(component): {\n                const componentMeta = A_Context.meta(component)\n\n                const argsMeta = componentMeta.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n                const resolvedArgs = (argsMeta?.get('constructor') || [])\n                    .map(dependency => this.resolve(dependency));\n\n\n                const newComponent = new component(...resolvedArgs)\n\n                this.register(newComponent);\n\n                return this._components.get(component)!;\n            }\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !this.allowedComponents.has(component) && Array.from(this.allowedComponents).some(el => A_CommonHelper.isInheritedFrom(el, component)): {\n                const found = Array.from(this.allowedComponents).find(el => A_CommonHelper.isInheritedFrom(el, component))!;\n\n                return this.resolveComponent(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n\n\n    /**\n     * This method is used to register the component in the scope\n     * \n     * @param fragment \n     */\n    register<T extends A_Component>(\n        /**\n         * Provide a component constructor to register it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    register<T extends A_Component>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        component: T\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error constructor to register it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error instance to register it in the scope\n         */\n        error: T\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a fragment instance to register it in the scope\n         */\n        fragment: T\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to register it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        entity: T\n    ): void\n    register<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        entity: T\n    ): void\n    register<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        param1: T\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                if (!this.allowedComponents.has(param1.constructor as _ComponentType[number]))\n                    this.allowedComponents.add(param1.constructor as _ComponentType[number]);\n\n                this._components.set(\n                    param1.constructor as _ComponentType[number],\n                    param1 as InstanceType<_ComponentType[number]>\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1) && !this._entities.has(param1.aseid.toString()): {\n\n                if (!this.allowedEntities.has(param1.constructor as _EntityType[number]))\n                    this.allowedEntities.add(param1.constructor as _EntityType[number]);\n\n                this._entities.set(param1.aseid.toString(), param1 as InstanceType<_EntityType[number]>);\n                A_Context.register(this, param1);\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n\n                if (!this.allowedFragments.has(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>))\n                    this.allowedFragments.add(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n\n                this._fragments.set(\n                    param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>,\n                    param1 as _FragmentType[number]\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n                if (!this.allowedErrors.has(param1.constructor as _ErrorType[number]))\n                    this.allowedErrors.add(param1.constructor as _ErrorType[number]);\n\n                this._errors.set(\n                    (param1 as any).code,\n                    param1 as InstanceType<_ErrorType[number]>\n                );\n\n                A_Context.register(this, (param1 as any));\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                if (!this.allowedComponents.has(param1))\n                    this.allowedComponents.add(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                if (!this.allowedFragments.has(param1))\n                    this.allowedFragments.add(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                if (!this.allowedEntities.has(param1))\n                    this.allowedEntities.add(param1 as _EntityType[number]);\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                if (!this.allowedErrors.has(param1))\n                    this.allowedErrors.add(param1 as _ErrorType[number]);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                if (param1 instanceof A_Entity)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Entity with ASEID ${param1.aseid.toString()} is already registered in the scope ${this.name}`\n                    );\n                else if (param1 instanceof A_Fragment)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Fragment ${param1.constructor.name} is already registered in the scope ${this.name}`\n                    );\n                else {\n                    const componentName = A_CommonHelper.getComponentName(param1);\n\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Cannot register ${componentName} in the scope ${this.name}`\n                    );\n                }\n        }\n    }\n\n\n    /**\n     * This method is used to deregister the component from the scope\n     * \n     * @param fragment \n     */\n    deregister<T extends A_Component>(\n        /**\n         * Provide a component constructor to deregister it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        component: A_Component\n    ): void\n    deregister<T extends A_Error>(\n        /**\n         * Provide an error constructor to deregister it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an error instance to deregister it in the scope\n         */\n        error: A_Error\n    ): void\n    deregister<T extends A_Fragment>(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a fragment instance to deregister it in the scope\n         */\n        fragment: A_Fragment\n    ): void\n    deregister<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to deregister it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an entity instance to deregister it in the scope\n         */\n        entity: A_Entity\n    ): void\n\n    deregister(\n        param1: unknown\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                this._components.delete(param1.constructor as _ComponentType[number]);\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as _ComponentType[number];\n\n                const hasComponent = this._components.has(ctor);\n                if (!hasComponent) {\n                    this.allowedComponents.delete(ctor);\n                }\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1): {\n\n                this._entities.delete(param1.aseid.toString());\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as _EntityType[number];\n\n                const hasEntity = Array.from(this._entities.values()).some(entity => entity instanceof ctor);\n                if (!hasEntity) {\n                    this.allowedEntities.delete(ctor);\n                }\n\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n                this._fragments.delete(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>;\n\n                const hasFragment = Array.from(this._fragments.values()).some(fragment => fragment instanceof ctor);\n                if (!hasFragment) {\n                    this.allowedFragments.delete(ctor);\n                }\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n\n                this._errors.delete((param1 as any).code);\n                A_Context.deregister((param1 as any));\n\n                const ctor = (param1 as any).constructor as _ErrorType[number];\n\n                const hasError = Array.from(this._errors.values()).some(error => error instanceof ctor);\n                if (!hasError) {\n                    this.allowedErrors.delete(ctor);\n                }\n\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                this.allowedComponents.delete(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                this.allowedFragments.delete(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                // and then deregister all instances of this fragment\n                Array.from(this._fragments.entries()).forEach(([ctor, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        this._fragments.delete(ctor);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                this.allowedEntities.delete(param1 as _EntityType[number]);\n                //  and then deregister all instances of this entity\n                Array.from(this._entities.entries()).forEach(([aseid, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(instance.constructor, param1)) {\n                        this._entities.delete(aseid);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                this.allowedErrors.delete(param1 as _ErrorType[number]);\n                // and then deregister all instances of this error\n                Array.from(this._errors.entries()).forEach(([code, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(instance.constructor, param1)) {\n                        this._errors.delete(code);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                const componentName = A_CommonHelper.getComponentName(param1);\n\n                throw new A_ScopeError(\n                    A_ScopeError.DeregistrationError,\n                    `Cannot deregister ${componentName} from the scope ${this.name}`\n                );\n        }\n\n    }\n\n    /**\n     * This method is useful when you want to serialize the scope to JSON\n     * \n     * [!] Note this is not a deep serialization, only the fragments are serialized\n     * [!] Fragments are a storage for information which is relevant to the scope\n     * \n     * @returns \n     */\n    toJSON(): Record<string, any> {\n        return this.fragments\n            .reduce((acc, fragment) => {\n\n                const serialized = fragment.toJSON()\n\n                return {\n                    ...acc,\n                    [serialized.name]: serialized\n                }\n            }, {});\n    }\n\n\n\n    //==========================================================================\n    // --------------------Scope Type Check Helpers---------------------------\n    //==========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Component and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedComponent(ctor: unknown): ctor is _ComponentType[number] {\n        return A_TypeGuards.isComponentConstructor(ctor) && this.allowedComponents.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedEntity(ctor: unknown): ctor is A_TYPES__Entity_Constructor<_EntityType[number]> {\n        return A_TypeGuards.isEntityConstructor(ctor) && this.allowedEntities.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedFragment(ctor: unknown): ctor is A_TYPES__Fragment_Constructor<_FragmentType[number]> {\n        return A_TypeGuards.isFragmentConstructor(ctor) && this.allowedFragments.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Error and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedError(ctor: unknown): ctor is A_TYPES__Error_Constructor<_ErrorType[number]> {\n        return A_TypeGuards.isErrorConstructor(ctor) && this.allowedErrors.has(ctor);\n    }\n\n\n\n\n    // ==========================================================================\n    // --------------------DEBUG & Helpers Methods--------------------------------\n    // ===========================================================================\n    /**\n     * This method is used to check if the scope is inherited from another scope\n     * \n     * @param scope \n     * @returns \n     */\n    isInheritedFrom(scope: A_Scope): boolean {\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            if (current === scope) {\n                return true;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to check circular inheritance\n     * Should return a full sequence of inheritance for logging purposes\n     * \n     * @param scope \n     * @returns \n     */\n    checkCircularInheritance(scope: A_Scope): Array<string> | false {\n        const inheritanceChain: Array<string> = [];\n        let current: A_Scope | undefined = this._parent;\n\n        while (current) {\n            inheritanceChain.push(current.name);\n            if (current === scope) {\n                return inheritanceChain;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to print the inheritance chain of the scope\n     */\n    printInheritanceChain(): void {\n        const chain: Array<string> = [];\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            chain.push(current.name);\n            current = current._parent;\n        }\n\n        console.log(chain.join(' -> '));\n    }\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_ScopeError extends A_Error {\n\n\n    static readonly InitializationError = 'A-Scope Initialization Error';\n\n    static readonly ConstructorError = 'Unable to construct A-Scope instance';\n\n    static readonly ResolutionError = 'A-Scope Resolution Error';\n\n    static readonly RegistrationError = 'A-Scope Registration Error';\n\n    static readonly CircularInheritanceError = 'A-Scope Circular Inheritance Error';\n\n    static readonly CircularImportError = 'A-Scope Circular Import Error';\n\n    static readonly DeregistrationError = 'A-Scope Deregistration Error';\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_ContextError extends A_Error {\n\n\n    static NotAllowedForScopeAllocationError = 'Component is not allowed for scope allocation';\n\n    static ComponentAlreadyHasScopeAllocatedError = 'Component already has scope allocated';\n\n    static InvalidMetaParameterError = 'Invalid parameter provided to get meta';\n\n    static InvalidScopeParameterError = 'Invalid parameter provided to get scope';\n\n    static ScopeNotFoundError = 'Scope not found';\n\n    static InvalidFeatureParameterError = 'Invalid parameter provided to get feature';\n\n    static InvalidFeatureDefinitionParameterError = 'Invalid parameter provided to define feature';\n\n    static InvalidFeatureTemplateParameterError = 'Invalid parameter provided to get feature template';\n\n    static InvalidFeatureExtensionParameterError = 'Invalid parameter provided to extend feature';\n\n\n    static InvalidAbstractionParameterError = 'Invalid parameter provided to get abstraction';\n\n    static InvalidAbstractionDefinitionParameterError = 'Invalid parameter provided to define abstraction';\n\n    static InvalidAbstractionTemplateParameterError = 'Invalid parameter provided to get abstraction template';\n\n    static InvalidAbstractionExtensionParameterError = 'Invalid parameter provided to extend abstraction';\n\n    static InvalidInjectionParameterError = 'Invalid parameter provided to get injections';\n\n    static InvalidExtensionParameterError = 'Invalid parameter provided to get extensions';\n\n\n    static InvalidRegisterParameterError = 'Invalid parameter provided to register component';\n\n\n    static InvalidComponentParameterError = 'Invalid component provided';\n\n    static ComponentNotRegisteredError = 'Component not registered in the context';\n\n    static InvalidDeregisterParameterError = 'Invalid parameter provided to deregister component';\n}","\nimport {\n    A_Scope,\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeConfig,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES_ScopeDependentComponents\n} from \"@adaas/a-concept/a-scope\";\nimport {\n    A_Meta,\n    A_TYPES__MetaLinkedComponentConstructors,\n    A_TYPES__MetaLinkedComponents\n} from \"@adaas/a-concept/a-meta\";\nimport type {\n    A_Feature,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureDefineDecoratorMeta\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_TYPES__Component_Constructor,\n    A_ComponentMeta\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Container,\n    A_TYPES__ContainerMetaKey,\n    A_TYPES__Container_Constructor,\n    A_ContainerMeta\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Entity,\n    A_TYPES__EntityMetaKey,\n    A_TYPES__Entity_Constructor,\n    A_EntityMeta\n} from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__A_StageStep } from \"@adaas/a-concept/a-stage\";\nimport { A_TYPES__ContextEnvironment } from \"./A-Context.types\";\nimport { A_TypeGuards } from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FormatterHelper } from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_CommonHelper } from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_ContextError } from \"./A-Context.error\";\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport { A_TYPES__ConceptAbstractions } from \"@adaas/a-concept/a-concept\";\nimport { A_Dependency } from \"@adaas/a-concept/a-dependency\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_CONCEPT_ENV } from \"@adaas/a-concept/env\";\n\n\n\nexport class A_Context {\n    // ====================================================================================================\n    // ================================ STATIC PROPERTIES =================================================\n    // ====================================================================================================\n    /**\n     * Default name of the application from environment variable A_CONCEPT_NAME\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept() {\n        return A_CONCEPT_ENV.A_CONCEPT_NAME || 'a-concept';\n    }\n    /**\n     * Root scope of the application from environment variable A_CONCEPT_ROOT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'root'\n     */\n    static get root(): A_Scope {\n        return this.getInstance()._root;\n    }\n    /**\n     * Environment the application is running in.\n     * Can be either 'server' or 'browser'.\n     * [!] Determined by environment variable A_CONCEPT_RUNTIME_ENVIRONMENT that comes from the build tool or is set manually in the environment.\n     */\n    static get environment(): A_TYPES__ContextEnvironment {\n        return A_CONCEPT_ENV.A_CONCEPT_RUNTIME_ENVIRONMENT\n    }\n\n    /**\n     * Singleton instance of the Context\n     */\n    private static _instance: A_Context;\n    // ====================================================================================================\n    // ================================ INTERNAL REGISTRY =================================================\n    // ====================================================================================================\n    /**\n     * Root Scope of the Concept and Environment\n     *\n     * Root scope is the top-level scope that all other scopes inherit from.\n     * It stores global configurations and settings and ALL SHAREABLE RESOURCES.\n     * \n     * [!] Root scope is created automatically when the Context is initialized.\n     * [!] Root scope name can be configured using environment variable A_CONCEPT_ROOT_SCOPE\n     */\n    private _root!: A_Scope\n    /**\n     * A registry that keeps track of scopes for all components (Containers, Features, Commands) \n     * Which can issue a scope allocation.\n     */\n    protected _registry: WeakMap<A_TYPES__ScopeLinkedComponents, A_Scope> = new WeakMap();\n    /**\n     * This is a registry that stores an issuer of each scope allocation.\n     * It helps to track which component (Container, Feature, Command) allocated a specific scope.\n     */\n    protected _scopeIssuers: WeakMap<A_Scope, A_TYPES__ScopeLinkedComponents> = new WeakMap();\n    /**\n     * Stores a context associated with a specific component that depends on a scope.\n     * uses for quick retrieval of the scope for the component.\n     */\n    protected _scopeStorage: WeakMap<A_TYPES_ScopeDependentComponents, A_Scope> = new WeakMap();\n    /**\n     * Stores meta information for different component types by their constructors.\n     * Meta provides to store extra information about the class behavior and configuration.\n     */\n    protected _metaStorage: Map<A_TYPES__MetaLinkedComponentConstructors, A_Meta> = new Map();\n\n\n\n\n    protected _globals = new Map<string, any>();\n\n    /**\n     * Private constructor to enforce singleton pattern.\n     * \n     * [!] This class should not be instantiated directly. Use A_Context.getInstance() instead.\n     */\n    private constructor() {\n        const name = String(A_CONCEPT_ENV.A_CONCEPT_ROOT_SCOPE) || 'root';\n\n        this._root = new A_Scope({ name });\n    }\n\n\n\n    /**\n     * Get the instance of the Namespace Provider.\n     * \n     * If the instance does not exist, it will be created.\n     * \n     * @returns \n     */\n    static getInstance() {\n        if (!A_Context._instance) {\n            A_Context._instance = new A_Context();\n        }\n\n        return A_Context._instance;\n    }\n\n\n\n    /**\n     * Register method allows to register a component with a specific scope in the context.\n     * \n     * @param component - Component to register with a specific scope. Can be either A_Container, A_Feature.\n     * @param scope - Scope to associate the component with.\n     * @returns \n     */\n    static register(\n        /**\n         * Provide the scope that will be associated with the component.\n         */\n        scope: A_Scope,\n        /**\n         * Provide a component that needs to be registered with a specific scope.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Component cannot be null or undefined.`);\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Scope cannot be null or undefined.`);\n\n        if (!this.isAllowedToBeRegistered(component)) throw new A_ContextError(\n            A_ContextError.NotAllowedForScopeAllocationError,\n            `Component ${componentName} is not allowed for scope allocation.`);\n\n        instance._scopeStorage.set(component, scope);\n\n        return scope;\n    }\n\n    /**\n     * Deregister method allows to deregister a component from the context.\n     * \n     * @param component - Component to deregister from the context.\n     */\n    static deregister(\n        /**\n         * Provide a component that needs to be deregistered from the context.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n    ): void {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidDeregisterParameterError,\n            `Unable to deregister component. Component cannot be null or undefined.`);\n\n        if (!instance._scopeStorage.has(component)) throw new A_ContextError(\n            A_ContextError.ComponentNotRegisteredError,\n            `Unable to deregister component. Component ${componentName} is not registered.`);\n\n        instance._scopeStorage.delete(component);\n    }\n\n    /**\n     * Allocate method instantiates a new scope for the given component and registers it in the context.\n     * It bounds the component (Container, Feature) to a new scope that can be configured and used independently.\n     * \n     * \n     * @param component - Component to allocate the scope for. Can be either A_Container, A_Feature.\n     * @param importing  - Configuration of the scope that will be created for the component.\n     */\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide the scope that will be used as a base for the new scope.\n         */\n        importing: A_Scope\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide configuration for the scope that will be created for the component.\n         */\n        config: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig>\n    ): A_Scope\n    static allocate(\n        component: A_TYPES__ScopeLinkedComponents,\n        importing?: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig> | A_Scope\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // ---------------------------------------------------------------------\n        // ----------------------Input Validation-------------------------------\n        // ---------------------------------------------------------------------\n        // 1) check if component is valid\n        if (!this.isAllowedForScopeAllocation(component))\n            throw new A_ContextError(A_ContextError.NotAllowedForScopeAllocationError, `Component of type ${componentName} is not allowed for scope allocation. Only A_Container, A_Feature are allowed.`);\n        const instance = this.getInstance();\n\n        // 2) check if component already has a scope allocated\n        if (instance._registry.has(component))\n            throw new A_ContextError(A_ContextError.ComponentAlreadyHasScopeAllocatedError, `Component ${componentName} already has a scope allocated.`);\n\n\n        // 3) Create a new scope for the component\n        const newScope = A_TypeGuards.isScopeInstance(importing)\n            ? importing\n            : new A_Scope(importing || {\n                name: componentName + '-scope'\n            }, importing);\n\n        // 4) Make sure that the new scope inherits from the root scope\n        if (!newScope.isInheritedFrom(A_Context.root))\n            newScope.inherit(A_Context.root);\n\n        // 5) Register the component in the appropriate storage\n        instance._registry.set(component, newScope);\n        // Also register the issuer of the scope for faster tracking\n        instance._scopeIssuers.set(newScope, component);\n\n        // 6) Return the newly created scope\n        return newScope;\n    }\n\n    /**\n     * Deallocate method removes the scope allocation for the given component from the context.\n     * \n     * @param component \n     * @returns \n     */\n    static deallocate(\n        /**\n         * A Scope that needs to be deallocated.\n         */\n        scope: A_Scope,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        param1: A_TYPES__ScopeLinkedComponents | A_Scope,\n    ) {\n        const instance = this.getInstance();\n\n        const scope = A_TypeGuards.isScopeInstance(param1)\n            ? param1\n            : instance._registry.get(param1);\n\n        if (!scope) return;\n\n        const component = A_TypeGuards.isComponentInstance(param1)\n            ? param1\n            : this.issuer(scope);\n\n        if (component)\n            instance._registry.delete(component);\n        if (scope)\n            instance._scopeIssuers.delete(scope);\n    }\n\n\n\n    /**\n      * Get or Create Meta for the specific class or instance.\n      * This method will return the existing meta if it exists, or create a new one if it doesn't.\n      * \n      * Meta object contains custom metadata based on the class type.\n      * \n      * @param container \n      */\n    static meta<T extends A_ContainerMeta>(\n        /**\n         * Get meta for the specific container class by constructor.\n         */\n        container: A_TYPES__Container_Constructor,\n    ): T\n    static meta<T extends A_ContainerMeta, S extends A_Container>(\n        /**\n         * Get meta for the specific container instance.\n         */\n        container: S,\n    ): T\n    static meta<T extends A_EntityMeta>(\n        /**\n         * Get meta for the specific entity class by constructor.\n         */\n        entity: A_TYPES__Entity_Constructor,\n    ): T\n    static meta<T extends A_EntityMeta>(\n        /**\n         * Get meta for the specific entity instance.\n         */\n        entity: A_Entity,\n    ): T\n    static meta<T extends A_ComponentMeta>(\n        /**\n         * Get meta for the specific component class by constructor.\n         */\n        component: A_TYPES__Component_Constructor,\n    ): T\n    static meta<T extends A_ComponentMeta, S extends A_Component>(\n        /**\n         * Get meta for the specific component instance.\n         */\n        component: S,\n    ): T\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific component class by constructor.\n         */\n        fragment: A_TYPES__Fragment_Constructor,\n    ): T\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific component instance.\n         */\n        fragment: A_Fragment,\n    ): T\n    static meta<T extends A_ComponentMeta>(\n        /**\n         * Get meta for the specific component by its name.\n         */\n        component: string,\n    ): T\n    static meta(\n        /**\n         * Get meta for the specific meta linked component (class or instance).\n         */\n        target: A_TYPES__MetaLinkedComponentConstructors | A_TYPES__MetaLinkedComponents,\n    ): A_ComponentMeta\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific class or instance\n         */\n        constructor: A_TYPES__Ctor<any>\n    ): T\n    static meta<T extends Record<string, any>>(\n        /**\n         * Get meta for the specific class or instance\n         */\n        constructor: A_TYPES__Ctor<any>\n    ): A_Meta<T>\n\n    static meta<T extends Record<string, any>>(\n        param1: A_TYPES__MetaLinkedComponentConstructors\n            | A_TYPES__MetaLinkedComponents\n            | string\n    ): A_Meta<T> {\n\n        // Get the component name for error messages\n        const componentName = A_CommonHelper.getComponentName(param1);\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for meta storage\n        if (!(\n            this.isAllowedForMeta(param1)\n            || this.isAllowedForMetaConstructor(param1)\n            || A_TypeGuards.isString(param1)\n            || A_TypeGuards.isFunction(param1\n            ))\n        ) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component of type ${componentName} is not allowed for meta storage. Only A_Container, A_Component and A_Entity are allowed.`);\n\n        let property: A_TYPES__MetaLinkedComponentConstructors;\n        let metaType: typeof A_Meta<T> | typeof A_ContainerMeta | typeof A_ComponentMeta | typeof A_EntityMeta\n\n        switch (true) {\n            // 1) If param1 is instance of A_Container\n            case A_TypeGuards.isContainerInstance(param1): {\n                property = param1.constructor as A_TYPES__Container_Constructor;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 2) If param1 is class of A_Container\n            case A_TypeGuards.isContainerConstructor(param1): {\n                property = param1 as typeof A_Container;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 3) If param1 is instance of A_Component\n            case A_TypeGuards.isComponentInstance(param1): {\n                property = param1.constructor as A_TYPES__Component_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 4) If param1 is class of A_Component\n            case A_TypeGuards.isComponentConstructor(param1): {\n                property = param1 as typeof A_Component;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 5) If param1 is instance of A_Entity\n            case A_TypeGuards.isEntityInstance(param1): {\n                property = param1.constructor as A_TYPES__Entity_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 6) If param1 is class of A_Entity\n            case A_TypeGuards.isEntityConstructor(param1): {\n                property = param1;\n                metaType = A_EntityMeta;\n\n                break;\n            }\n            // 7) If param1 is instance of A_Fragment\n            case A_TypeGuards.isFragmentInstance(param1): {\n                property = param1.constructor as A_TYPES__Fragment_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 8) If param1 is class of A_Fragment\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                property = param1;\n                metaType = A_EntityMeta;\n\n                break;\n            }\n            // 9) If param1 is string then we need to find the component by its name\n            case typeof param1 === 'string': {\n                const found = Array.from(instance._metaStorage)\n                    .find(([c]) => c.name === param1\n                        || c.name === A_FormatterHelper.toKebabCase(param1)\n                        || c.name === A_FormatterHelper.toPascalCase(param1)\n                    )!;\n                if (!(found && found.length))\n                    throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component with name ${param1} not found in the meta storage.`);\n\n                property = found[0];\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 10) If param1 is any other class or function\n            default: {\n                property = param1;\n                metaType = A_Meta;\n\n                break;\n            }\n        }\n\n        // Check if the meta already exists for the property, if not create a new one\n        if (!instance._metaStorage.has(property)) {\n\n            let inheritedMeta: A_Meta<any> | undefined = undefined;\n            let currentProperty: any = property;\n\n            // go up to the prototype chain and find if there is any meta to inherit from\n            while (!inheritedMeta) {\n                const parent = Object.getPrototypeOf(currentProperty);\n\n                if (!parent) {\n                    break;\n                }\n                inheritedMeta = instance._metaStorage.get(parent);\n                currentProperty = parent;\n            }\n\n            if (!inheritedMeta)\n                inheritedMeta = new metaType();\n\n            instance._metaStorage.set(property, new metaType().from(inheritedMeta as any));\n        }\n\n        // Return the meta for the property\n        return instance._metaStorage.get(property)!;\n    }\n\n\n\n    /**\n     * Allows to set meta for the specific class or instance.\n     * \n     * @param param1 \n     * @param meta \n     */\n    static setMeta<T extends A_ContainerMeta, S extends A_Container>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_EntityMeta, S extends A_Entity>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_ComponentMeta, S extends A_Component>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_Meta>(\n        param1: new (...args: any[]) => any,\n        meta: T\n    )\n    static setMeta<T extends A_Meta>(\n        param1: A_TYPES__MetaLinkedComponentConstructors | A_TYPES__MetaLinkedComponents,\n        meta: T\n    ) {\n        const instance = A_Context.getInstance();\n\n        const existingMeta = A_Context.meta(param1);\n\n        const constructor = typeof param1 === 'function'\n            ? param1\n            : param1.constructor as A_TYPES__MetaLinkedComponentConstructors;\n\n        instance._metaStorage.set(constructor, existingMeta ? meta.from(existingMeta) : meta);\n    }\n\n\n\n\n    /**\n     * \n     * This method allows to get the issuer of a specific scope.\n     * \n     * @param scope - Scope to get the issuer for.\n     * @returns - Component that issued the scope.\n     */\n    static issuer(\n        /**\n         * Provide the scope to get its issuer.\n         */\n        scope: A_Scope\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const instance = this.getInstance();\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidComponentParameterError,\n            `Invalid parameter provided to get scope issuer. Parameter cannot be null or undefined.`\n        );\n\n        // if (!instance._scopeIssuers.has(scope)) throw new A_ContextError(\n        //     A_ContextError.ScopeNotFoundError,\n        //     `Invalid parameter provided to get scope issuer. Provided scope does not have an issuer registered.`\n        // );\n\n        return instance._scopeIssuers.get(scope)!;\n    }\n\n\n\n    /**\n     * Get the scope of the specific class or instance.\n     * \n     * Every execution in Concept has its own scope.\n     * \n     * This method will return the scope of the specific class or instance.\n     * \n     * @param entity \n     */\n    static scope<T extends A_Entity>(\n        /**\n         * Provide an entity to get its scope.\n         */\n        entity: T\n    ): A_Scope\n    static scope<T extends A_Component>(\n        /**\n         * Provide a component to get its scope.\n         */\n        component: T\n    ): A_Scope\n    static scope<T extends A_Container>(\n        /**\n         * Provide a container to get its scope.\n         */\n        container: T\n    ): A_Scope\n    static scope<T extends A_Feature>(\n        /**\n         * Provide a feature to get its scope.\n         */\n        feature: T\n    ): A_Scope\n    static scope<T extends A_Fragment>(\n        /**\n         * Provide a fragment to get its scope.\n         */\n        fragment: T\n    ): A_Scope\n    static scope<T extends A_TYPES__ScopeLinkedComponents | A_TYPES_ScopeDependentComponents>(\n        param1: T\n    ): A_Scope {\n\n        // for error messages\n        const name = (param1 as any)?.constructor?.name || String(param1);\n\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        // Input validation\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for scope allocation\n        if (!this.isAllowedForScopeAllocation(param1)\n            && !this.isAllowedToBeRegistered(param1)\n        )\n            throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed for scope allocation.`);\n\n        switch (true) {\n\n\n            case this.isAllowedToBeRegistered(param1):\n\n                // Check if the parameter has a scope registered\n                if (!instance._scopeStorage.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope registered. Make sure to register the component using A_Context.register() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed to be registered, return the scope from the storage\n                return instance._scopeStorage.get(param1)!;\n\n            case this.isAllowedForScopeAllocation(param1):\n\n                // Check if the parameter has a scope allocated\n                if (!instance._registry.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope allocated. Make sure to allocate a scope using A_Context.allocate() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed for scope allocation, return the scope\n                return instance._registry.get(param1)!;\n            default:\n                throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed to be registered.`);\n        }\n    }\n\n\n    // ==========================================================================================================\n    // ================================== FEATURE MANAGEMENT ====================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a template of the feature that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the feature.\n     * \n     * @param name \n     */\n    static featureTemplate(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope = this.scope(component)\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base feature definition from the component\n            ...this.featureDefinition(name, component),\n            // 2) Get all extensions for the feature from other components in the scope\n            ...this.featureExtensions(name, component, scope)\n        ];\n\n        return steps;\n    }\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns all extensions for the specific feature in the specific component within the provided scope.\n     * Scope dictates which components are active and can provide extensions for the feature.\n     * \n     * [!] This method only returns extensions, not the base feature definition.\n     * \n     * @param scope \n     * @returns \n     */\n    static featureExtensions(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope\n    ): Array<A_TYPES__A_StageStep> {\n\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n\n        const callNames = A_CommonHelper.getClassInheritanceChain(component)\n            .filter(c => c !== A_Component && c !== A_Container && c !== A_Entity)\n            .map(c => `${c.name}.${name}`);\n\n        // const callNames = [`${A_CommonHelper.getComponentName(component)}.${name}`];\n        // const callNames = [`BaseComponent.testFeature`];\n\n        const steps: Map<string, A_TYPES__A_StageStep> = new Map();\n\n        const allowedComponents: Set<A_TYPES__MetaLinkedComponentConstructors> = new Set();\n\n        for (const callName of callNames) {\n            // We need to get all components that has extensions for the feature in component\n            for (const [cmp, meta] of instance._metaStorage) {\n                // Just try to make sure that component not only Indexed but also presented in scope\n                if (scope.has(cmp) && (\n                    A_TypeGuards.isComponentMetaInstance(meta)\n                    ||\n                    A_TypeGuards.isContainerMetaInstance(meta)\n                )) {\n                    allowedComponents.add(cmp);\n                    // Get all extensions for the feature\n                    meta\n                        .extensions(callName)\n                        .forEach((declaration) => {\n                            const inherited = Array.from(allowedComponents).reverse().find(c => A_CommonHelper.isInheritedFrom(cmp, c) && c !== cmp);\n\n                            if (inherited) {\n                                steps.delete(`${A_CommonHelper.getComponentName(inherited)}.${declaration.handler}`);\n                            }\n\n                            steps.set(`${A_CommonHelper.getComponentName(cmp)}.${declaration.handler}`, {\n                                dependency: new A_Dependency(cmp),\n                                ...declaration\n                            });\n                        });\n                }\n            }\n        }\n\n        return instance.filterToMostDerived(scope, Array.from(steps.values()));\n    }\n\n\n    /**\n     * method helps to filter steps in a way that only the most derived classes are kept.\n     * \n     * @param scope \n     * @param items \n     * @returns \n     */\n    private filterToMostDerived(\n        scope: A_Scope,\n        items: A_TYPES__A_StageStep[]): Array<A_TYPES__A_StageStep> {\n        return items.filter(item => {\n            // const currentClass = scope.resolveConstructor(item.dependency.name)\n            const currentClass = scope.resolveConstructor(item.dependency.name)\n\n            // Check if this class is parent of any other in the list\n            const isParentOfAnother = items.some(other => {\n                if (other === item) return false;\n\n                const otherClass = scope.resolveConstructor(other.dependency.name);\n\n                if (!currentClass || !otherClass) return false;\n\n                return currentClass.prototype.isPrototypeOf(otherClass.prototype);\n            });\n\n            // Keep only classes that are not parent of any other\n            return !isParentOfAnother;\n        });\n    }\n\n\n    /**\n     * This method returns the feature template definition without any extensions.\n     * It can be used to retrieve the base template for a feature before any modifications are applied.\n     * \n     * [!] This method does not consider extensions from other components.\n     * \n     * @param feature \n     * @param component \n     * @returns \n     */\n    static featureDefinition(\n        /**\n         * Name of the feature to get the template for.\n         * Regular expressions are also supported to match multiple features.\n         */\n        feature: string | RegExp,\n        /**\n         * Component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        let metaKey;\n\n        if (!feature)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n        if (!component)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n\n\n        switch (true) {\n            case component instanceof A_Entity:\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case component instanceof A_Container:\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case component instanceof A_Component:\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n\n            default:\n                throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `A-Feature cannot be defined on the ${component} level`);\n        }\n\n        const featureDefinition: A_TYPES__FeatureDefineDecoratorMeta | undefined = this.meta(component)\n            ?.get(metaKey)\n            ?.get(feature);\n\n        return [\n            ...(featureDefinition?.template || [])\n        ];\n    }\n\n    // ==========================================================================================================\n    // ================================== ABSTRACTION MANAGEMENT =================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a definition of the abstraction that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the abstraction.\n     * \n     * @param abstraction \n     */\n    static abstractionTemplate(\n        /**\n         * Provide the abstraction stage to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = (A_CommonHelper.getComponentName(component));\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`);\n\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidAbstractionTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base abstraction definition from the component\n            // [!] No abstraction Definitions -> They are limited to Concept Abstractions ONLY\n            // ...this.abstractionDefinition(abstraction, component),\n\n            // 2) Get all extensions for the abstraction from other components in the scope\n            ...this.abstractionExtensions(abstraction, component)\n        ];\n\n        return steps;\n    }\n\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n\n    static abstractionExtensions(\n        /**\n         * Provide the abstraction name to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`\n        );\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`\n        );\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError\n                (A_ContextError.InvalidAbstractionExtensionParameterError,\n                    `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`\n                );\n\n        const steps: Map<string, A_TYPES__A_StageStep> = new Map();\n\n        const scope = this.scope(component);\n\n        // We need to get all components that has extensions for the feature in component\n        const allowedComponents: Set<A_TYPES__MetaLinkedComponentConstructors> = new Set();\n\n        for (const [cmp, meta] of instance._metaStorage) {\n            // Just try to make sure that component not only Indexed but also presented in scope\n            if (scope.has(cmp) && (\n                A_TypeGuards.isComponentMetaInstance(meta)\n                || A_TypeGuards.isContainerMetaInstance(meta)\n            )) {\n                allowedComponents.add(cmp);\n                // Get all extensions for the feature\n                meta\n                    .abstractions(abstraction)\n                    .forEach((declaration) => {\n                        const inherited = Array.from(allowedComponents).reverse().find(c => A_CommonHelper.isInheritedFrom(cmp, c) && c !== cmp);\n\n                        if (inherited) {\n                            steps.delete(`${A_CommonHelper.getComponentName(inherited)}.${declaration.handler}`);\n                        }\n\n                        steps.set(`${A_CommonHelper.getComponentName(cmp)}.${declaration.handler}`, {\n                            dependency: new A_Dependency(cmp),\n                            ...declaration\n                        });\n                    });\n            }\n        }\n\n        return instance.filterToMostDerived(scope, Array.from(steps.values()));\n    }\n\n\n    /**\n     * Resets the Context to its initial state.\n     */\n    static reset() {\n        const instance = A_Context.getInstance();\n\n        instance._registry = new WeakMap();\n\n        const name = String(A_CONCEPT_ENV.A_CONCEPT_ROOT_SCOPE) || 'root';\n\n        instance._root = new A_Scope({ name });\n    }\n\n\n\n\n    // ====================================================================================================================\n    // ====================================== HELPERS & GUARDS ============================================================\n    // ====================================================================================================================\n    /**\n     * Type guard to check if the param is allowed for scope allocation.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForScopeAllocation(param: any): param is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isFeatureInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed to be registered in the context.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedToBeRegistered(param: any): param is A_TYPES_ScopeDependentComponents {\n        return A_TypeGuards.isEntityInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isFragmentInstance(param)\n            || A_TypeGuards.isErrorInstance(param);\n    }\n\n    /**\n     * Type guard to check if the param is allowed for meta storage.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMeta(param: any): param is A_TYPES__MetaLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed for meta storage by constructor.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMetaConstructor(param: any): param is A_TYPES__MetaLinkedComponentConstructors {\n        return A_TypeGuards.isContainerConstructor(param)\n            || A_TypeGuards.isComponentConstructor(param)\n            || A_TypeGuards.isEntityConstructor(param);\n    }\n\n\n\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_AbstractionError extends A_Error {\n    /**\n     * This error code indicates that there was an issue extending the abstraction execution\n     */\n    static readonly AbstractionExtensionError = 'Unable to extend abstraction execution';\n\n}","import {\n    A_TYPES__AbstractionDecoratorConfig,\n    A_TYPES__AbstractionDecoratorDescriptor\n} from \"./A-Abstraction.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport {\n    A_Container,\n    A_ContainerMeta,\n    A_TYPES__ContainerMetaKey\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_ComponentMeta\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_TYPES__ConceptAbstraction,\n    A_TYPES__ConceptAbstractions\n} from \"@adaas/a-concept/a-concept\";\nimport { A_AbstractionError } from \"./A-Abstraction.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * A-Abstraction Extend decorator allows to extends behavior of each concept abstraction execution. \n * In case some components or containers requires to extend the behavior of the abstraction like 'start', 'build' or 'deploy'\n * for example, this decorator allows to do so.    \n * \n * @param name - abstraction name \n * @param config - configuration of the abstraction extension\n * @returns \n */\nexport function A_Abstraction_Extend(\n    /**\n     * Name of the Concept Abstraction to extend\n     */\n    name: A_TYPES__ConceptAbstractions,\n    /**\n     * Configuration of the Abstraction Extension\n     * \n     */\n    config: Partial<A_TYPES__AbstractionDecoratorConfig> = {}\n) {\n    return function (\n        target: A_Container | A_Component,\n        propertyKey: string,\n        descriptor: A_TYPES__AbstractionDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!name)\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Abstraction name must be provided to extend abstraction for '${componentName}'.`,\n            );\n\n        //  Only Containers and Components can extend Concept Abstractions\n        if (!A_TypeGuards.isConstructorAvailableForAbstraction(target)) {\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Unable to extend Abstraction '${name}' for '${componentName}'. Only A-Containers and A-Components can extend Abstractions.`,\n            );\n        }\n\n        let metaKey;\n        const meta: A_ContainerMeta | A_ComponentMeta = A_Context.meta(target);\n\n        switch (true) {\n            case A_TypeGuards.isContainerConstructor(target) || A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.ABSTRACTIONS\n                break;\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.ABSTRACTIONS\n                break;\n        }\n        const setName = `CONCEPT_ABSTRACTION::${name}`;\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            [Key: string]: A_TYPES__ConceptAbstraction[];\n        }> = meta.get(metaKey) ?\n                new A_Meta().from(meta.get(metaKey))\n                : new A_Meta();\n\n        // Set the metadata of the method to define a custom Stage with name\n        const existedMetaValue = [\n            ...(existedMeta.get(setName) || [])\n        ];\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const abstraction = {\n            name: setName,\n            handler: propertyKey,\n            behavior: config.behavior || 'sync',\n            throwOnError: config.throwOnError !== undefined ? config.throwOnError : true,\n\n            before: A_TypeGuards.isArray(config.before)\n                ? new RegExp(`^${config.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.before instanceof RegExp\n                    ? config.before.source\n                    : '',\n            after: A_TypeGuards.isArray(config.after)\n                ? new RegExp(`^${config.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n\n            override: A_TypeGuards.isArray(config.override)\n                ? new RegExp(`^${config.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = abstraction;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(abstraction);\n        }\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(setName, existedMetaValue);\n\n        //  Update the metadata of the container with the new Stage definition\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    };\n}\n","import { A_Abstraction_Extend } from \"./A-Abstraction-Extend.decorator\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_TYPES__Abstraction_Init } from \"./A-Abstraction.types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_TYPES__ConceptAbstractions } from \"@adaas/a-concept/a-concept\";\n\n\n\nexport class A_Abstraction {\n\n    /**\n     * The name of the Abstraction e.g. 'deploy', 'start', 'test', etc.\n     */\n    protected _name: A_TYPES__ConceptAbstractions;\n    /**\n     * List of features that are part of this Abstraction\n     */\n    protected _features: A_Feature[] = [];\n    /**\n     * The Feature currently being processed\n     */\n    protected _current?: A_Feature;\n    /**\n     * Actual Index of the current Feature being processed\n     */\n    protected _index: number = 0;\n\n\n    /**\n     * Allows to extends A-Abstraction with additional methods\n     */\n    static get Extend(): typeof A_Abstraction_Extend {\n        return A_Abstraction_Extend;\n    }\n\n    /**\n     * A-Abstraction is an object that is common for any application. \n     * By providing components and creating abstraction extensions it's possible to create a unique behavior of the whole solution.\n     * \n     * Every application has basic abstractions like 'start', 'stop', 'deploy', 'test', etc. \n     * They can be easily extended with additional logic from both containers and components.\n     * \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Parameters to define the A-Abstraction\n         */\n        params: A_TYPES__Abstraction_Init\n    ) {\n        this._name = params.name;\n\n        this._features = params.containers.map(container => {\n            const template = A_Context.abstractionTemplate(\n                this._name,\n                container\n            );\n            return new A_Feature({\n                name: this._name,\n                component: container,\n                template\n            })\n        });\n\n        this._current = this._features[0];\n    }\n\n    /**\n     * Returns the name of the Abstraction\n     */\n    get name(): string { return this._name; }\n    /**\n     * Returns the current Feature being processed\n     */\n    get feature(): A_Feature | undefined {\n        return this._current;\n    }\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.feature\n            || this._index >= this._features.length\n\n    }\n\n\n    [Symbol.iterator](): Iterator<A_Feature, any> {\n        return {\n            // Custom next method\n            next: (): IteratorResult<A_Feature, any> => {\n                if (!this.isDone) {\n\n                    this._current = this._features[this._index];\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    /**\n     * This method moves the Abstraction processing to the next Feature in the list\n     * \n     * @param stage \n     */\n    next(stage) {\n        if (this._index >= this._features.length) {\n            return;\n        }\n\n        const stageIndex = this._features.indexOf(stage);\n\n        this._index = stageIndex + 1;\n    }\n\n\n\n    /**\n     * Allows to process all stages of the Abstraction\n     * \n     * @returns \n     */\n    async process(\n        /**\n         * Allows to override the scope in which the Abstraction will be processed\n         * \n         */\n        scope?: A_Scope\n    ) {\n        if (this.isDone)\n            return;\n\n        for (const feature of this._features) {\n\n            await feature.process(scope);\n        }\n    }\n}","export enum A_TYPES__ConceptAbstractions {\n    /**\n     * Run the concept.\n     */\n    Run = 'run',\n    /**\n     * Build the concept.\n     */\n    Build = 'build',\n    /**\n     * Publish the concept.\n     */\n    Publish = 'publish',\n    /**\n     * Deploy the concept.\n     */\n    Deploy = 'deploy',\n    /**\n     * Load the concept.\n     */\n    Load = 'load',\n    /**\n     * Start the concept.\n     */\n    Start = 'start',\n    /**\n     * Stop the concept.\n     */\n    Stop = 'stop',\n}\n\n\n\nexport enum A_TYPES__ConceptMetaKey {\n    LIFECYCLE = 'a-component-extensions',\n}","import { A_Container } from \"@adaas/a-concept/a-container\";\nimport {\n    A_Abstraction,\n    A_TYPES__AbstractionDecoratorConfig\n} from \"@adaas/a-concept/a-abstraction\";\nimport { A_Abstraction_Extend } from \"@adaas/a-concept/a-abstraction\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_TYPES__ConceptAbstractions } from \"./A-Concept.constants\";\nimport { A_TYPES__Concept_Init } from \"./A-Concept.types\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\n\n\n\nexport class A_Concept<\n    _Imports extends A_Container[] = A_Container[]\n> {\n\n    // ==============================================================================\n    // ====================  STATIC LIFECYCLE DECORATORS  ===========================\n    // ==============================================================================\n    /**\n     * Load the concept. This step runs before any other steps to ensure that all components are loaded.\n     */\n    static Load(\n        /**\n         * provide additional configuration for the abstraction extension to make it dependent on other factors\n         */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ): ReturnType<typeof A_Abstraction_Extend> {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Load, config);\n    }\n\n    /**\n     * Publish the concept to ADAAS platform. (Or any other place defined in the concept)\n     *\n     * [!] To extend the logic just create a custom containers and override the default behavior.\n     */\n    static Publish(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ): ReturnType<typeof A_Abstraction_Extend> {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Publish);\n    }\n\n    /**\n     * Deploy the concept to the environment.\n     */\n    static Deploy(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Deploy, config);\n    }\n\n    /**\n     * Compiles the Concept in case there are some containers that require that. \n     * \n     * Can be used for static websites or any other concept that requires a build step.\n     * \n     */\n    static Build(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Build, config);\n    }\n\n    /**\n     *  Main execution of the concept.\n     */\n    static Run(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Run, config);\n    }\n\n    /**\n     *  Start the concept. Uses for servers or any other background services.\n     */\n    static Start(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Start, config);\n    }\n\n    /**\n     * Stop the concept. Uses for servers or any other background services.\n     */\n    static Stop(\n        /**\n        * provide additional configuration for the abstraction extension to make it dependent on other factors\n        */\n        config?: Partial<A_TYPES__AbstractionDecoratorConfig>\n    ) {\n        return A_Abstraction.Extend(A_TYPES__ConceptAbstractions.Stop, config);\n    }\n\n\n    /**\n     * Name of the concept\n     * \n     * By default, the name of the Concept is 'a-concept'\n     */\n    private _name!: string;\n    /**\n     * A list of internally defined containers that the concept uses.\n     */\n    protected _containers!: A_Container[];\n\n\n\n    // ==============================================================================\n    // ==========================  MAIN Methods  ======================================\n    // ==============================================================================\n\n\n    /**\n     * A-Concept is a placeholder for the concept of the any program.\n     * \n     * Concept - could be any Program regardless environment and it's goal.\n     * It could be mobile, web or simple html page.\n     * All depends on Containers and Components installed and provided in the Concept.\n     * \n     * \n     * [!] Concept operates ONLY with all Components and Containers provided to achieve the goal.\n     * \n     * \n     * @param props - Initialization properties for the Concept\n     */\n    constructor(\n        protected props: A_TYPES__Concept_Init<_Imports>\n    ) {\n        this._name = props.name || A_Context.root.name;\n\n        if (props.components && props.components.length)\n            props.components.forEach(component => this.scope.register(component))\n\n        if (props.fragments && props.fragments.length)\n            props.fragments.forEach(fragment => this.scope.register(fragment))\n\n        if (props.entities && props.entities.length)\n            props.entities.forEach(entity => this.scope.register(entity as any))\n\n\n        this._containers = props.containers || [];\n    }\n\n    /**\n     * Name of the concept\n     */\n    get name() {\n        return A_Context.root.name;\n    }\n    /**\n     * The primary Root scope of the concept.\n     */\n    get scope() {\n        return A_Context.root;\n    }\n\n    /**\n     * Register a class or value in the concept scope.\n     */\n    get register(): A_Scope['register'] {\n        return this.scope.register.bind(this.scope);\n    }\n\n    /**\n     * Resolve a class or value from the concept scope.\n     */\n    get resolve(): A_Scope['resolve'] {\n        return this.scope.resolve.bind(this.scope);\n    }\n\n\n    // =======================================================================\n    // ==========================  LIFECYCLE  ================================\n    // =======================================================================\n    /**\n     * Load the concept.\n     */\n    async load(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Load,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Run the concept.\n     */\n    async run(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Run,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Start the concept.\n     * \n     * @param params \n     */\n    async start(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Start,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Stop the concept.\n     * \n     * @param params \n     */\n    async stop(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Stop,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Build the concept.\n     */\n    async build(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Build,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n    /**\n     * Deploy the concept.\n     */\n    async deploy(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Deploy,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n\n    }\n    /**\n     * Publish the concept.\n     */\n    async publish(\n        scope?: A_Scope,\n    ) {\n        const abstraction = new A_Abstraction({\n            name: A_TYPES__ConceptAbstractions.Publish,\n            containers: this._containers,\n        });\n\n        await abstraction.process(scope);\n    }\n\n\n    // =======================================================================\n    // ==========================  CALL  =====================================\n    // =======================================================================\n\n\n    /**\n     * Call the specific method of the concept or included modules.\n     */\n    async call<\n        K extends Record<_Imports[number]['name'], string>\n    >(\n        /**\n         * Name of the method to call\n         */\n        method: K[keyof K],\n        /**\n         * Container in which the method is located\n         */\n        container: _Imports[number],\n    ) {\n        const feature = new A_Feature({ name: method, component: container });\n\n        return await feature.process();\n    }\n}\n\n\n\n\n","\nimport { A_Container } from \"@adaas/a-concept/a-container\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\n\n\n\nexport class A_ConceptMeta extends A_Meta<any> {\n\n\n    constructor(\n        private containers: Array<A_Container>,\n    ) {\n        super();\n    }\n\n\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\nexport class A_InjectError extends A_Error {\n    static readonly InvalidInjectionTarget = 'Invalid target for A-Inject decorator';\n\n    static readonly MissingInjectionTarget = 'Missing target for A-Inject decorator';\n}","import {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__A_InjectDecoratorReturn,\n    A_TYPES__InjectableTargets\n} from \"./A-Inject.types\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport {\n    A_TYPES__ContainerMetaKey\n\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_TYPES__Entity_Constructor,\n    A_TYPES__EntityMetaKey\n} from \"@adaas/a-concept/a-entity\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_Entity } from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__Feature_Constructor } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Caller,\n    A_TYPES__Caller_Constructor\n} from \"@adaas/a-concept/a-caller\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_InjectError } from \"./A-Inject.error\";\nimport {\n    A_Scope,\n    A_TYPES__Scope_Constructor\n} from \"@adaas/a-concept/a-scope\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Error,\n    A_TYPES__Error_Constructor\n} from \"@adaas/a-concept/a-error\";\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable,\n    A_TYPES__A_DependencyResolutionStrategy\n} from \"@adaas/a-concept/a-dependency\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\n\n\n/**\n * A-Inject decorator\n * \n * This Decorator allows to inject dependencies into the module like \n * - Namespaces \n * - Other Concepts \n * - or maybe Components\n * \n * @param params - see overloads\n * @returns - decorator function\n */\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the Component constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Component from current Scope or from Parent Scopes.\n     */\n    component: A_TYPES__Component_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\n// Allows to inject just one Context Fragment\nexport function A_Inject<T extends A_Fragment>(\n    /**\n     * Provide the Fragment constructor to inject the Fragment instance\n     *\n     * [!] It returns the Fragment instance from current Scope or from Parent Scopes.\n     */\n    fragment: A_TYPES__Fragment_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Entity>(\n    /**\n     * Provide the Entity constructor to inject the Entity instance\n     * \n     * [!] Note: It returns the Entity instance from current Scope or from Parent Scopes.\n     * [!] Note: If instance has more than one Entity of the same type It returns FIRST found Entity\n     * [!] Note: Use 'config' to specify to inject specific one or even Array of Entities\n     */\n    entity: A_TYPES__Entity_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     * \n     * [!] Default Pagination is 1 if it's necessary to get multiple Entities please customize it in the instructions\n     */\n    config?: Partial<A_TYPES__A_DependencyResolutionStrategy<T>>\n): A_TYPES__A_InjectDecoratorReturn<T>\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the name of Component constructor to inject the Component instance\n     * \n     * [!] You can use both customized one or original depending on your overriding strategy\n     */\n    ctor: string\n): A_TYPES__A_InjectDecoratorReturn\n//  Allows to inject just one A_FeatureCaller\nexport function A_Inject<T extends A_Caller>(\n    /**\n     * Provide the A_Caller constructor to inject the Caller instance\n     *\n     * [!] It returns initiator of the call, e.g. Container/Component/Command who called Feature \n     */\n    caller: A_TYPES__Caller_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\n//  Allows to inject just one A_Error instance\nexport function A_Inject<T extends A_Error>(\n    /***\n     * Provide the Error constructor that will be associated with the injection.\n     *\n     * [!] It returns an Instance of the Error what is executed.\n     */\n    error: A_TYPES__Error_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Feature>(\n    /**\n     * Provide the Feature constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Feature what is executed. \n     */\n    feature: A_TYPES__Feature_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\n// Allows to inject just one Scope instance\nexport function A_Inject<T extends A_Scope>(\n    /***\n     * Provide the Scope constructor that will be associated with the injection.\n     *\n     * [!] It returns an instance of the Scope where the Entity/Component/Container is defined.\n     */\n    scope: A_TYPES__Scope_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_TYPES__A_DependencyInjectable>(\n    /***\n     * Provide the Scope constructor that will be associated with the injection.\n     *\n     * [!] It returns an instance of the Scope where the Entity/Component/Container is defined.\n     */\n    dependency: A_Dependency<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_TYPES__A_DependencyInjectable>(\n    param1: string | A_TYPES__Ctor<T> | A_Dependency<T>,\n    param2?: Partial<A_TYPES__A_DependencyResolutionStrategy<T>>\n): A_TYPES__A_InjectDecoratorReturn {\n\n    //  pre call checks\n    if (!param1) {\n        throw new A_InjectError(\n            A_InjectError.MissingInjectionTarget,\n            `A-Inject decorator is missing the target to inject`\n        );\n    }\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_InjectError(\n                A_InjectError.InvalidInjectionTarget,\n                `A-Inject cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = param1 instanceof A_Dependency ? param1 : new A_Dependency(param1, param2);\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}"]}