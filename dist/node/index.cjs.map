{"version":3,"sources":["../../src/lib/A-Fragment/A-Fragment.class.ts","../../src/lib/A-Feature/A-Feature.types.ts","../../src/helpers/A_Formatter.helper.ts","../../src/helpers/A_Identity.helper.ts","../../src/helpers/A_BasicTypeGuards.helper.ts","../../src/lib/ASEID/ASEID.class.ts","../../src/lib/A-Error/A_Error.constants.ts","../../src/constants/env.constants.ts","../../src/env/env.base.ts","../../src/env/env-node.ts","../../src/lib/A-Error/A_Error.class.ts","../../src/lib/A-Entity/A-Entity.error.ts","../../src/lib/A-Entity/A-Entity.class.ts","../../src/lib/A-Meta/A-Meta.decorator.ts","../../src/lib/A-Meta/A-Meta.class.ts","../../src/lib/A-Entity/A-Entity.constants.ts","../../src/lib/A-Entity/A-Entity.meta.ts","../../src/lib/A-Container/A-Container.class.ts","../../src/lib/A-Container/A-Container.constants.ts","../../src/lib/A-Container/A-Container.meta.ts","../../src/lib/A-Feature/A-Feature.error.ts","../../src/helpers/A_Common.helper.ts","../../src/lib/A-Caller/A_Caller.error.ts","../../src/lib/A-Caller/A_Caller.class.ts","../../src/lib/A-Dependency/A-Dependency.error.ts","../../src/lib/A-Dependency/A-Dependency-Default.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Flat.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Load.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Parent.decorator.ts","../../src/lib/A-Dependency/A-Dependency-Require.decorator.ts","../../src/lib/A-Dependency/A-Dependency-All.decorator.ts","../../src/lib/A-Dependency/A-Dependency.class.ts","../../src/helpers/A_TypeGuards.helper.ts","../../src/lib/A-Feature/A-Feature-Define.decorator.ts","../../src/lib/A-Feature/A-Feature-Extend.decorator.ts","../../src/lib/A-Stage/A-Stage.types.ts","../../src/lib/A-Stage/A-Stage.error.ts","../../src/lib/A-Stage/A-Stage.class.ts","../../src/lib/A-StepManager/A-StepManager.error.ts","../../src/lib/A-StepManager/A-StepManager.class.ts","../../src/lib/A-Feature/A-Feature.class.ts","../../src/lib/A-Component/A-Component.class.ts","../../src/lib/A-Component/A-Component.constants.ts","../../src/lib/A-Component/A-Component.meta.ts","../../src/lib/A-Scope/A-Scope.class.ts","../../src/lib/A-Scope/A-Scope.error.ts","../../src/lib/A-Context/A-Context.error.ts","../../src/lib/A-Context/A-Context.class.ts","../../src/lib/A-Abstraction/A-Abstraction.error.ts","../../src/lib/A-Abstraction/A-Abstraction-Extend.decorator.ts","../../src/lib/A-Abstraction/A-Abstraction.class.ts","../../src/lib/A-Inject/A-Inject.error.ts","../../src/lib/A-Inject/A-Inject.decorator.ts"],"names":["A_TYPES__FeatureState","A_TYPES__EntityMetaKey","A_TYPES__EntityFeatures","A_TYPES__ContainerMetaKey","extensions","A_TYPES__A_Stage_Status","A_TYPES__ComponentMetaKey"],"mappings":"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","file":"index.cjs","sourcesContent":["import { A_TYPES__Fragment_Init, A_TYPES__Fragment_Serialized } from \"./A-Fragment.types\";\n\n\n/**\n * A_Fragment is a core architectural component that represents a singleton execution context\n * within the A-Concept framework. It serves as a shared memory container that can be passed\n * between Components, Entities, and Commands throughout the application pipeline.\n * \n * Key Features:\n * - Singleton pattern: Only one instance per fragment type per scope\n * - Meta storage: Built-in key-value storage for pipeline data\n * - Type-safe: Full TypeScript generics support for meta items and serialization\n * - Serializable: Can be converted to JSON for persistence or transmission\n * \n * @template _MetaItems - Type definition for the meta storage structure\n * @template _SerializedType - Type definition for the serialized output format\n * \n * @example\n * ```typescript\n * // Basic usage with typed meta\n * class UserFragment extends A_Fragment<{ userId: string; role: string }> {\n *   constructor() {\n *     super({ name: 'UserFragment' });\n *   }\n * }    \n * \n * // Custom serialization\n * class SessionFragment extends A_Fragment<\n *   { sessionId: string; timestamp: number },\n *   { name: string; sessionData: string }\n * > {\n *   toJSON() {\n *     return {\n *       name: this.name,\n *       sessionData: `${this.get('sessionId')}-${this.get('timestamp')}`\n *     };\n *   }\n * }\n * ```\n */\nexport class A_Fragment<\n    _SerializedType extends A_TYPES__Fragment_Serialized = A_TYPES__Fragment_Serialized\n> {\n    /**\n     * The unique identifier/name for this fragment instance.\n     * Used for identification and debugging purposes.\n     */\n    protected _name: string;\n\n    /**\n     * Creates a new A_Fragment instance.\n     * \n     * A_Fragment implements the singleton pattern for execution contexts, allowing\n     * shared state management across different parts of the application pipeline.\n     * Each fragment serves as a memory container that can store typed data and be\n     * serialized for persistence or transmission.\n     * \n     * Key Benefits:\n     * - Centralized state management for related operations\n     * - Type-safe meta operations with full IntelliSense support\n     * - Serialization support for data persistence \n     * - Singleton pattern ensures consistent state within scope\n     * \n     * @param params - Initialization parameters\n     * @param params.name - Optional custom name for the fragment (defaults to class name)\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string }>({ \n     *   name: 'UserSessionFragment' \n     * });\n     * fragment.set('userId', '12345');\n     * ```\n     */\n    constructor(params: Partial<A_TYPES__Fragment_Init> = {}) {\n        this._name = params.name || this.constructor.name;\n    }\n\n    /**\n     * Gets the fragment's unique name/identifier.\n     * \n     * @returns The fragment name\n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Serializes the fragment to a JSON-compatible object.\n     * \n     * This method combines the fragment's name with all meta data to create\n     * a serializable representation. The return type is determined by the\n     * _SerializedType generic parameter, allowing for custom serialization formats.\n     * \n     * @returns A serialized representation of the fragment\n     * \n     * @example\n     * ```typescript\n     * const fragment = new A_Fragment<{ userId: string, role: string }>({\n     *   name: 'UserFragment'\n     * });\n     * fragment.set('userId', '12345');\n     * fragment.set('role', 'admin');\n     * \n     * const json = fragment.toJSON();\n     * // Result: { name: 'UserFragment', userId: '12345', role: 'admin' }\n     * ```\n     */\n    toJSON(): _SerializedType {\n        const result = {\n            name: this.name,\n        };\n\n        return result as _SerializedType;\n    }\n}","import {\n    A_Stage,\n    A_TYPES__A_StageStep,\n    A_TYPES_StageExecutionBehavior\n} from \"@adaas/a-concept/a-stage\"\nimport { A_Entity } from \"@adaas/a-concept/a-entity\"\nimport {\n    A_Container,\n    A_TYPES__Container_Constructor\n} from \"@adaas/a-concept/a-container\"\nimport {\n    A_Component,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\"\nimport { A_TYPES__Entity_Constructor } from \"@adaas/a-concept/a-entity\"\nimport { A_Feature } from \"./A-Feature.class\"\nimport {\n    A_TYPES__Ctor,\n    A_TYPES__Required\n} from \"@adaas/a-concept/types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\"\nimport { A_TYPES__Error_Init } from \"@adaas/a-concept/a-error\"\n\n\n// ============================================================================\n// --------------------------- Primary Types ----------------------------------\n// ============================================================================\n/**\n * Feature constructor type\n * Uses the generic type T to specify the type of the feature\n */\nexport type A_TYPES__Feature_Constructor<T = A_Feature> = A_TYPES__Ctor<T>;\n/**\n * Feature initialization type\n */\nexport type A_TYPES__Feature_Init<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = A_TYPES__Feature_InitWithComponent<T> | A_TYPES__Feature_InitWithTemplate<T>\n/**\n * Feature initialization type using component\n */\nexport type A_TYPES__Feature_InitWithComponent<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component: T,\n\n    /**\n     * In case when Entity is not attached to the scope can be used to transparently show dependencies\n     * \n     * \n     */\n    scope?: A_Scope\n}\n/**\n * Feature initialization type using template\n */\nexport type A_TYPES__Feature_InitWithTemplate<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> = {\n    /**\n     * Feature Name\n     */\n    name: string,\n    /**\n     * The scope from where to retrieve dependent components, entities and containers. \n     * \n     * [!] Important for proper scoping. \n     */\n    scope: A_Scope\n    /**\n     * The component from where the feature is calling. It's important for proper scoping. \n     * Based on the component would be retrieved connected components, entities and containers.\n     * \n     * [!] Could be Container, Entity, Component or Command\n     */\n    component?: T,\n    /**\n     * Optional Feature template to be used instead of building it from decorators\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n\n/**\n * Feature serialized type\n */\nexport type A_TYPES__Feature_Serialized = {}\n\n\n/**\n * Feature lifecycle states\n */\nexport enum A_TYPES__FeatureState {\n    /**\n     * The feature has been initialized\n     */\n    INITIALIZED = \"INITIALIZED\",\n    /**\n     * The feature is currently being processed\n     */\n    PROCESSING = \"PROCESSING\",\n    /**\n     * The feature has been completed\n     */\n    COMPLETED = \"COMPLETED\",\n    /**\n     * The feature has been interrupted\n     */\n    INTERRUPTED = \"INTERRUPTED\",\n    /**\n     * The feature has failed\n     */\n    FAILED = \"FAILED\"\n}\n\n// ===========================================================================\n// --------------------------- Error Types ------------------------------------\n// ===========================================================================\n\nexport type A_TYPES__FeatureError_Init = {\n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n} & A_TYPES__Error_Init\n\n\n\n// ===========================================================================-\n// --------------------------- Available Types -------------------------------\n// ===========================================================================\n\n/**\n * A list of component where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableComponents = InstanceType<A_TYPES__FeatureAvailableConstructors>\n/**\n * A list of constructors where features can be Defined\n * \n * [!] On this component Feature Definition is Available\n */\nexport type A_TYPES__FeatureAvailableConstructors = A_TYPES__Component_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Container_Constructor\n\n\n\n// ===========================================================================\n// --------------------------- Decorator Types -------------------------------\n// ===========================================================================\n// ---------------------------------------------------------------------------\n// --------------------Feature Define Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Indicates a type of Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorDescriptor =\n    TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n/**\n * Describes additional configuration properties to be used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorConfig = {\n    /**\n     * Feature name\n     * \n     * [!] By default uses the method name\n     */\n    name: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n}\n/**\n * Describes a single template item used in Feature Define decorator\n */\nexport type A_TYPES__FeatureDefineDecoratorTemplateItem = A_TYPES__Required<Partial<A_TYPES__A_StageStep>, ['name', 'handler', 'dependency']>\n/**\n * Describes a target where Feature Define decorator can be applied\n * \n * [!] The feature can be defined on Container, Entity, Component or Command\n */\nexport type A_TYPES__FeatureDefineDecoratorTarget = A_Container\n    | A_Entity\n    | A_Component\n/**\n * A type of Meta information stored by Feature Define decorator\n * This information then uses by A-Context to build a proper feature template\n */\nexport type A_TYPES__FeatureDefineDecoratorMeta = {\n    /**\n     * Feature name\n     * mainly it's a unique combination of the class name and method name\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string,\n    /**\n     * Indicates a default behavior of the feature. If true the feature will be automatically attached to the execution.\n     * \n     * [!] Before feature execution the method itself will be called to prepare the feature template\n     * [!] Default is false\n     */\n    invoke: boolean,\n    /**\n     * Allows to add a default behavior or number of steps that will be part of the feature\n     */\n    template: Array<A_TYPES__A_StageStep>\n}\n// ---------------------------------------------------------------------------\n// --------------------Feature Extend Decorator Types-------------------------\n// ---------------------------------------------------------------------------\n/**\n * Descriptor type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorDescriptor =\n    TypedPropertyDescriptor<() => any>\n    | TypedPropertyDescriptor<(...args: any[]) => any>\n    | TypedPropertyDescriptor<(...args: any[]) => Promise<any>>\n    | TypedPropertyDescriptor<() => Promise<any>>\n/**\n * Target type for A_Extend decorator\n * \n * [!] Can be applied only on A-Components\n */\nexport type A_TYPES__FeatureExtendDecoratorTarget = A_Component | A_Container | A_Entity\n\n/**\n * Configuration type for A_Extend decorator\n * \n * This is an INPUT parameter provided by the user\n */\nexport type A_TYPES__FeatureExtendDecoratorConfig = {\n    /**\n     * Name of the container Lifecycle method to be extended.\n     * \n     * [!] If not provided will be used the name of the method.\n     * [!!] If name contains \".\" dot it will be considered as a path to the method.\n     */\n    name: string,\n    /**\n     * Container class or container name uses to identify the proper container in case when the name is not unique.\n     * \n     * [!] If not provided will be applied to all containers with the same name.\n     * [!!] By default uses OR to join all provided items. If you need more complex Logic, please use Regexp instead\n     * \n     * [!!!] In case if you need to exclude some containers, entities or components, please use \"exclude\" property\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      scope: {\n     *          include: [A_Container1, A_Entity1],\n     *          exclude: [A_Component1]\n     *      }\n     *  })\n     * ```\n     */\n    scope: Array<A_TYPES__FeatureExtendDecoratorScopeItem> | Partial<A_TYPES__FeatureExtendDecoratorScopeConfig>,\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      before: /Component2\\..+/\n     *  })\n     * ```\n     */\n    before: Array<string> | RegExp\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] It applies for the following structure :'Component.methodName'\n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     * Example:\n     * ```ts\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: ['Component1.methodName', 'Component2.methodName2']\n     *  })\n     *  // OR\n     *  @A_Feature.Extend({\n     *      name: 'load',\n     *      after: /Component2\\..+/\n     *  })\n     * ```\n     * \n     */\n    after: Array<string> | RegExp\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: Array<string> | RegExp\n}\n/**\n * Scope item that can be used in A_Extend decorator configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeConfig = {\n    /**\n     * A list of components, entities or containers to include in the scope of the extension\n     */\n    include?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>,\n    /**\n     * A list of components, entities or containers to exclude from the scope of the extension\n     */\n    exclude?: Array<A_TYPES__FeatureExtendDecoratorScopeItem>\n}\n/**\n * A single item that can be used in scope configuration\n */\nexport type A_TYPES__FeatureExtendDecoratorScopeItem = A_TYPES__Container_Constructor\n    | A_TYPES__Entity_Constructor\n    | A_TYPES__Component_Constructor\n\n\n\n// =======================================================================\n// --------------------------META TYPES-----------------------------------\n// =======================================================================\n/**\n * Meta type for A_Extend decorator\n */\nexport type A_TYPES__FeatureExtendDecoratorMeta = {\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     */\n    name: string,\n    /**\n     * Actual method name in the class\n     */\n    handler: string\n    /**\n     * The behavior of the method. \n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean,\n    /**\n     * Allows to override particular steps in the feature sequence by provided names [Component].[Method] or by regexp\n     */\n    override: string\n}\n\n\n","\n/**\n * A_FormatterHelper\n * \n * Helper class for formatting strings into different cases.\n */\nexport class A_FormatterHelper {\n    /**\n     * Convert string to UPPER_SNAKE_CASE\n     * \n     * @param str \n     * @returns \n     */\n    static toUpperSnakeCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1_$2')  // Handle camelCase\n            .replace(/[^a-zA-Z0-9]+/g, '_')       // Replace non-alphanumeric with underscores\n            .replace(/_+/g, '_')                  // Collapse multiple underscores\n            .replace(/^_|_$/g, '')                // Remove leading/trailing underscores\n            .toUpperCase();\n    }\n    /**\n     * Convert string to camelCase\n     * \n     * @param str \n     * @returns \n     */\n    static toCamelCase(str: string): string {\n        return str\n            .trim()\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map((part, index) => {\n                if (index === 0) {\n                    return part.toLowerCase();\n                }\n                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n            })\n            .join('');\n    }\n    /**\n     * Convert string to PascalCase\n     * \n     * @param str \n     * @returns \n     */\n    static toPascalCase(str: string): string {\n        return str\n            .trim()\n            .replace(/([a-z])([A-Z])/g, '$1 $2')  // Insert space before uppercase in camelCase\n            .replace(/[^a-zA-Z0-9]+/g, ' ')       // Replace non-alphanumeric with spaces\n            .split(' ')                           // Split by spaces\n            .filter(Boolean)                      // Remove empty items\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n    /**\n     * Convert string to kebab-case\n     * \n     * @param str \n     * @returns \n     */\n    static toKebabCase(str: string): string {\n        return str\n            // 1. Replace all non-alphanumeric (underscore, dot, etc.) with a space\n            .replace(/[^a-zA-Z0-9]+/g, ' ')\n            // 2. Insert space before any uppercase preceded by lowercase or digit\n            .replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n            // 3. Trim spaces at both ends and replace remaining spaces with dashes\n            .trim()\n            .replace(/\\s+/g, '-')\n            // 4. Lowercase everything\n            .toLowerCase();\n    }\n}","import { A_ID_TYPES__TimeId_Parts } from \"@adaas/a-concept/types\";\n\n\n\n\nexport class A_IdentityHelper {\n    /**\n   * Generates a short, time-based unique ID.\n   * Encodes current time (ms since epoch) and random bits in base36.\n   * Example: \"mb4f1g-7f9a1c\"\n   */\n    static generateTimeId(\n        parts: A_ID_TYPES__TimeId_Parts = { timestamp: new Date(), random: Math.random().toString(36).slice(2, 8) }\n    ): string {\n        const time = parts.timestamp.getTime().toString(36); // base36-encoded timestamp\n        const random = parts.random; // use provided random string\n        return `${time}-${random}`;\n    }\n\n    /**\n     * Parses a short ID back into its parts.\n     * Returns an object with the original timestamp (as Date) and random string.\n     */\n    static parseTimeId(id: string): A_ID_TYPES__TimeId_Parts {\n        const [timePart, randomPart] = id.split('-');\n        const timestamp = new Date(parseInt(timePart, 36));\n        return { timestamp, random: randomPart };\n    }\n\n\n    /**\n     *  Format a number with leading zeros to a fixed length\n     * \n     * @param number \n     * @param maxZeros \n     * @returns \n     */\n    static formatWithLeadingZeros(number, maxZeros = 10) {\n        const formattedNumber = String(number).padStart(maxZeros + 1, '0');\n        return formattedNumber.slice(-maxZeros);\n    }\n\n    /**\n     * Remove leading zeros from a formatted number\n     */\n    static removeLeadingZeros(formattedNumber) {\n        return String(Number(formattedNumber)); // Convert to number and back to string to remove leading zeros\n    }\n\n    /**\n     * Generates a simple hash string from the input string.\n     * \n     * \n     * @param input \n     * @returns\n     */\n    static hashString(input: string): string {\n        let hash = 0, i, chr;\n        if (input.length === 0) return hash.toString();\n        for (i = 0; i < input.length; i++) {\n            chr = input.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash.toString();\n    }\n\n\n}","/**\n * Basic TypeGuards that don't create circular dependencies\n * These are used by A_Error and other core classes\n */\nexport class A_BasicTypeGuards {\n\n    /**\n     * Check if value is a string\n     * \n     * @param value \n     * @returns \n     */\n    static isString(value: any): value is string {\n        return typeof value === 'string' || value instanceof String;\n    }\n\n    /**\n     * Check if value is a number\n     * \n     * @param value \n     * @returns \n     */\n    static isNumber(value: any): value is number {\n        return typeof value === 'number' && isFinite(value);\n    }\n\n    /**\n     * Check if value is a boolean\n     * \n     * @param value \n     * @returns \n     */\n    static isBoolean(value: any): value is boolean {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Check if value is an object\n     * \n     * @param value \n     * @returns \n     */\n    static isObject<T = object>(value: any): value is T {\n        return value !== null && typeof value === 'object' && !Array.isArray(value);\n    }\n\n    /**\n     * Check if value is an array\n     * \n     * @param value \n     * @returns \n     */\n    static isArray(value: any): value is any[] {\n        return Array.isArray(value);\n    }\n\n    /**\n     * Allows to check if the provided param is of constructor type.\n     * \n     * @param param \n     * @returns \n     */\n    static isErrorConstructorType<T = any>(param: any): param is T {\n        return !!param && A_BasicTypeGuards.isObject(param) && !(param instanceof Error) && \"title\" in param;\n    }\n\n    static isErrorSerializedType<T = any>(param: any): param is T {\n        return !!param && A_BasicTypeGuards.isObject(param) && !(param instanceof Error) && \"aseid\" in param && A_BasicTypeGuards.isString((param as any).aseid);\n    }\n\n    /**\n     * Check if scope is of type A_Scope instance\n     * \n     * @param scope \n     * @returns \n     */\n    static isScopeInstance(scope: any): boolean {\n        // Basic check without importing A_Scope to avoid circular dependency\n        return !!scope && typeof scope === 'object' && 'name' in scope && 'aseid' in scope;\n    }\n}","import {\n    A_TYPES__ASEID_Constructor,\n    A_TYPES__ASEID_JSON\n} from \"./ASEID.types\";\nimport { A_IdentityHelper} from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport { A_BasicTypeGuards} from \"@adaas/a-concept/helpers/A_BasicTypeGuards.helper\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\n// import { ASEID_Error } from \"./ASEID.error\";\nimport { A_TYPES__Required } from \"@adaas/a-concept/types\";\n\n\nexport class ASEID {\n\n\n    //==========================================================================\n    //============================= STATIC METHODS ===========================\n    //==========================================================================\n    /**\n     * ASEID Regular Expression\n     */\n    static readonly regexp: RegExp = new RegExp(`^[a-z|A-Z|0-9|-]+@[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\-]+:[a-z|A-Z|0-9|\\\\.|-]+(@v[0-9|\\\\.]+|@lts)?$`)\n    /**\n     * Tests if the identity string is an ASEID\n     * \n     * @param identity \n     * @returns \n     */\n    static isASEID(identity: string): boolean {\n        return this.regexp.test(identity)\n    }\n\n\n    static compare(aseid1: ASEID | string | undefined, aseid2: ASEID | string | undefined): boolean {\n\n        if (!aseid1 || !aseid2) {\n            return false;\n        }\n\n        if (A_BasicTypeGuards.isString(aseid1) && this.isASEID(aseid1) === false) {\n            throw new Error(`Invalid ASEID format provided: ${aseid1}`);\n        }\n\n        if (A_BasicTypeGuards.isString(aseid2) && this.isASEID(aseid2) === false) {\n            throw new Error(`Invalid ASEID format provided: ${aseid2}`);\n        }\n\n        const aseidObj1 = aseid1 instanceof ASEID ? aseid1 : new ASEID(aseid1);\n        const aseidObj2 = aseid2 instanceof ASEID ? aseid2 : new ASEID(aseid2);\n\n        return aseidObj1.toString() === aseidObj2.toString();\n    }\n\n\n    // ====================================================================\n    // ==================== Hidden ASEID Information ======================\n    // ====================================================================\n    /**\n     * Concept for the ASEID\n     * Generally it is the application name or code, should correspond to the concept where the entity is used\n     * Could be ID or ASEID\n     */\n    private _concept!: string;\n    /**\n     * Entity Scope the primary location of the resource \n     * Organization, or organization Unit\n     * Could be ID or ASEID\n     * \n     */\n    private _scope!: string\n    /**\n     * Entity Type the type of the resource\n     */\n    private _entity!: string\n    /**\n     * Entity ID the unique identifier of the resource\n     */\n    private _id!: string\n    /**\n     * Version of the entity (optional)\n     */\n    private _version?: string\n    /**\n     * Shard of the entity (optional)\n     */\n    private _shard?: string\n\n\n\n\n\n\n    /**\n     * ASEID is a structured identifier for entities in the A-Concept system. \n     * using the format:\n     *  A - A-Concept\n     *  S - System \n     *  E - Entity\n     *  I - Identifier\n     *  D - iDentifier\n     * \n     * Structure: CONCEPT_NAME + @ + SCOPE + : ENTITY_NAME + : + ID + @ + VERSION \n     * \n     * Example:\n     *  - root@core:usr:0000000001\n     * \n     * [!] Concept is optional, if not provided will be used the current concept name\n     * [!] Scope is optional, if not provided will be used the root scope of the current concept\n     * [!] Version is optional, if not provided will be considered as latest version\n     * \n     * @param aseid - ASEID string representation or ASEID components as object\n     */\n    constructor(\n        /**\n         * ASEID string representation\n         */\n        aseid: string\n    )\n    constructor(\n        /**\n         * ASEID components as object \n         */\n        props: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    )\n    constructor(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this.verifyInput(param1);\n\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1);\n    }\n\n    /**\n     * Getters for ASEID components\n     */\n    get concept(): string {\n        return this._concept || A_Context.concept;\n    }\n    /**\n     * Get the scope of the ASEID\n     */\n    get scope(): string {\n        return this._scope || A_Context.root.name;\n    }\n    /**\n     * Get the entity of the ASEID\n     */\n    get entity(): string {\n        return this._entity;\n    }\n    /**\n     * Get the id of the ASEID\n     */\n    get id(): string {\n        return this._id;\n    }\n    /**\n     * Get the version of the ASEID (if any)\n     */\n    get version(): string | undefined {\n        return this._version;\n    }\n    /**\n     * Get the shard of the ASEID (if any)\n     */\n    get shard(): string | undefined {\n        return this._shard;\n    }\n\n    /**\n     * Get the hash of the ASEID, Unique identifier based on the ASEID string\n     * Useful when aseid details should not be exposed directly\n     */\n    get hash(): string {\n        return A_IdentityHelper.hashString(this.toString());\n    }\n\n    /**\n     * get Internal Initializer based on the type of the parameter provided\n     * \n     * @param param1 \n     * @returns \n     */\n    private getInitializer(\n        param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>\n    ): (param1: any) => void | (() => void) {\n        switch (true) {\n            case A_BasicTypeGuards.isString(param1):\n                return this.fromString;\n\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1):\n                return this.fromObject;\n\n            default:\n                throw new Error(\n                    'Invalid parameters provided to ASEID constructor'\n                );\n        }\n    }\n\n\n    /**\n     * Initialize ASEID from string\n     * \n     * @param param1 \n     */\n    private fromString(param1: string) {\n        const [concept, body, version] = param1.split('@');\n        const [scope, entity, idCandidate] = body.split(':');\n\n        const shard = idCandidate.includes('.') ? idCandidate.split('.')[0] : undefined;\n        const id = idCandidate.includes('.') ? idCandidate.split('.')[1] : idCandidate;\n\n        this._concept = concept || A_Context.root.name;\n        this._scope = scope || A_Context.root.name;\n        this._entity = entity;\n        this._id = id;\n        this._version = version;\n        this._shard = shard;\n    }\n    /**\n     * Initialize ASEID from object\n     * \n     * @param param1 \n     */\n    private fromObject(param1: A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n        this._concept = param1.concept\n            ? ASEID.isASEID(param1.concept)\n                ? new ASEID(param1.concept).id\n                : param1.concept\n            : A_Context.concept;\n\n        this._scope = param1.scope\n            ? A_BasicTypeGuards.isNumber(param1.scope)\n                ? A_IdentityHelper.formatWithLeadingZeros(param1.scope) :\n                ASEID.isASEID(param1.scope)\n                    ? new ASEID(param1.scope).id\n                    : param1.scope\n            : A_Context.root.name\n\n        this._entity = param1.entity;\n\n        this._id = A_BasicTypeGuards.isNumber(param1.id)\n            ? A_IdentityHelper.formatWithLeadingZeros(param1.id)\n            : param1.id;\n\n        this._version = param1.version;\n        this._shard = param1.shard;\n    }\n\n\n    /**\n     * String representation of the ASEID\n     * \n     * @returns \n     */\n    toString(): string {\n        return `${this.concept}@${this.scope}:${this.entity}:${this.shard ? (this.shard + '.' + this.id) : this.id}${this.version ? ('@' + this.version) : ''}`\n    }\n\n    /**\n     * JSON representation of the ASEID\n     * \n     * @returns \n     */\n    toJSON(): A_TYPES__ASEID_JSON {\n        return {\n            concept: this._concept,\n            scope: this._scope,\n            entity: this._entity,\n            id: this._id,\n            version: this._version,\n            shard: this._shard\n        }\n    }\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n\n\n    protected verifyInput(param1: string | A_TYPES__Required<Partial<A_TYPES__ASEID_Constructor>, ['id', 'entity']>) {\n\n        switch (true) {\n            // 1) check for string and validate it as ASEID\n            case A_BasicTypeGuards.isString(param1) && !ASEID.isASEID(param1):\n                throw new Error( 'Invalid ASEID format provided')\n\n            // 2) check for object and validate required fields\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.id:\n                throw new Error('ASEID id is required')\n            // 3) check for object and validate required fields\n            case A_BasicTypeGuards.isObject<A_TYPES__ASEID_Constructor>(param1) && !param1.entity:\n                throw new Error('ASEID entity is required')\n\n        }\n    }\n}","\n\n\nexport const A_CONSTANTS__ERROR_CODES = {\n    UNEXPECTED_ERROR: 'A-Error Unexpected Error',\n    VALIDATION_ERROR: 'A-Error Validation Error',\n} as const;\n\n\n\nexport const A_CONSTANTS__ERROR_DESCRIPTION = 'If you see this error please let us know.'","export const A_CONSTANTS__DEFAULT_ENV_VARIABLES = {\n    // ----------------------------------------------------------\n    // A-Concept Core Environment Variables\n    // ----------------------------------------------------------\n    // These environment variables are used by A-Concept core to configure the application\n    // ----------------------------------------------------------\n    /**\n     * Name of the application\n     * \n     * DEFAULT value is 'a-concept'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_NAME: 'A_CONCEPT_NAME',\n    /**\n     * Root scope of the application\n     * \n     * DEFAULT value is 'root'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    A_CONCEPT_ROOT_SCOPE: 'A_CONCEPT_ROOT_SCOPE',\n    /**\n     * Environment of the application e.g. development, production, staging\n     */\n    A_CONCEPT_ENVIRONMENT: 'A_CONCEPT_ENVIRONMENT',\n    /**\n     * Runtime environment of the application e.g. browser, node\n     */\n    A_CONCEPT_RUNTIME_ENVIRONMENT: 'A_CONCEPT_RUNTIME_ENVIRONMENT',\n    /**\n     * Root folder of the application\n     * [!] Automatically set by A-Concept when the application starts\n     */\n    A_CONCEPT_ROOT_FOLDER: 'A_CONCEPT_ROOT_FOLDER',\n    /**\n     * Allows to define a default error description for errors thrown without a description\n     */\n    A_ERROR_DEFAULT_DESCRIPTION: 'A_ERROR_DEFAULT_DESCRIPTION',\n} as const\n\n\n//should be an array\nexport type A_TYPES__ConceptENVVariables = (typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES)[keyof typeof A_CONSTANTS__DEFAULT_ENV_VARIABLES][];\n\n\nexport const A_CONSTANTS__DEFAULT_ENV_VARIABLES_ARRAY = [\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_NAME,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ENVIRONMENT,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_RUNTIME_ENVIRONMENT,\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_FOLDER,\n\n    A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_ERROR_DEFAULT_DESCRIPTION,\n] as const;\n\n","import { A_TYPES__ContextEnvironment } from \"@adaas/a-concept/a-context\";\n\nexport class A_CONCEPT_BASE_ENV {\n  // ----------------------------------------------------------\n  // A-Concept Core Environment Variables\n  // ----------------------------------------------------------\n  // These environment variables are used by A-Concept core to configure the application\n  // ----------------------------------------------------------\n  /**\n   * Name of the application\n   * \n   * DEFAULT value is 'a-concept'\n   * \n   * [!] Provided name will be used for all aseids in the application by default\n   */\n  static get A_CONCEPT_NAME() {\n    return \"a-concept\";\n  }\n  /**\n   * Root scope of the application\n   * \n   * DEFAULT value is 'root'\n   * \n   * [!] Provided name will be used for all aseids in the application by default\n   */\n  static get A_CONCEPT_ROOT_SCOPE() {\n    return \"root\";\n  }\n  /**\n   * Environment of the application e.g. development, production, staging\n   */\n  static get A_CONCEPT_ENVIRONMENT() {\n    return \"production\";\n  }\n  /**\n   * Runtime environment of the application e.g. browser, node\n   */\n  static get A_CONCEPT_RUNTIME_ENVIRONMENT(): A_TYPES__ContextEnvironment {\n    return \"unknown\";\n  }\n\n  /**\n   * Root folder of the application\n   * [!] Automatically set by A-Concept when the application starts\n   */\n  static get A_CONCEPT_ROOT_FOLDER() {\n    return \"/app\";\n  }\n\n  /**\n   * Allows to define a default error description for errors thrown without a description\n   */\n  static get A_ERROR_DEFAULT_DESCRIPTION() {\n    return \"If you see this error please let us know.\";\n  }\n\n  /**\n   * Generic getter for environment variables. This allows to access environment variables dynamically by name. It will return undefined if the variable does not exist.\n   * \n   * @param name \n   * @returns \n   */\n  static get(name: string) {\n    return (this as any)[name];\n  }\n  /**\n   * Generic setter for environment variables. This allows to set environment variables dynamically by name.\n   * \n   * @param name \n   * @param value \n   */\n  static set(name: string, value: string) {\n    (this as any)[name] = value;\n  }\n\n} \n","import { A_CONSTANTS__DEFAULT_ENV_VARIABLES } from \"@adaas/a-concept/constants/env.constants\";\nimport { A_TYPES__ContextEnvironment } from \"@adaas/a-concept/a-context\";\nimport { A_CONCEPT_BASE_ENV } from \"./env.base\";\n\nexport class A_CONCEPT_ENV extends A_CONCEPT_BASE_ENV {\n    // ----------------------------------------------------------\n    // A-Concept Core Environment Variables\n    // ----------------------------------------------------------\n    // These environment variables are used by A-Concept core to configure the application\n    // ----------------------------------------------------------\n    /**\n     * Name of the application\n     * \n     * DEFAULT value is 'a-concept'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    static get A_CONCEPT_NAME() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_NAME] || super.A_CONCEPT_NAME\n    }\n    /**\n     * Root scope of the application\n     * \n     * DEFAULT value is 'root'\n     * \n     * [!] Provided name will be used for all aseids in the application by default\n     */\n    static get A_CONCEPT_ROOT_SCOPE() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_SCOPE] || super.A_CONCEPT_ROOT_SCOPE;\n    }\n    /**\n     * Environment of the application e.g. development, production, staging\n     */\n    static get A_CONCEPT_ENVIRONMENT() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ENVIRONMENT] || super.A_CONCEPT_ENVIRONMENT;\n    }\n    /**\n     * Runtime environment of the application e.g. browser, node\n     */\n    static get A_CONCEPT_RUNTIME_ENVIRONMENT(): A_TYPES__ContextEnvironment {\n        return 'server';\n    }\n\n    /**\n     * Root folder of the application\n     * [!] Automatically set by A-Concept when the application starts\n     */\n    static get A_CONCEPT_ROOT_FOLDER() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_CONCEPT_ROOT_FOLDER] || process.cwd();\n    }\n\n    /**\n     * Allows to define a default error description for errors thrown without a description\n     */\n    static get A_ERROR_DEFAULT_DESCRIPTION() {\n        return process.env[A_CONSTANTS__DEFAULT_ENV_VARIABLES.A_ERROR_DEFAULT_DESCRIPTION] || super.A_ERROR_DEFAULT_DESCRIPTION;\n    }\n\n    static get(name: string) {\n        return process.env[name] || (this as A_CONCEPT_ENV)[name as keyof typeof A_CONCEPT_ENV];\n    }\n\n    static set(name: string, value: string): void {\n        process.env[name] = value;\n    }\n} \n","import { A_Context } from '@adaas/a-concept/a-context';\nimport {\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from './A_Error.types';\nimport {\n    A_CONSTANTS__ERROR_CODES,\n    A_CONSTANTS__ERROR_DESCRIPTION\n} from './A_Error.constants';\nimport { A_FormatterHelper } from '@adaas/a-concept/helpers/A_Formatter.helper';\nimport { A_BasicTypeGuards } from '@adaas/a-concept/helpers/A_BasicTypeGuards.helper';\nimport { ASEID } from '@adaas/a-concept/aseid';\nimport { A_CONCEPT_ENV } from '@adaas/a-concept/env';\n\n\nexport class A_Error<\n    _ConstructorType extends A_TYPES__Error_Init = A_TYPES__Error_Init,\n    _SerializedType extends A_TYPES__Error_Serialized = A_TYPES__Error_Serialized\n> extends Error {\n    // ====================================================================\n    // ================== Static A-Error Information ======================\n    // ====================================================================\n    /**\n     * Error Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Namespace of the error from environment variable A_CONCEPT_NAMESPACE\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n    // ====================================================================\n    // ================== Hidden A-Error Information ======================\n    // ====================================================================\n    /**\n     * ASEID of the error instance\n     */\n    protected _aseid!: ASEID;\n    /**\n     * Title of the error\n     */\n    protected _title!: string;\n    /**\n     * Possible Scope if needed to identify the error by it's execution environment\n     */\n    protected _scope?: string;\n    /**\n     * Unique code representing the type of error\n     */\n    protected _code?: string;\n    /**\n     * Detailed description of the error\n     */\n    protected _description?: string;\n    /**\n     * Original Error if any\n     */\n    protected _originalError?: Error | any\n    /**\n     * Link to the documentation or support page for the error\n     */\n    protected _link?: string;\n\n\n\n    /**\n     * A_Error is a custom error class for A_Concept framework.\n     * This error allows to have more structured error handling.\n     * Each error has a unique code, description and a link to the documentation.\n     * \n     * Example of usage: \n     * ```typescript\n     * \n     * // 1) all parameters will be used as provided\n     * throw new A_Error({\n     *    message: 'User not found',\n     *    code: 'USER_NOT_FOUND',\n     *    description: 'The user with the given ID was not found.',\n     *    link: 'https://support.adaas.org/error/USER_NOT_FOUND'\n     * });\n     * \n     * // or\n     * // 2) only message is provided, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'User not found' (same as message)\n     * //     - link: Empty\n     * throw new A_Error('User not found');\n     * \n     * // or\n     * // 3) Provided Message and Description, other parameters will be set to default values:\n     * //     - code: 'user-not-found' (kebab-case of the message)\n     * //     - description: 'The user with the given ID was not found.' (as provided)\n     * //     - link: Empty\n     * throw new A_Error('User not found', 'The user with the given ID was not found.');\n     * \n     * \n     * ```\n     * [!] Note: The behavior of A_Error is similar to the A_Entity however it cannot have own A_Features.\n     * [!] Note: This class can be inherited to create custom error classes.\n     * \n     * @param message \n     */\n    constructor(\n        /**\n         * A_Error Constructor params\n         */\n        params: _ConstructorType\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        message: string\n    )\n    constructor(\n        /**\n         * Original JS Error\n         */\n        error: Error\n    )\n    constructor(\n        /**\n         * Original JS Error\n         */\n        error: unknown\n    )\n    constructor(\n        /**\n         * Error message\n         */\n        title: string,\n        /**\n         * Detailed description of the error\n         */\n        description: string\n    )\n    constructor(\n        param1: _ConstructorType | Error | string | A_Error | any,\n        param2?: string\n    ) {\n        //  to prevent errors accumulation in the stack trace it returns the original error if provided param1 is A_Error\n        switch (true) {\n            case param1 instanceof A_Error:\n                return param1 as A_Error<_ConstructorType, _SerializedType>;\n\n            case param1 instanceof Error:\n                super(param1.message);\n                break;\n\n            case A_BasicTypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                super(param1.message);\n                break;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1) && 'description' in param1:\n                super(`[${param1.title}]: ${param1.description}`);\n                break;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1) && !('description' in param1):\n                super(param1.title);\n                break;\n\n            case A_BasicTypeGuards.isString(param1) && !param2:\n                super(param1);\n                break;\n\n            case A_BasicTypeGuards.isString(param1) && !!param2:\n                super(`[${param1}]: ${param2}`);\n                break;\n\n            default:\n                super('An unknown error occurred.');\n        }\n\n        const initializer = this.getInitializer(param1, param2);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n\n\n    // ====================================================================\n    // ================== Public A-Error Information ======================\n    // ====================================================================\n    /**\n     * Returns the ASEID of the error instance\n     */\n    get aseid(): ASEID {\n        return this._aseid;\n    }\n    /**\n     * Returns the title of the error\n     * \n     * Example: 'User not found', 'Validation error', 'Unauthorized access', etc.\n     * \n     * [!] Note: This title should be short and concise, less than 60 characters\n     * [!] Note: If title exceeds 60 characters, there would be an error thrown\n     * [!] Note: This title is intended to be human-readable and can be displayed in UI or logs\n     */\n    get title(): string {\n        return this._title;\n    }\n    /**\n     * Returns an Error message what is a brief title of the error\n     * \n     */\n    get message(): string {\n        return super.message;\n    }\n    /**\n     * Returns a unique code representing the type of error\n     * \n     * If code is not provided, it will generate a kebab-case of the message\n     * \n     * Example: 'validation-error', 'not-found', 'user-not-found', 'unauthorized' etc.\n     * \n     * [!] Note: It is recommended to use kebab-case for error codes\n     * [!] Note: If not provided would be used a kebab-case message of the error\n     */\n    get code(): string {\n        return this._code || A_FormatterHelper.toKebabCase(this.title);\n    }\n    /**\n     * Returns the type of the error which corresponds to the static entity of the class\n     * \n     * Example: 'a-error', 'validation-error', 'not-found-error', 'user-error', etc.\n     * \n     * Defaults to the kebab-case of the class name\n     * \n     * [!] Note: naming ad separation are fully dependent on the architecture of the application\n     * [!] Note: It is recommended to use kebab-case for error types\n     * [!] Note: This type is intended to group similar errors together\n     */\n    get type() {\n        return (this.constructor as typeof A_Error).entity;\n    }\n    /**\n     * Returns a link with possible documentation or support page for the error\n     * If link is not provided, it will generate a link based on the ASEID of the error that points to the A-Concept support page\n     * \n     * Example: https://adaas.support/a-concept/errors/{ASEID}\n     * \n     * [!] Note: ASEID is generated based on the static properties of the class (concept, scope, entity) and the code of the error\n     */\n    get link() {\n        if (this._link)\n            return this._link;\n\n        const url = new URL(`https://adaas.support/a-concept/errors/${this.aseid.toString()}`);\n\n        return url.toString();\n    }\n    /**\n     * The scope name of the error instance\n     * \n     * If scope is not provided, it will use the static scope of the class\n     * \n     * [!] Note: Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    get scope() {\n        return this._aseid.scope\n    }\n    /**\n     * A detailed description of the error\n     * If description is not provided, it will use the environment variable A_ERROR_DEFAULT_DESCRIPTION or a generic message\n     * \n     * Example: 'The user with the given ID was not found.', 'The provided data is invalid.', 'You do not have permission to access this resource.', etc.\n     * \n     * [!] Note: This description is intended to provide more context about the error and can be used for debugging or logging purposes\n     */\n    get description(): string {\n        return this._description || String(A_CONCEPT_ENV.A_ERROR_DEFAULT_DESCRIPTION) || A_CONSTANTS__ERROR_DESCRIPTION;\n    }\n    /**\n     * Returns the original error if any\n     * \n     * This can be useful for debugging purposes to see the original stack trace or error message\n     * \n     * [!] Note: Original error is optional and may not be present in all cases\n     */\n    get originalError(): Error | any | undefined {\n        return this._originalError;\n    }\n\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1: _ConstructorType | Error | string | any,\n        param2?: string\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n\n            case A_BasicTypeGuards.isString(param1) && !param2:\n                return this.fromMessage;\n\n            case A_BasicTypeGuards.isString(param1) && !!param2:\n                return this.fromTitle;\n\n            case param1 instanceof Error:\n                return this.fromError;\n\n            case A_BasicTypeGuards.isErrorSerializedType<_SerializedType>(param1):\n                return this.fromJSON;\n\n            case A_BasicTypeGuards.isErrorConstructorType<_ConstructorType>(param1):\n                return this.fromConstructor;\n\n            default: {\n                throw new A_Error(\n                    A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                    'Invalid parameters provided to A_Error constructor'\n                );\n            }\n        }\n    }\n\n    /**\n     * Initializes the A_Error instance from a standard Error object.\n     * \n     * @param error \n     */\n    protected fromError(error: Error): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._originalError = error;\n    }\n    /**\n     * Initializes the A_Error instance from a message.\n     * \n     * @param title \n     * @param description \n     */\n    protected fromMessage(message: string): void {\n        this._title = A_CONSTANTS__ERROR_CODES.UNEXPECTED_ERROR;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a serialized object.\n     * \n     * @param serialized\n     */\n    protected fromJSON(serialized: _SerializedType): void {\n        this._aseid = new ASEID(serialized.aseid);\n        super.message = serialized.message;\n        this._title = serialized.title;\n        this._code = serialized.code;\n        this._scope = serialized.scope;\n        this._description = serialized.description;\n        // Note: originalError is deserialized as message only\n        this._originalError = serialized.originalError ? new A_Error(serialized.originalError) : undefined;\n        this._link = serialized.link;\n    }\n\n\n\n    fromTitle(title: string, description: string): void {\n        this.validateTitle(title);\n\n        this._title = title;\n        this._description = description;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._link = undefined;\n        this._originalError = undefined;\n    }\n    /**\n     * Initializes the A_Error instance from a constructor parameters object.\n     * \n     * @param params \n     */\n    protected fromConstructor(params: _ConstructorType): void {\n        this.validateTitle(params.title);\n\n        this._title = params.title;\n        this._code = params.code;\n        this._scope = params.scope ? (A_BasicTypeGuards.isScopeInstance(params.scope) ? (params.scope as any).name : params.scope) : undefined;\n\n        this._aseid = new ASEID({\n            concept: (this.constructor as typeof A_Error).concept,\n            scope: this._scope || (this.constructor as typeof A_Error).scope,\n            entity: (this.constructor as typeof A_Error).entity,\n            id: this.code\n        });\n\n        this._description = params.description;\n        this._link = params.link;\n\n        // Handle originalError: if it's an A_Error, we should trace back to the root cause\n        // to avoid infinite nesting of A_Error instances\n        if (params.originalError instanceof A_Error) {\n            // Find the root original error by traversing the chain\n            let rootError = params.originalError;\n            while (rootError.originalError instanceof A_Error) {\n                rootError = rootError.originalError;\n            }\n            // Set the root cause as the original error\n            this._originalError = rootError.originalError || rootError;\n        } else {\n            this._originalError = params.originalError;\n        }\n    }\n\n    /**\n     * Serializes the A_Error instance to a plain object.\n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString(),\n            title: this.title,\n            code: this.code,\n            type: this.type,\n            message: this.message,\n            link: this.link,\n            scope: this.scope,\n            description: this.description,\n            originalError: this.originalError?.message\n        } as _SerializedType;\n    }\n\n\n\n    // --------------------------------------------------------------------------\n    // ----------------------- PROTECTED HELPERS --------------------------------\n    // --------------------------------------------------------------------------\n    /**\n     * Checks if the provided title exceeds 60 characters.\n     * If it does, throws a validation A_Error.\n     * \n     * @param title \n     */\n    protected validateTitle(title: string) {\n        if (title.length > 60) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title exceeds 60 characters limit.'\n            );\n        }\n        if (title.length === 0) {\n            throw new A_Error(\n                A_CONSTANTS__ERROR_CODES.VALIDATION_ERROR,\n                'A-Error title cannot be empty.'\n            );\n        }\n    }\n}\n\n\n\n\n\n// message = title + description for better printing in the console\n// description = detailed information about the error\n// code = kebabcase (title)\n\n","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_EntityError extends A_Error {\n\n    /**\n     * Error code for validation errors.\n     */\n    static readonly ValidationError = 'A-Entity Validation Error';\n\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_TYPES__Entity_Serialized,\n    A_TYPES__Entity_Init,\n    A_TYPES__IEntity,\n} from \"./A-Entity.types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_FormatterHelper} from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_IdentityHelper} from \"@adaas/a-concept/helpers/A_Identity.helper\";\nimport {\n    ASEID,\n    A_TYPES__ASEID_Constructor\n} from \"@adaas/a-concept/aseid\";\nimport { A_EntityError } from \"./A-Entity.error\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\n\n\n/**\n * A_Entity is another abstraction that describes all major participants in the system business logic.\n * Each Entity should have a clear definition and a clear set of responsibilities. \n * However, entity may hide some of its responsibilities behind the interface to prevent overload. \n * \n * Each entity should be connected to the ContextFragment (Scope) and should be able to communicate with other entities.\n */\nexport class A_Entity<\n    _ConstructorType extends A_TYPES__Entity_Init = A_TYPES__Entity_Init,\n    _SerializedType extends A_TYPES__Entity_Serialized = A_TYPES__Entity_Serialized\n>\n    implements A_TYPES__IEntity {\n\n    // ====================================================================\n    // ================== Static A-Entity Information ============================\n    // ====================================================================\n    /**\n     * Entity Identifier that corresponds to the class name\n     */\n    static get entity(): string {\n        return A_FormatterHelper.toKebabCase(this.name);\n    }\n    /**\n     * DEFAULT Concept Name (Application Name) of the entity from environment variable A_CONCEPT_NAME\n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept(): string {\n        return A_Context.concept;\n    }\n    /**\n     * DEFAULT Scope of the entity from environment variable A_CONCEPT_DEFAULT_SCOPE\n     * [!] If environment variable is not set, it will default to 'core'\n     * [!] Scope is an application specific identifier that can be used to group entities together\n     * [!] e.g. 'default', 'core', 'public', 'internal', etc\n     */\n    static get scope(): string {\n        return A_Context.root.name;\n    }\n\n\n\n    // ====================================================================\n    // ================== Instance A-Entity Information ====================\n    // ====================================================================\n\n    /**\n     * ASEID is an entity identifier that is unique across the system\n     * A - A_Concept or Application\n     * S - System or Scope\n     * E - Entity\n     * ID - Identifier\n     * \n     * [!] ASEID is immutable and should not be changed after the entity is created\n     * \n     * [!] ASEID is composed of the following parts:\n     * - concept: an application specific identifier from where the entity is coming from\n     * - scope: the scope of the entity from concept\n     * - entity: the name of the entity from concept\n     * - id: the unique identifier of the entity\n     *\n     * [!] For more information about ASEID, please refer to the ASEID class documentation]\n     */\n    aseid!: ASEID;\n\n\n\n    /**\n     * Create a new A_entity instance from Aseid String\n     * e.g. project@scope:entity:0000000001\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID string that represents the entity\n         */\n        aseid?: string\n    )\n    /**\n     * Create a new A_entity instance from Aseid instance\n     * e.g. new ASEID({concept: 'project', scope: 'default', entity: 'entity', id: '0000000001'})\n     * \n     * @param aseid \n     */\n    constructor(\n        /**\n         * ASEID instance that represents the entity\n         */\n        aseid: ASEID\n    )\n    /**\n     * Create a new A_entity instance from serialized object\n     * \n     * @param serialized \n     */\n    constructor(\n        /**\n         * Serialized object that represents the entity\n         */\n        serialized: _SerializedType\n    )\n    /**\n     * Create a new A_entity instance from constructor object\n     * \n     * @param newEntity \n     */\n    constructor(\n        /**\n         * Constructor object that represents the entity\n         */\n        newEntity?: _ConstructorType\n    )\n    constructor(props?: string | ASEID | _SerializedType | _ConstructorType) {\n\n        const initializer = this.getInitializer(props);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, props);\n    }\n    // ====================================================================\n    // ================== DUPLICATED ASEID Getters ========================\n    // ====================================================================\n\n    /**\n     * Extracts the ID from the ASEID\n     * ID is the unique identifier of the entity\n     */\n    get id(): string | number {\n        return this.aseid.id;\n    }\n\n    // ====================================================================\n    // ================== Constructor Helpers =============================\n    // ====================================================================\n\n\n    // --- Type guards used to classify `props` properly ---\n    protected isStringASEID(x: unknown): x is string {\n        return typeof x === \"string\" && ASEID.isASEID(x);\n    }\n\n    protected isASEIDInstance(x: unknown): x is ASEID {\n        return x instanceof ASEID;\n    }\n\n    /**\n     * A \"serialized\" object is considered such if it is a non-null object \n     * and contains an \"aseid\" property (this mirrors your original check). \n     * \n     * @param x \n     * @returns \n     */\n    protected isSerializedObject(x: unknown): x is _SerializedType {\n        return !!x && typeof x === \"object\" && \"aseid\" in (x as object);\n    }\n\n    /**\n     * Constructor-style props = a plain object which does NOT contain \"aseid\".\n     * This is the \"create from provided fields\" case.\n     * \n     * @param x \n     * @returns \n     */\n    protected isConstructorProps(x: unknown): x is _ConstructorType {\n        return !!x && typeof x === \"object\" && !(\"aseid\" in (x as object));\n    }\n\n    /**\n     * Determines the appropriate initializer method based on the type of `props`.\n     * The method checks if `props` is:  \n     * 1) a string that matches ASEID format -> fromASEID\n     * 2) an ASEID instance -> fromASEID\n     * 3) a serialized object (has 'aseid') -> fromJSON\n     * 4) a plain object with no 'aseid' -> treat as constructor props -> fromNew\n     * \n     * [!] If `props` is undefined, it will call fromUndefined method\n     * \n     * If none of the above, it throws an error indicating incorrect constructor usage.\n     * \n     * \n     * To get a custom initializer, override this method in the child class.\n     * Example:\n     * ```typescript\n     * protected getInitializer(\n     *   props?: string | ASEID | _SerializedType | _ConstructorType\n     * ): (props: any) => void | (() => void) {\n     *   if('customField' in props) {\n     *       return this.fromCustomField.bind(this);\n     *   }\n     *   return super.getInitializer(props);\n     * }\n     * ```\n     * @param props\n     * @returns The appropriate initializer method\n     */\n    protected getInitializer(\n        props?: string | ASEID | _SerializedType | _ConstructorType\n    ): (props: any) => void | (() => void) {\n\n        if (!props) {\n            return this.fromUndefined\n        }\n\n        // 1) string that matches ASEID format -> fromASEID\n        if (this.isStringASEID(props)) {\n            return this.fromASEID as (p: string) => void;\n        }\n\n        // 2) ASEID instance -> fromASEID\n        if (this.isASEIDInstance(props)) {\n            return this.fromASEID as (p: ASEID) => void;\n        }\n\n        // 3) serialized object (has 'aseid') -> fromJSON\n        if (this.isSerializedObject(props)) {\n            return this.fromJSON as (p: _SerializedType) => void;\n        }\n\n        // 4) plain object with no 'aseid' -> treat as constructor props -> fromNew\n        if (this.isConstructorProps(props)) {\n            return this.fromNew as (p: _ConstructorType) => void;\n        }\n\n        // none of the above -> throw consistent error\n        throw new A_EntityError(A_EntityError.ValidationError, 'Unable to determine A-Entity constructor initialization method. Please check the provided parameters.');\n    }\n\n    /**\n     * Generates a new ASEID for the entity. \n     * It uses class definitions for concept, scope, and entity,\n     * and allows overriding any of these values.\n     * \n     * @param override \n     * @returns \n     */\n    protected generateASEID(override?: Partial<A_TYPES__ASEID_Constructor>): ASEID {\n        return new ASEID({\n            concept: override?.concept || (this.constructor as typeof A_Entity).concept,\n            scope: override?.scope || (this.constructor as typeof A_Entity).scope,\n            entity: override?.entity || (this.constructor as typeof A_Entity).entity,\n            id: override?.id || A_IdentityHelper.generateTimeId()\n        });\n    }\n\n\n    /**\n     * Call a feature of the component with the provided scope\n     * \n     * [!] If the provided scope is not inherited from the entity scope, it will be inherited\n     * \n     * @param lifecycleMethod \n     * @param args \n     */\n    async call(\n        feature: string,\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this,\n            scope\n        });\n\n        return await newFeature.process(scope);\n    }\n\n\n    // ====================================================================\n    // ================== Entity Base Methods =============================\n    // ====================================================================\n\n    /**\n     * The default method that can be called and extended to load entity data.\n     */\n    async load(\n        scope?: A_Scope,\n    ) {\n        return this.call('load', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to destroy entity data.\n     */\n    async destroy(scope?: A_Scope) {\n        return this.call('destroy', scope);\n    }\n\n    /**\n     * The default method that can be called and extended to save entity data.\n     */\n    async save(scope?: A_Scope) {\n        return this.call('save', scope);\n    }\n\n\n\n    // ====================================================================\n    // ================== Entity Serialization ============================\n    // ====================================================================\n\n    /**\n     * Create a new entity from ASEID string or instance\n     * [!] Executed when the constructor is called with a string or ASEID instance that represents the ASEID\n     * [!] Executes By Default with new A_Entity('aseid-string') or new A_Entity(new ASEID(...)) if getInitializer has not been overridden\n     * \n     * @param aseid \n     */\n    fromASEID(aseid: string | ASEID): void {\n        if (aseid instanceof ASEID)\n            this.aseid = aseid;\n        else\n            this.aseid = new ASEID(aseid);\n    }\n\n    /**\n     * Handles the case when no props are provided to the constructor.\n     * This method can be overridden in child classes to set default values or perform specific initialization logic.\n     * By default, it does nothing.\n     * \n     * \n     * @returns \n     */\n    fromUndefined(): void {\n        this.aseid = this.generateASEID();\n\n        return;\n    }\n\n    /**\n     * Create a new entity from constructor object\n     * [!] Executed when the constructor is called with an object that does not contain \"aseid\" property\n     * [!] Executes By Default with new A_Entity({}) if getInitializer has not been overridden\n     * \n     * @param newEntity \n     * @returns \n     */\n    fromNew(newEntity: _ConstructorType): void {\n        this.aseid = this.generateASEID();\n\n        return;\n    }\n\n\n    /**\n     * Creates a new entity from serialized object\n     * \n     * [!] Executed when the constructor is called with an object that contains \"aseid\" property\n     * [!] Executes By Default with new A_Entity({ aseid: '...' }) if getInitializer has not been overridden\n     * \n     * \n     * @param serialized \n     * @returns \n     */\n    fromJSON(serialized: _SerializedType): void {\n        this.aseid = new ASEID(serialized.aseid);\n        return;\n    }\n\n\n\n    /**\n     * Converts the entity to a JSON object \n     * [!] This method should be extended in the child classes to include all properties of the entity\n     * [!] Includes aseid by default \n     * \n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        return {\n            aseid: this.aseid.toString()\n        } as _SerializedType;\n    }\n\n\n    /**\n     * Returns the string representation of the entity\n     * what is basically the ASEID string\n     * \n     * @returns \n     */\n    toString(): string {\n        return this.aseid ? this.aseid.toString() : this.constructor.name;\n    }\n}","import { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"./A-Meta.class\";\nimport { A_TYPES__MetaLinkedComponentConstructors } from \"./A-Meta.types\";\n\n\n\n\n/**\n * \n * This decorator should allow to set a default meta type for the class, this helps to avoid\n * the need to create custom meta classes for each class.\n * \n * @returns \n */\nexport function A_MetaDecorator<T extends A_Meta>(\n    constructor: A_TYPES__Ctor<T>\n) {\n    return function <TTarget extends A_TYPES__MetaLinkedComponentConstructors>(\n        target: TTarget\n    ): TTarget {\n        // Store meta info on the target class itself for the Meta decorator to pick up\n        A_Context.setMeta(target, new constructor());\n\n        return target;\n    };\n}","import { A_MetaDecorator } from \"./A-Meta.decorator\";\nimport { A_TYPES__Meta_Constructor } from \"./A-Meta.types\";\n\n/**\n * A Meta is an entity that stores all the metadata for the specific entity like container, component, feature, etc. \n * \n * [!] Meta can be different depending on the type of input data\n */\nexport class A_Meta<\n    _StorageItems extends Record<any, any> = any,\n    _SerializedType extends Record<string, any> = Record<string, any>\n> implements Iterable<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n\n    /**\n     * Allows to set a custom meta class for the Component or Container or Entity, or anything else. \n     * \n     * @param target \n     * @returns \n     */\n    static Define<T extends A_Meta>(target: A_TYPES__Meta_Constructor<T>) {\n        return A_MetaDecorator(target);\n    }\n\n\n\n    protected meta: Map<keyof _StorageItems, _StorageItems[keyof _StorageItems]> = new Map();\n\n\n    /**\n     * Method to get the iterator for the meta object\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const iterator = this.meta.entries();\n        return {\n            next: () => iterator.next()\n        };\n    }\n\n\n\n    // ===================================================================================================\n    // ================================ META OPERATIONS ==================================================\n    // ===================================================================================================\n    /**\n     * Allows to replicate received meta object by replacing internal meta to the received one\n     * \n     * @param meta \n     * @returns \n     */\n    from(\n        meta: A_Meta<_StorageItems>\n    ): A_Meta<_StorageItems> {\n        this.meta = new Map(meta.meta);\n\n        return this;\n    }\n\n\n    /**\n     * Method to set values in the map\n     * \n     * @param key \n     * @param value \n     */\n    set<K extends keyof _StorageItems>(key: K, value: _StorageItems[K]) {\n\n        const inheritedValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? []\n            : (value as any) instanceof Map\n                ? new Map()\n                : {};\n        const targetValue = this.meta.get(key)\n            || Array.isArray(value)\n            ? [\n                ...inheritedValue as any\n            ] : (value as any) instanceof Map\n                ? new Map(inheritedValue as any)\n                : { ...inheritedValue };\n\n        this.meta.set(key, value);\n\n    }\n\n\n\n    /**\n     * Method to get values from the map\n     * \n     * @param key \n     * @returns \n     */\n    get<K extends keyof _StorageItems>(key: K): _StorageItems[K] | undefined {\n        return this.meta.get(key) as _StorageItems[K];\n    }\n\n\n    /**\n     * Method to delete values from the map\n     * \n     * @param key \n     * @returns \n     */\n    delete(key: keyof _StorageItems): boolean {\n        return this.meta.delete(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    size(): number {\n        return this.meta.size;\n    }\n\n\n    /**\n     * This method is needed to convert the key to a regular expression and cover cases like: \n     * \n     * simple * e.g. \"a*\" instead of \"a.*\"\n     * \n     * simple ? e.g. \"a?\" instead of \"a.\"\n     * \n     * etc. \n     * \n     * @param key \n     * @returns \n     */\n    private convertToRegExp(key: string | RegExp): RegExp {\n        return key instanceof RegExp\n            ? key\n            : new RegExp(key);\n    }\n\n\n    /**\n     * Method to find values in the map by name.\n     * \n     * Converts the Key in Map to a regular expression and then compares to the name\n     * \n     * @param name \n     * @returns \n     */\n    find(name: string) {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (this.convertToRegExp(String(key)).test(name)) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to find values in the map by regular expression\n     * \n     * Compares Map Key to the input regular expression\n     * \n     * @param regex \n     * @returns \n     */\n    findByRegex(regex: RegExp): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        const results: Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> = [];\n        for (const [key, value] of this.meta.entries()) {\n            if (regex.test(String(key))) {\n                results.push([key, value]);\n            }\n        }\n        return results;\n    }\n\n\n    /**\n     * Method to check if the map has a specific key\n     * \n     * @param key \n     * @returns \n     */\n    has(key: keyof _StorageItems): boolean {\n        return this.meta.has(key);\n    }\n\n\n    /**\n     * Method to get the size of the map\n     * \n     * @returns \n     */\n    entries(): IterableIterator<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return this.meta.entries();\n    }\n\n\n    /**\n     * Method to clear the map\n     */\n    clear(): void {\n        this.meta.clear();\n    }\n\n\n    toArray(): Array<[keyof _StorageItems, _StorageItems[keyof _StorageItems]]> {\n        return Array.from(this.meta.entries());\n    }\n\n\n    protected recursiveToJSON(value: any): any {\n        switch (true) {\n            case value instanceof A_Meta:\n                return value.toJSON();\n\n            case value instanceof Map:\n                const obj: Record<string, any> = {};\n                for (const [k, v] of value.entries()) {\n                    obj[String(k)] = this.recursiveToJSON(v);\n                }\n                return obj;\n\n            case Array.isArray(value):\n                return value.map((item) => this.recursiveToJSON(item));\n\n            case !!value && typeof value === 'object':\n                const res: Record<string, any> = {};\n                for (const [k, v] of Object.entries(value)) {\n                    res[k] = this.recursiveToJSON(v);\n                }\n                return res;\n\n            default:\n                return value;\n        }\n    }\n\n    /**\n     * Serializes the meta to a JSON object\n     * Uses internal storage to convert to JSON\n     * \n     * @returns \n     */\n    toJSON(): _SerializedType {\n        const json: Record<string, any> = {};\n\n        for (const [key, value] of this.meta.entries()) {\n            json[String(key)] = this.recursiveToJSON(value);\n        }\n        return json as _SerializedType;\n    }\n}","export enum A_TYPES__EntityMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    ABSTRACTIONS = 'a-component-abstractions',\n    INJECTIONS = 'a-component-injections',\n}\n\nexport enum A_TYPES__EntityFeatures {\n    SAVE = 'save',\n    DESTROY = 'destroy',\n    LOAD = 'load'\n}","import { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__EntityMeta } from \"./A-Entity.types\";\nimport { A_TYPES__EntityMetaKey } from \"./A-Entity.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\n\n\nexport class A_EntityMeta extends A_Meta<A_TYPES__EntityMeta> {\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__EntityMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__EntityMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_TYPES__Container_Init } from \"./A-Container.types\";\n\n\n\nexport class A_Container {\n\n    /**\n     * Configuration of the container that will be used to run it.\n     */\n    protected readonly config!: Partial<A_TYPES__Container_Init>;\n    /**\n     * Name of the container\n     */\n    get name() {\n        return this.config?.name || this.constructor.name;\n    }\n    /**\n     * Returns the scope where the container is registered\n     */\n    get scope(): A_Scope {\n        return A_Context.scope(this);\n    }\n\n\n    /**\n     * This class should combine Components to achieve the goal withing Concept\n     * \n     * Container is a direct container that should be \"run\" to make Concept work. \n     * So because of that Container can be:\n     * - HTTP Server\n     * - BASH Script\n     * - Database Connection\n     * - Microservice\n     * - etc.\n     * \n     * @param config - Configuration of the container that will be used to run it.\n     */\n    constructor(\n        /**\n         * Configuration of the container that will be used to run it.\n         */\n        config: Partial<A_TYPES__Container_Init> = {}\n    ) {\n        this.config = config;\n\n        A_Context.allocate(this, this.config);\n    }\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    async call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ) {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return await newFeature.process(scope);\n    }\n}","export enum A_TYPES__ContainerMetaKey {\n    FEATURES = 'a-container-features',\n    INJECTIONS = 'a-container-injections',\n    ABSTRACTIONS = 'a-container-abstractions',\n    EXTENSIONS  = 'a-container-extensions',\n}","import {\n    A_TYPES__ContainerMeta,\n    A_TYPES__ContainerMetaExtension,\n} from \"./A-Container.types\";\nimport { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\nimport {\n    A_TYPES__ConceptAbstractionMeta,\n    A_TYPES__ConceptAbstractions\n} from \"@adaas/a-concept/a-concept\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ContainerMetaKey } from \"./A-Container.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\n\n\n\nexport class A_ContainerMeta extends A_Meta<A_TYPES__ContainerMeta> {\n\n\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Returns all features defined in the Container\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ContainerMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Container during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: A_TYPES__ConceptAbstractions\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ContainerMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ContainerMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ContainerMetaExtension[] {\n        const steps: A_TYPES__ContainerMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ContainerMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override: ''\n\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\nimport { A_Stage } from \"@adaas/a-concept/a-stage\";\nimport { A_TYPES__FeatureError_Init } from \"./A-Feature.types\";\n\n\n\nexport class A_FeatureError extends A_Error<A_TYPES__FeatureError_Init> {\n\n    /**\n     * Indicates that the Feature has been interrupted\n     */\n    static readonly Interruption = 'Feature Interrupted';\n    /**\n     * Indicates that there was an error initializing the Feature\n     * \n     * Failed during the A-Feature initialization process\n     */\n    static readonly FeatureInitializationError = 'Unable to initialize A-Feature';\n    /**\n     * Indicates that there was an error processing the Feature\n     * \n     * Failed during the A-Feature processing\n     */\n    static readonly FeatureProcessingError = 'Error occurred during A-Feature processing';\n\n    // =======================================================================\n    // ---------------------- Decorator Errors -----------------------------\n    // =======================================================================\n    /**\n     * Indicates that there was an error defining the Feature\n     * \n     * Failed during the @A_Feature.Define() decorator execution\n     */\n    static readonly FeatureDefinitionError = 'Unable to define A-Feature';\n    /**\n     * Indicates that there was an error extending the Feature\n     * \n     * Failed during the @A_Feature.Extend() decorator execution\n     */\n    static readonly FeatureExtensionError = 'Unable to extend A-Feature';\n\n    \n    /**\n     * Stage where the error occurred\n     */\n    stage?: A_Stage\n\n\n    protected fromConstructor(params: A_TYPES__FeatureError_Init): void {\n        super.fromConstructor(params);\n\n        this.stage = params.stage;\n    }\n}","import { A_TYPES__DeepPartial } from \"@adaas/a-concept/types\";\n\nexport class A_CommonHelper {\n\n    /**\n     * A simple promise that resolves immediately.\n     * Can be used in async functions to create a resolved promise.\n     */\n    static resolve() {\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    /**\n     * Check if a class is inherited from another class\n     * \n     * @param childClass \n     * @param parentClass \n     * @returns \n     */\n    static isInheritedFrom(childClass: any, parentClass: any): boolean {\n        let current = childClass;\n\n        // Traverse the prototype chain\n        while (current) {\n            if (current === parentClass) {\n                return true;\n            }\n            current = Object.getPrototypeOf(current);\n        }\n        return false;\n    }\n\n\n    /**\n     * Get all parent classes of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClasses(childClass: any): any[] {\n\n        // first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        const parents = [] as any[];\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            parents.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return parents;\n\n    }\n\n    /**\n     * Get the class inheritance chain as an array of class names\n     * \n     * @param childClass \n     * @returns \n     */\n    static getClassInheritanceChain(childClass: any): any[] {\n\n        //  first we need to check is that a constructor or instance\n        let current = typeof childClass === 'function'\n            ? Object.getPrototypeOf(childClass)\n            : Object.getPrototypeOf(childClass.constructor);\n\n        //  then if input is instance we have to include its own class name\n        const chain = typeof childClass === 'function'\n            ? [childClass]\n            : [childClass.constructor];\n\n\n        // Traverse the prototype chain\n        while (current && current !== Function.prototype) {\n            chain.push(current);\n            current = Object.getPrototypeOf(current);\n        }\n        return chain;\n    }\n\n    /**\n     * Get the parent class of a given class\n     * \n     * @param childClass \n     * @returns \n     */\n    static getParentClass(childClass: any): any {\n        return Object.getPrototypeOf(childClass);\n    }\n\n    /**\n     *  Omit properties from an object or array with nested objects\n     * \n     * @param input \n     * @param paths \n     * @returns \n     */\n    static omitProperties<T, S extends string>(\n        input: T,\n        paths: string[]\n\n    ): Omit<T, S> {\n\n        // Deep clone the input object or array\n        const result = JSON.parse(JSON.stringify(input));\n\n        // Helper function to recursively remove properties\n        function removeProperties(target: Record<string, any> | any[], currPath: string[]) {\n            const currKey = currPath[0];\n            if (currPath.length === 1) {\n                // If current path has only one key, delete the property\n                delete target[currKey];\n            } else if (target[currKey] !== undefined && typeof target[currKey] === 'object') {\n                // If current key exists and is an object, recursively call removeProperties\n                removeProperties(target[currKey], currPath.slice(1));\n            }\n        }\n\n        // Iterate through each path and remove corresponding properties from the result\n        paths.forEach(path => {\n            const pathKeys = path.split('.');\n            removeProperties(result, pathKeys);\n        });\n\n        return result as Omit<T, S>;\n    }\n\n\n    static isObject(item: unknown): item is Record<string, any> {\n        return item !== null && typeof item === 'object' && !Array.isArray(item);\n    }\n\n    static deepMerge<T = any>(target: any, source: any, visited = new Map<any, any>()): T {\n        if (this.isObject(target) && this.isObject(source)) {\n            for (const key in source) {\n                if (this.isObject(source[key])) {\n                    if (!target[key]) {\n                        target[key] = {};\n                    }\n                    // Check if the source object has already been visited\n                    if (!visited.has(source[key])) {\n                        visited.set(source[key], {});\n                        this.deepMerge(target[key], source[key], visited);\n                    } else {\n                        target[key] = visited.get(source[key]);\n                    }\n                } else {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    }\n\n\n    static deepClone<T>(target: T): T {\n        // Check if the value is null or undefined\n        if (target === null || target === undefined) {\n            return target;\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target;\n        }\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepClone(item)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (target.hasOwnProperty(key)) {\n                    clone[key] = this.deepClone(target[key]);\n                }\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n\n    static deepCloneAndMerge<T>(target: A_TYPES__DeepPartial<T>, source: T): T {\n        if (\n            (source === null || source === undefined) &&\n            (target === null || target === undefined))\n            return target;\n\n        // Check if the value is null or undefined\n        if ((target === null || target === undefined) &&\n            source\n        ) {\n            return this.deepClone(source);\n        }\n\n        // Handle primitive types (string, number, boolean, etc.)\n        if (typeof target !== 'object') {\n            return target\n        }\n\n\n        // Handle Date\n        if (target instanceof Date) {\n            return new Date(target.getTime()) as T;\n        }\n\n        // Handle Array\n        if (Array.isArray(target)) {\n            return target.map(item => this.deepCloneAndMerge(item, source)) as unknown as T;\n        }\n\n        // Handle Function\n        if (typeof target === 'function') {\n            return target;\n        }\n\n        // Handle Object\n        if (target instanceof Object) {\n            const clone = {} as T;\n            for (const key in target) {\n                if (\n                    source[key] !== null\n                    &&\n                    source[key] !== undefined\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key as any], source[key]);\n                else\n                    clone[key as any] = this.deepClone(target[key]);\n            }\n\n            for (const key in source) {\n                if (\n                    target[key] !== undefined\n                    &&\n                    target[key] !== null\n                )\n                    clone[key] = this.deepCloneAndMerge(target[key], source[key]);\n                else\n                    clone[key] = this.deepClone(source[key]);\n            }\n            return clone;\n        }\n\n        // For any other cases\n        throw new Error('Unable to clone the object. Unsupported type.');\n    }\n\n    /**\n     * Get a readable name for a component (string, class, function, React element, instance, etc.)\n     *\n     * Covers:\n     * - string tags (\"div\")\n     * - symbols (Symbol.for('xxx'))\n     * - functions and classes (with name or displayName)\n     * - React elements (object with `type`)\n     * - component instances (constructor.name)\n     * - objects with custom toString returning meaningful info\n     *\n     * Falls back to sensible defaults (\"Unknown\" / \"Anonymous\").\n     */\n    static getComponentName(component: any): string {\n        const UNKNOWN = 'Unknown';\n        const ANONYMOUS = 'Anonymous';\n\n        if (component === null || component === undefined) {\n            return UNKNOWN;\n        }\n\n        // Strings (HTML tags or explicit names)\n        if (typeof component === 'string') {\n            return component || UNKNOWN;\n        }\n\n        // Symbols\n        if (typeof component === 'symbol') {\n            try {\n                return component.toString();\n            } catch {\n                return UNKNOWN;\n            }\n        }\n\n        // Arrays - try to derive from first element\n        if (Array.isArray(component)) {\n            if (component.length === 0) return UNKNOWN;\n            return this.getComponentName(component[0]);\n        }\n\n        // Functions and classes\n        if (typeof component === 'function') {\n            const fnAny = component as any;\n            // Common React convention\n            if (fnAny.displayName) return String(fnAny.displayName);\n            if (fnAny.name) return String(fnAny.name);\n\n            if (fnAny.constructor && fnAny.constructor.name) {\n                return String(fnAny.constructor.name);\n            }\n\n            // Try to extract a name from source if possible\n            try {\n                const src = Function.prototype.toString.call(component);\n                // class Foo { ... } or function foo() { ... } or foo => ...\n                const match = src.match(/^(?:class\\s+([A-Za-z0-9_$]+)|function\\s+([A-Za-z0-9_$]+)|([A-Za-z0-9_$]+)\\s*=>)/);\n                if (match) {\n                    return match[1] || match[2] || match[3] || ANONYMOUS;\n                }\n            } catch {\n                // fallthrough\n            }\n            return ANONYMOUS;\n        }\n\n        // Objects (instances, React elements, plain objects)\n        if (typeof component === 'object') {\n            const objAny = component as any;\n\n            // React element: { type: ComponentOrString, props: ... }\n            if (objAny.type) {\n                return this.getComponentName(objAny.type);\n            }\n\n            // React forwardRef / memo wrappers often expose displayName\n            if (objAny.displayName) return String(objAny.displayName);\n            if (objAny.name) return String(objAny.name);\n\n            // Instance: use constructor name if available and not Object\n            if (objAny.constructor && objAny.constructor.name && objAny.constructor.name !== 'Object') {\n                return String(objAny.constructor.name);\n            }\n\n            // If object implements a meaningful toString, try it\n            try {\n                const s = objAny.toString();\n                if (typeof s === 'string' && s !== '[object Object]') {\n                    return s;\n                }\n            } catch {\n                // ignore\n            }\n\n            return ANONYMOUS;\n        }\n\n        // Fallback for other types\n        try {\n            return String(component);\n        } catch {\n            return UNKNOWN;\n        }\n    }\n}","export class A_CallerError extends Error {\n\n    /**\n     * This error code indicates that there was an issue initializing the A-Caller\n     */\n    static readonly CallerInitializationError = 'Unable to initialize A-Caller';\n}","import { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_TYPES__FeatureAvailableComponents } from \"@adaas/a-concept/a-feature\";\nimport { A_CallerError } from \"./A_Caller.error\";\n\n\n\n/**\n * This is a common class that uses to return an entity that initiates a feature call\n * \n * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n * \n * [!] the class itself may be retrieved, but may require additional processing inside the feature\n * \n */\nexport class A_Caller<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    /**\n     * The component that initiated the feature call\n     */\n    protected _component: T;\n\n\n    /**\n     * A_Caller allows to get the component that initiated the feature call\n     * \n     * It can be used then in @A_Inject(A_Caller) to get the entity that initiated the feature call\n     * \n     * [!] If Scope is not provided, a new empty scope will be created and inherited from the global scope\n     * \n     * @param component \n     * @param scope \n     */\n    constructor(\n        component: T\n    ) {\n        this.validateParams(component);\n\n        this._component = component;\n    }\n\n    get component(): T {\n        return this._component;\n    }\n\n\n    /**\n     * Validates the provided parameters and Ensures that the component is of an allowed type\n     * \n     * @param component \n     */\n    protected validateParams(\n        component: T\n    ) {\n        if (!A_TypeGuards.isAllowedForFeatureCall(component)) {\n            throw new A_CallerError(\n                `[${A_CallerError.CallerInitializationError}]: Invalid A-Caller component provided of type: ${typeof component} with value: ${JSON.stringify(component).slice(0, 100)}...`\n            );\n        }\n    }\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_DependencyError extends A_Error {\n\n    static readonly InvalidDependencyTarget = 'Invalid Dependency Target';\n\n    static readonly InvalidLoadTarget = 'Invalid Load Target';\n\n    static readonly InvalidLoadPath = 'Invalid Load Path';\n\n\n    static readonly InvalidDefaultTarget = 'Invalid Default Target';\n\n\n    static readonly ResolutionParametersError = 'Dependency Resolution Parameters Error';\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_DefaultDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Default is required\n */\nexport function A_Dependency_Default(\n    /**\n     * Constructor Parameters that will be used to create the default instance\n     */\n    ...args: any[]\n): A_TYPES__A_Dependency_DefaultDecoratorReturn {\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDefaultTarget,\n                `A-Default cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            create: true,\n            args: args\n        }\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_FlatDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Flat(): A_TYPES__A_Dependency_FlatDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            flat: true,\n        }\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_LoadDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which Load is required\n */\nexport function A_Dependency_Load(\n\n): A_TYPES__A_Dependency_LoadDecoratorReturn {\n\n    // if (!path || typeof path !== 'string') {\n    //     throw new A_DependencyError(\n    //         A_DependencyError.InvalidLoadPath,\n    //         `A-Load decorator requires a valid path string to the dependency`\n    //     );\n    // }\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target);\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidLoadTarget,\n                `A-Load cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            load: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_ParentDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Parent(\n    /**\n     * Indicates how many layers up the parent dependency should be resolved from current dependency\n     * \n     * Default: -1 (one layer up)\n     */\n    layerOffset: number = -1\n): A_TYPES__A_Dependency_ParentDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n                \n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            parent: layerOffset\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_RequireDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n\n/**\n * Should indicate which dependency is required\n */\nexport function A_Dependency_Require(): A_TYPES__A_Dependency_RequireDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-Dependency cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            require: true\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\nimport { A_TYPES__A_Dependency_AllDecoratorReturn } from \"./A-Dependency.types\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__InjectableTargets\n} from \"@adaas/a-concept/a-inject\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * Should indicate which All is required\n */\nexport function A_Dependency_All(): A_TYPES__A_Dependency_AllDecoratorReturn {\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_DependencyError(\n                A_DependencyError.InvalidDependencyTarget,\n                `A-All cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex].resolutionStrategy = {\n            pagination: {\n                ...paramsArray[parameterIndex].resolutionStrategy.pagination,\n                count: -1\n            }\n        }\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}","import { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_Dependency_Default } from \"./A-Dependency-Default.decorator\";\nimport { A_Dependency_Flat } from \"./A-Dependency-Flat.decorator\";\nimport { A_Dependency_Load } from \"./A-Dependency-Load.decorator\";\nimport { A_Dependency_Parent } from \"./A-Dependency-Parent.decorator\";\nimport { A_Dependency_Require } from \"./A-Dependency-Require.decorator\";\nimport { A_DependencyError } from \"./A-Dependency.error\";\nimport {\n    A_TYPES__A_Dependency_EntityInjectionPagination,\n    A_TYPES__A_Dependency_EntityInjectionQuery,\n    A_TYPES__A_Dependency_Serialized,\n    A_TYPES__A_DependencyInjectable,\n    A_TYPES__A_DependencyResolutionStrategy\n} from \"./A-Dependency.types\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_Dependency_All } from \"./A-Dependency-All.decorator\";\n\n\nexport class A_Dependency<\n    T extends A_TYPES__A_DependencyInjectable = A_TYPES__A_DependencyInjectable\n> {\n    /**\n     * Allows to indicate which Injected parameter is required\n     * \n     * [!] If parameter marked as required is not provided, an error will be thrown\n     * \n     * @returns \n     */\n    static get Required(): typeof A_Dependency_Require {\n        return A_Dependency_Require;\n    }\n    /**\n     * Allows to indicate which dependency should be loaded from a specific path\n     * \n     * @returns \n     */\n    static get Loaded(): typeof A_Dependency_Load {\n        return A_Dependency_Load;\n    }\n    /**\n     * Allows to indicate which dependency default parameters should be used\n     * \n     * @returns \n     */\n    static get Default(): typeof A_Dependency_Default {\n        return A_Dependency_Default;\n    }\n    /**\n     * Allows to indicate which parent dependency should be resolved\n     * e.g. from which layer up the parent should be taken\n     * \n     * @returns \n     */\n    static get Parent(): typeof A_Dependency_Parent {\n        return A_Dependency_Parent;\n    }\n\n    /**\n     * Allows to indicate that the dependency should be resolved in a flat manner\n     * Only in the same scope, without going up to parent scopes\n     * \n     * @returns \n     */\n    static get Flat(): typeof A_Dependency_Flat {\n        return A_Dependency_Flat;\n    }\n\n    /**\n     * Allows to indicate that all instances of the dependency should be resolved\n     * \n     * @returns\n     */\n    static get All(): typeof A_Dependency_All {\n        return A_Dependency_All;\n    }\n\n    protected _name: string;\n    protected _target?: A_TYPES__Ctor<T>;\n    protected _resolutionStrategy!: A_TYPES__A_DependencyResolutionStrategy;\n\n    protected _defaultPagination: A_TYPES__A_DependencyResolutionStrategy['pagination'] = {\n        count: 1,\n        from: 'start',\n    };\n    protected _defaultResolutionStrategy: A_TYPES__A_DependencyResolutionStrategy = {\n        require: false,\n        load: false,\n        parent: 0,\n        flat: false,\n        create: false,\n        args: [],\n        query: {},\n        pagination: this._defaultPagination,\n    };\n\n    get flat(): boolean {\n        return this._resolutionStrategy.flat;\n    }\n    get require(): boolean {\n        return this._resolutionStrategy.require;\n    }\n    get load(): boolean {\n        return this._resolutionStrategy.load;\n    }\n    /**\n     * Indicates cases when it's necessary to search across all instances\n     */\n    get all(): boolean {\n        return this._resolutionStrategy.pagination.count !== 1 || Object.keys(this._resolutionStrategy.query).length > 0\n    }\n    get parent(): number {\n        return this._resolutionStrategy.parent;\n    }\n    get create(): any {\n        return this._resolutionStrategy.create;\n    }\n    get args(): any[] {\n        return this._resolutionStrategy.args;\n    }\n    get query(): Partial<A_TYPES__A_Dependency_EntityInjectionQuery<T>> {\n        return this._resolutionStrategy.query as Partial<A_TYPES__A_Dependency_EntityInjectionQuery<T>>;\n    }\n    get pagination(): A_TYPES__A_Dependency_EntityInjectionPagination {\n        return this._resolutionStrategy.pagination;\n    }\n\n\n\n\n    /**\n     * Class instances allows to identify dependencies by name and use them for better type checking\n     * \n     * @param name \n     */\n    constructor(\n        name: string | A_TYPES__Ctor<T>,\n        resolutionStrategy?: Partial<Omit<A_TYPES__A_DependencyResolutionStrategy<T>, 'pagination'> & { pagination: Partial<A_TYPES__A_Dependency_EntityInjectionPagination> }>\n    ) {\n        this._name = typeof name === 'string' ? name : A_CommonHelper.getComponentName(name);\n\n        this._target = typeof name === 'string' ? undefined : name;\n\n        this.resolutionStrategy = resolutionStrategy || {};\n\n        this.initCheck();\n    }\n\n    /**\n     * Gets the dependency name\n     * \n     * Can be identifier, url or any string value\n     * \n     * @returns \n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Returns the original class of the dependency if provided\n     * \n     */\n    get target(): A_TYPES__Ctor<T> | undefined {\n        return this._target;\n    }\n\n    /**\n     * Gets the dependency resolution strategy\n     */\n    get resolutionStrategy(): A_TYPES__A_DependencyResolutionStrategy<T> {\n        return this._resolutionStrategy!;\n    }\n\n    /**\n     * Sets the dependency resolution strategy\n     */\n    set resolutionStrategy(strategy: Partial<Omit<A_TYPES__A_DependencyResolutionStrategy<T>, 'pagination'> & { pagination: Partial<A_TYPES__A_Dependency_EntityInjectionPagination> }>) {\n        this._resolutionStrategy = {\n            ...this._defaultResolutionStrategy,\n            ...this._resolutionStrategy,\n            ...strategy,\n            pagination: {\n                ...this._defaultPagination,\n                ...(this._resolutionStrategy || {}).pagination,\n                ...(strategy.pagination || {})\n            },\n        };\n    }\n\n\n    /**\n     * Method for the parameters check and all input data before usage\n     * \n     * @returns \n     */\n    private initCheck(): this {\n        if (!this._resolutionStrategy) {\n            throw new A_DependencyError(\n                A_DependencyError.ResolutionParametersError,\n                `Resolution strategy parameters are not provided for dependency: ${this._name}`\n            );\n        }\n\n        return this;\n    }\n\n\n    /**\n     * Serializes the dependency to a JSON object\n     * \n     * @returns \n     */\n    toJSON(): A_TYPES__A_Dependency_Serialized<T> {\n        return {\n            name: this._name,\n            all: this.all,\n            require: this.require,\n            load: this.load,\n            parent: this.parent,\n            flat: this.flat,\n            create: this.create,\n            args: this.args,\n            query: this.query,\n            pagination: this.pagination,\n        }\n    }\n}\n\n\n\n","import { A_CommonHelper } from \"./A_Common.helper\";\nimport {\n    A_TYPES__Feature_Constructor,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureExtendDecoratorTarget\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_TYPES__Error_Constructor,\n    A_TYPES__Error_Init,\n    A_TYPES__Error_Serialized\n} from \"@adaas/a-concept/a-error\";\nimport {\n    A_Component,\n    A_ComponentMeta,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Container,\n    A_ContainerMeta,\n    A_TYPES__Container_Constructor\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Entity,\n    A_EntityMeta,\n    A_TYPES__Entity_Constructor\n} from \"@adaas/a-concept/a-entity\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_TYPES__Fragment_Constructor,\n    A_Fragment\n} from \"@adaas/a-concept/a-fragment\";\nimport {\n    A_Scope,\n    A_TYPES__Scope_Constructor,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES__ScopeLinkedConstructors\n} from \"@adaas/a-concept/a-scope\";\nimport {\n    A_Caller,\n    A_TYPES__Caller_Constructor\n} from \"@adaas/a-concept/a-caller\";\nimport { A_TYPES__AbstractionAvailableComponents } from \"@adaas/a-concept/a-abstraction\";\nimport { A_TYPES__InjectableTargets } from \"@adaas/a-concept/a-inject\";\nimport { ASEID } from \"@adaas/a-concept/aseid\";\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable\n} from \"@adaas/a-concept/a-dependency\";\n\n\n\nexport class A_TypeGuards {\n    // ===========================================================================\n    // ============================= BASE Type Guards ============================\n    // ===========================================================================\n    /**\n     * Check if value is a string\n     * \n     * @param value \n     * @returns \n     */\n    static isString(value: any): value is string {\n        return typeof value === 'string' || value instanceof String;\n    }\n    /**\n     * Check if value is a number\n     * \n     * @param value \n     * @returns \n     */\n    static isNumber(value: any): value is number {\n        return typeof value === 'number' && isFinite(value);\n    }\n    /**\n     * Check if value is a boolean\n     * \n     * @param value \n     * @returns \n     */\n    static isBoolean(value: any): value is boolean {\n        return typeof value === 'boolean';\n    }\n    /**\n     * Check if value is an array\n     * \n     * @param value \n     * @returns \n     */\n    static isArray(value: any): value is Array<any> {\n        return Array.isArray(value);\n    }\n    /**\n     * Check if value is an object\n     * \n     * @param value \n     * @returns \n     */\n    static isObject<T extends Object = Object>(value: any): value is T {\n        return value && typeof value === 'object' && !Array.isArray(value);\n    }\n    /**\n     * Check if value is a function\n     * \n     * @param value \n     * @returns \n     */\n    static isFunction(value: any): value is Function {\n        return typeof value === 'function';\n    }\n\n    static isUndefined(value: any): value is undefined {\n        return typeof value === 'undefined';\n    }\n\n    static isRegExp(value: any): value is RegExp {\n        return value instanceof RegExp;\n    }\n\n\n    // ===========================================================================\n    // ==========================A-Concept Type Guards ===========================\n    // ===========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Container\n     * \n     * @param ctor \n     * @returns \n     */\n    static isContainerConstructor(ctor: any): ctor is A_TYPES__Container_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Container);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Component\n     * \n     * @param ctor \n     * @returns \n     */\n    static isComponentConstructor(ctor: any): ctor is A_TYPES__Component_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Component);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFragmentConstructor(ctor: any): ctor is A_TYPES__Fragment_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Fragment);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity\n     * \n     * @param ctor \n     * @returns \n     */\n    static isEntityConstructor(ctor: any): ctor is A_TYPES__Entity_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Entity);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isScopeConstructor(ctor: any): ctor is A_TYPES__Scope_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Scope);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Scope\n     * \n     * @param ctor \n     * @returns \n     */\n    static isErrorConstructor(ctor: any): ctor is A_TYPES__Error_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, Error);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Feature\n     * \n     * @param ctor \n     * @returns \n     */\n    static isFeatureConstructor(ctor: any): ctor is A_TYPES__Feature_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Feature);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Caller\n     * \n     * @param ctor \n     * @returns \n     */\n    static isCallerConstructor(ctor: any): ctor is A_TYPES__Caller_Constructor {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Caller);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Dependency\n     * \n     * @param ctor \n     * @returns \n     */\n    static isDependencyConstructor<T extends A_TYPES__A_DependencyInjectable>(ctor: any): ctor is A_Dependency<T> {\n        return typeof ctor === 'function' && A_CommonHelper.isInheritedFrom(ctor, A_Dependency);\n    }\n    // ----------------------------------------------------------------------------\n    // Instance type guards\n    // ----------------------------------------------------------------------------\n    /**\n     * Type guard to check if the instance is of type A_Dependency\n     * \n     * @param instance \n     * @returns \n     */\n    static isDependencyInstance<T extends A_TYPES__A_DependencyInjectable>(instance: any): instance is A_Dependency<T> {\n        return instance instanceof A_Dependency;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Container\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerInstance(instance: any): instance is A_Container {\n        return instance instanceof A_Container;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Component\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentInstance(instance: any): instance is A_Component {\n        return instance instanceof A_Component;\n    }\n\n    /**\n     * Type guard to check if the instance is of type A_Feature\n     * \n     * @param instance \n     * @returns \n     */\n    static isFeatureInstance(instance: any): instance is A_Feature {\n        return instance instanceof A_Feature;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Fragment\n     * \n     * @param instance \n     * @returns \n     */\n    static isFragmentInstance(instance: any): instance is A_Fragment {\n        return instance instanceof A_Fragment;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Entity\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityInstance(instance: any): instance is A_Entity {\n        return instance instanceof A_Entity;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Scope\n     * \n     * @param instance \n     * @returns \n     */\n    static isScopeInstance(instance: any): instance is A_Scope {\n        return instance instanceof A_Scope;\n    }\n    /**\n     * Type guard to check if the instance is of type A_Error\n     * \n     * @param instance \n     * @returns \n     */\n    static isErrorInstance(instance: any): boolean {\n        return instance instanceof Error;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ComponentMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isComponentMetaInstance(instance: any): instance is A_ComponentMeta {\n        return instance instanceof A_ComponentMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_ContainerMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isContainerMetaInstance(instance: any): instance is A_ContainerMeta {\n        return instance instanceof A_ContainerMeta;\n    }\n    /**\n     * Type guard to check if the instance is of type A_EntityMeta\n     * \n     * @param instance \n     * @returns \n     */\n    static isEntityMetaInstance(instance: any): instance is A_EntityMeta {\n        return instance instanceof A_EntityMeta;\n    }\n\n\n\n    // ==========================================================================\n    // ========================= SPECIAL Type Guards =============================\n    // ===========================================================================\n    static hasASEID(value: any): value is A_Entity | { aseid: any } {\n        return value && typeof value === 'object' && 'aseid' in value && (A_TypeGuards.isEntityInstance(value) || A_TypeGuards.isErrorInstance(value));\n    }\n\n\n    static isConstructorAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedConstructors {\n        return A_TypeGuards.isContainerConstructor(target)\n            || A_TypeGuards.isFeatureConstructor(target);\n    }\n    static isInstanceAllowedForScopeAllocation(target: any): target is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isFeatureInstance(target);\n    }\n\n    static isConstructorAvailableForAbstraction(target: any): target is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isComponentInstance(target);\n    }\n\n\n    static isTargetAvailableForInjection(target: any): target is A_TYPES__InjectableTargets {\n        return A_TypeGuards.isComponentConstructor(target)\n            || A_TypeGuards.isComponentInstance(target)\n            || A_TypeGuards.isContainerInstance(target)\n            || A_TypeGuards.isEntityInstance(target)\n    }\n\n    static isAllowedForFeatureCall(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureDefinition(param: any): param is A_TYPES__FeatureAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForFeatureExtension(param: any): param is A_TYPES__FeatureExtendDecoratorTarget {\n        return A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n\n    static isAllowedForAbstractionDefinition(param: any): param is A_TYPES__AbstractionAvailableComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param);\n    }\n\n    static isAllowedForDependencyDefaultCreation(param: any): param is A_TYPES__Entity_Constructor | A_TYPES__Fragment_Constructor {\n        return A_TypeGuards.isFragmentConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Fragment)\n            || A_TypeGuards.isEntityConstructor(param)\n            || A_CommonHelper.isInheritedFrom(param, A_Entity)\n\n    }\n\n    /**\n     * Allows to check if the provided param is of constructor type.\n     * \n     * @param param \n     * @returns \n     */\n    static isErrorConstructorType<T extends A_TYPES__Error_Init>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"title\" in param;\n    }\n\n\n    static isErrorSerializedType<T extends A_TYPES__Error_Serialized>(param: any): param is T {\n        return !!param && A_TypeGuards.isObject(param) && !(param instanceof Error) && \"aseid\" in param && ASEID.isASEID(param.aseid);\n    }\n\n\n    static isPromiseInstance<T>(value: any): value is Promise<T> {\n        return value instanceof Promise;\n    }\n}","import {\n    A_TYPES__FeatureDefineDecoratorConfig,\n    A_TYPES__FeatureDefineDecoratorDescriptor,\n    A_TYPES__FeatureDefineDecoratorMeta,\n    A_TYPES__FeatureDefineDecoratorTarget\n} from \"./A-Feature.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_EntityMeta,\n    A_TYPES__EntityMetaKey\n} from \"@adaas/a-concept/a-entity\";\nimport {\n    A_ContainerMeta,\n    A_TYPES__ContainerMetaKey\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_ComponentMeta,\n    A_TYPES__ComponentMetaKey\n} from \"@adaas/a-concept/a-component\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * A-Feature decorator\n * \n * This decorator allows to define a custom lifecycle stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Feature and A-Feature decorators is that A-Feature methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\nexport function A_Feature_Define(\n    config: Partial<A_TYPES__FeatureDefineDecoratorConfig> = {}\n) {\n    return function (\n        target: A_TYPES__FeatureDefineDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureDefineDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureDefinitionError,\n                `A-Feature cannot be defined on the ${componentName} level`\n            );\n\n        const meta: A_EntityMeta | A_ContainerMeta | A_ComponentMeta = A_Context.meta(target.constructor as any);\n\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n        }\n\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            /**\n             * Where Key is the name of the feature\n             * \n             * Where value is the list of features\n             */\n            [Key: string]: A_TYPES__FeatureDefineDecoratorMeta\n        }> = meta.get(metaKey) || new A_Meta();\n\n\n        const name = config.name || propertyKey;\n        //  default to false\n        const invoke = config.invoke || false;\n\n\n        // Set the metadata of the method to define a custom Feature with name \n        existedMeta.set(propertyKey, {\n            name: `${target.constructor.name}.${name}`,\n            handler: propertyKey,\n            invoke: invoke,\n            template: config.template && config.template.length ? config.template.map(\n                item => ({\n                    ...item,\n                    before: item.before || '',\n                    after: item.after || '',\n                    behavior: item.behavior || 'sync',\n                    throwOnError: true,\n                    override: item.override || ''\n                })\n            ) : [],\n        });\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target.constructor as any)\n            .set(\n                metaKey,\n                existedMeta\n            );\n\n        const originalMethod = descriptor.value!;\n\n        // Wrap the original method to add the call to `call`\n        // this helps to automatically call the container/entity/component method when it's called\n        descriptor.value = function (...args: any[]) {\n\n            // Call the original method\n            if (!invoke)\n                return originalMethod.apply(this, args);\n            else\n                originalMethod.apply(this, args);\n\n            // Call your `call` with the function name\n            if (typeof (this as A_TYPES__FeatureDefineDecoratorTarget).call === \"function\" && invoke)\n                return (this as A_TYPES__FeatureDefineDecoratorTarget).call(name);\n\n        };\n\n        return descriptor;\n    };\n}","import { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport {\n    A_TYPES__FeatureExtendDecoratorConfig,\n    A_TYPES__FeatureExtendDecoratorDescriptor,\n    A_TYPES__FeatureExtendDecoratorScopeItem,\n    A_TYPES__FeatureExtendDecoratorTarget\n} from \"./A-Feature.types\";\nimport { A_TYPES__ComponentMetaKey } from \"@adaas/a-concept/a-component\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_TYPES__EntityMetaKey } from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__ContainerMetaKey } from \"@adaas/a-concept/a-container\";\n\n\n\n\n/**\n * A-Extend decorator\n * \n * This decorator allows to define a custom Extend stage for the Container.\n * These stages are executed in a container-specific order and can be extended by components that are injected into the container.\n * This approach allows to create a flexible and extendable architecture for the application.\n * \n * The main difference between the A-Extend and A-Extend decorators is that A-Extend methods can be inherited and overridden by child classes.\n * \n * \n * @param params \n * @returns \n */\n/**\n * Use regexp in case if you need more flexibility and control over the name of the method\n * \n * @param regexp \n */\nexport function A_Feature_Extend(\n    /**\n     * The regular expression to match the name of the Feature method to be extended\n     * \n     * Example:\n     * \n     * ```ts\n     *  @A_Feature.Extend(/.*\\.load/)\n     * ```\n     */\n    regexp: RegExp\n)\n/**\n * In this case the name configurations will be used as an input to get scope and name of target function\n * [!] Not that for all SCOPE will be used OR operator\n * \n * @param config \n */\nexport function A_Feature_Extend(\n    /**\n     * Configuration for the A-Feature-Extend decorator\n     */\n    config: Partial<A_TYPES__FeatureExtendDecoratorConfig>\n)\n/**\n * In this case the name of function will be used as a name of the Feature.\n * [!] AND it will be applicable for ANY element where the name is the same as the name of the function\n */\nexport function A_Feature_Extend()\nexport function A_Feature_Extend(\n    param1?: Partial<A_TYPES__FeatureExtendDecoratorConfig> | RegExp\n) {\n    return function (\n        target: A_TYPES__FeatureExtendDecoratorTarget,\n        propertyKey: string,\n        descriptor: A_TYPES__FeatureExtendDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isAllowedForFeatureExtension(target))\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be applied on the ${componentName} level`\n            );\n\n        let targetRegexp: RegExp;\n        let behavior: 'sync' | 'async' = 'sync';\n        let before: string = '';\n        let after: string = '';\n        let override: string = '';\n        let include: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let exclude: Array<A_TYPES__FeatureExtendDecoratorScopeItem> = [];\n        let throwOnError: boolean = true;\n        let metaKey;\n\n\n        switch (true) {\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.EXTENSIONS;\n                break;\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.EXTENSIONS\n                break;\n            case A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.EXTENSIONS\n                break;\n        }\n\n\n        switch (true) {\n            case A_TypeGuards.isRegExp(param1):\n                targetRegexp = param1;\n                break;\n\n            case !!param1 && typeof param1 === 'object':\n\n                if (Array.isArray(param1.scope))\n                    include = param1.scope;\n                else if (!!param1.scope && typeof param1.scope === 'object') {\n                    if (Array.isArray(param1.scope.include))\n                        include = param1.scope.include;\n                    if (Array.isArray(param1.scope.exclude))\n                        exclude = param1.scope.exclude;\n                }\n\n\n                targetRegexp = buildTargetRegexp(param1, include, exclude, propertyKey);\n\n                behavior = param1.behavior || behavior;\n                throwOnError = param1.throwOnError !== undefined ? param1.throwOnError : throwOnError;\n\n                before = A_TypeGuards.isArray(param1.before)\n                    ? new RegExp(`^${param1.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.before instanceof RegExp\n                        ? param1.before.source\n                        : ''\n                after = A_TypeGuards.isArray(param1.after)\n                    ? new RegExp(`^${param1.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.after instanceof RegExp\n                        ? param1.after.source\n                        : ''\n\n                override = A_TypeGuards.isArray(param1.override)\n                    ? new RegExp(`^${param1.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                    : param1.override instanceof RegExp\n                        ? param1.override.source\n                        : ''\n                break;\n\n            default:\n                targetRegexp = new RegExp(`^.*${propertyKey.replace(/\\./g, '\\\\.')}$`);\n                break;\n        }\n\n\n        const existedDefinitions = A_Context\n            .meta(target)\n            .get(metaKey);\n\n        // Get the existed metadata or create a new one\n        const meta = A_Context.meta(target)\n\n        const existedMeta = meta.get(metaKey)\n            ? new A_Meta().from(meta.get(metaKey)!)\n            : new A_Meta();\n\n        if (existedDefinitions\n            && existedDefinitions.size()\n            && existedDefinitions.has(propertyKey)\n            && existedDefinitions.get(propertyKey)!.invoke\n        ) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureExtensionError,\n                `A-Feature-Extend cannot be used on the method \"${propertyKey}\" because it is already defined as a Feature with \"invoke\" set to true. Please remove the A-Feature-Extend decorator or set \"invoke\" to false in the A-Feature decorator.`\n            );\n        }\n\n        const existedMetaValue = [\n            ...(existedMeta.get(targetRegexp.source) || [])\n        ];\n\n        //  ensure that other regexps are preserved\n        for (const [key, handlers] of existedMeta.entries()) {\n\n            const indexInAnother = handlers.findIndex(item => item.handler === propertyKey);\n\n            //  if the same handler exists in another regexp, remove it\n            if (key !== targetRegexp.source && indexInAnother !== -1) {\n                handlers.splice(indexInAnother, 1);\n                //  if no handlers left for this regexp, remove the regexp entry\n                if (handlers.length === 0) {\n                    existedMeta.delete(key);\n                } else {\n                    existedMeta.set(key, handlers);\n                }\n            }\n        }\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const extension = {\n            name: targetRegexp.source,\n            handler: propertyKey,\n            behavior,\n            before,\n            after,\n            throwOnError,\n            override\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = extension;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(extension);\n        }\n\n\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(targetRegexp.source, existedMetaValue);\n\n        //  Update the metadata of the container with the new Feature definition\n        A_Context\n            .meta(target)\n            .set(metaKey, existedMeta);\n    };\n}\n\n\n/**\n * Builds a target regular expression based on the provided parameters.\n * \n * @param param1 - The first parameter, which can be a string or an object.\n * @param include - An array of items to include in the regular expression.\n * @param exclude - An array of items to exclude from the regular expression.\n * @param propertyKey - The property key to use in the regular expression.\n * @returns A regular expression object.\n */\nexport function buildTargetRegexp(\n    param1: any,\n    include: any[],\n    exclude: any[],\n    propertyKey: string\n) {\n    const includePart = include.length\n        ? `(${include.map(el => el.name).join('|')})`\n        : `.*`;\n\n    const excludePart = exclude.length\n        ? `(?!${exclude.map(el => el.name).join('|')})`\n        : ``;\n\n    const pattern = param1.scope\n        ? `^${excludePart}${includePart}\\\\.${param1.name || propertyKey}$`\n        : `.*\\\\.${param1.name || propertyKey}$`;\n\n    return new RegExp(pattern);\n}","import type { A_Dependency } from \"@adaas/a-concept/a-dependency\"\n\n\n\nexport enum A_TYPES__A_Stage_Status {\n    /**\n     * The stage is currently being processed\n     */\n    PROCESSING = 'PROCESSING',\n    /**\n     * The stage has been completed\n     */\n    COMPLETED = 'COMPLETED',\n    /**\n     * The stage has failed\n     */\n    FAILED = 'FAILED',\n    /**\n     * The stage has been skipped\n     */\n    SKIPPED = 'SKIPPED',\n    /**\n     * The stage has been paused\n     */\n    // PAUSED = 'PAUSED',\n    /**\n     * The stage has been stopped\n     */\n    // STOPPED = 'STOPPED',\n    /**\n     * The stage has been started\n     */\n    // STARTED = 'STARTED',\n    /**\n     * The stage has been initialized\n     */\n    INITIALIZED = 'INITIALIZED',\n    /**\n     * The stage has been aborted\n     */\n    ABORTED = 'ABORTED'\n}\n\nexport type A_TYPES_StageExecutionBehavior = 'async' | 'sync'\n\n\nexport type A_TYPES__A_StageStep = {\n    /**\n     * The component to be called\n     */\n    dependency: A_Dependency,\n    /**\n     * The method to be called on the component\n     */\n    handler: string,\n    /**\n     * Original Feature Extension name\n     * \n     * [!] could be string or regex\n     * \n     */\n    name: string,\n\n    /**\n     * In case its async it will be executed independently from the main thread.\n     * \n     * [!] However, in case of sync, it will be executed in the main thread.in the order of the declaration.\n     * \n     */\n    behavior: A_TYPES_StageExecutionBehavior\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    before: string\n\n    /**\n     * Allows to define the order of the execution of the method.\n     * \n     * [!] In case the method has circular dependencies it will Throw an error.\n     * \n     */\n    after: string,\n\n    /**\n     * Indicates whether to throw an error if the step fails.\n     * \n     * [!] By default is true\n     */\n    throwOnError: boolean\n\n    /**\n     * \n     */\n    override: string\n}\n\n\n\nexport type A_TYPES__Stage_Serialized = {\n\n    /**\n     * The name of the stage\n     */\n    name: string,\n\n    /**\n     *  The status of the stage\n     * \n     */\n    status: A_TYPES__A_Stage_Status,\n\n\n}\n\n\n\nexport type A_TYPES__A_StageStepProcessingExtraParams = {\n    steps: A_TYPES__A_StageStep[]\n    filter: (step: A_TYPES__A_StageStep) => boolean\n}\n","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\nexport class A_StageError extends A_Error {\n\n    static readonly ArgumentsResolutionError = 'A-Stage Arguments Resolution Error';\n\n\n    static get CompileError(): string {\n        return 'Unable to compile A-Stage';\n    }\n\n}\n","import {\n    A_TYPES__A_Stage_Status,\n    A_TYPES__A_StageStep,\n    A_TYPES__Stage_Serialized\n} from \"./A-Stage.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport type { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport type { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_StageError } from \"./A-Stage.error\";\nimport { A_Error } from \"@adaas/a-concept/a-error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport type { A_TYPES__Container_Constructor } from \"@adaas/a-concept/a-container\";\nimport type { A_TYPES__Component_Constructor } from \"@adaas/a-concept/a-component\";\nimport type { A_TYPES__A_DependencyInjectable } from \"@adaas/a-concept/a-dependency\";\n\n\n\nexport class A_Stage {\n\n    /**\n     * The feature that owns this stage\n     */\n    private readonly _feature!: A_Feature;\n    /**\n     * Initial Instructions to process the stage\n     */\n    private readonly _definition!: A_TYPES__A_StageStep;\n    /**\n     * Possible errors during stage processing\n     */\n    private _error?: A_Error;\n    /**\n     * Indicates the current status of the stage\n     */\n    private _status: A_TYPES__A_Stage_Status = A_TYPES__A_Stage_Status.INITIALIZED;\n\n\n    /**\n     * A_Stage is a callable A_Function within A_Feature that should be run with specific parameters.\n     * [!] Depending on the Stage Definition type sync/async function can be executed correspondingly.\n     * \n     * A-Stage is a common object that uses to simplify logic and re-use of A-Feature internals for better composition. \n     */\n    constructor(\n        /**\n         * The feature that owns this stage\n         */\n        feature: A_Feature,\n        /**\n         * The step definitions of the stage\n         */\n        step: A_TYPES__A_StageStep\n    ) {\n        this._feature = feature;\n        this._definition = step;\n    }\n\n    /**\n     * Returns the name of the stage\n     */\n    get name(): string {\n        return this.toString();\n    }\n    /**\n     * Returns the definition of the stage\n     */\n    get definition(): A_TYPES__A_StageStep {\n        return this._definition;\n    }\n    /**\n     * Returns the current status of the stage\n     */\n    get status(): A_TYPES__A_Stage_Status {\n        return this._status;\n    }\n    /**\n     * Returns the feature that owns this stage\n     */\n    get feature(): A_Feature {\n        return this._feature;\n    }\n    /**\n     * Returns true if the stage is processed (completed, failed, or skipped)\n     */\n    get isProcessed(): boolean {\n        return this._status === A_TYPES__A_Stage_Status.COMPLETED\n            || this._status === A_TYPES__A_Stage_Status.FAILED\n            || this._status === A_TYPES__A_Stage_Status.SKIPPED;\n    }\n    /**\n     * Returns the error of the stage\n     */\n    get error(): A_Error | undefined {\n        return this._error;\n    }\n\n    /**\n     * Resolves the arguments of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected getStepArgs(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        let resolverConstructor: A_TYPES__Container_Constructor | A_TYPES__Component_Constructor =\n            (step.dependency.target as A_TYPES__Container_Constructor | A_TYPES__Component_Constructor)\n            || scope.resolveConstructor(step.dependency.name);\n\n        return A_Context\n            .meta(resolverConstructor)\n            .injections(step.handler)\n            .map(dependency => {\n                switch (true) {\n                    case A_TypeGuards.isCallerConstructor(dependency.target):\n                        return this._feature.caller.component;\n\n                    case A_TypeGuards.isFeatureConstructor(dependency.target):\n                        return this._feature;\n\n                    default: {\n                        return scope.resolve(dependency);\n                    }\n                }\n            })\n    }\n\n\n    /**\n     * Resolves the component of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected getStepComponent(\n        scope: A_Scope,\n        step: A_TYPES__A_StageStep\n    ) {\n        const { dependency, handler } = step;\n\n        let instance: A_TYPES__A_DependencyInjectable | undefined =\n            (scope.resolve(dependency) || this.feature.scope.resolve(dependency)) as A_TYPES__A_DependencyInjectable\n\n\n        if (!instance)\n            throw new A_StageError(\n                A_StageError.CompileError,\n                `Unable to resolve component ${dependency.name} from scope ${scope.name}`\n            );\n\n        if (!instance[handler])\n            throw new A_StageError(\n                A_StageError.CompileError,\n                `Handler ${handler} not found in ${instance.constructor.name}`\n            );\n\n        return instance;\n    }\n\n\n\n    /**\n     * Calls the handler of the step\n     * \n     * @param step \n     * @returns \n     */\n    protected callStepHandler(\n        step: A_TYPES__A_StageStep,\n        scope: A_Scope\n    ): {\n        handler: Function,\n        params: any[]\n    } {\n        // 1) Resolve component\n        const component = this.getStepComponent(scope, step);\n        // 2) Resolve arguments\n        const callArgs = this.getStepArgs(scope, step);\n\n        // 3) Call handler\n        return {\n            handler: component[step.handler].bind(component),\n            params: callArgs\n        }\n    }\n\n\n    skip() {\n        this._status = A_TYPES__A_Stage_Status.SKIPPED;\n    }\n\n\n    /**\n     * This method processes the stage by executing all the steps\n     * \n     * @param scope - Scope to be used to resolve the steps dependencies\n     */\n    process(\n        /**\n         * Scope to be used to resolve the steps dependencies\n         */\n        scope?: A_Scope,\n    ): Promise<void> | void {\n\n        const targetScope = A_TypeGuards.isScopeInstance(scope)\n            ? scope\n            : this._feature.scope;\n\n        if (!this.isProcessed) {\n            this._status = A_TYPES__A_Stage_Status.PROCESSING;\n\n            const { handler, params } = this.callStepHandler(this._definition, targetScope);\n\n            const result = handler(...params);\n\n            if (A_TypeGuards.isPromiseInstance(result)) {\n\n                return new Promise<void>(\n                    async (resolve, reject) => {\n                        try {\n                            await result;\n\n                            this.completed();\n\n                            return resolve();\n                        } catch (error) {\n                            const wrappedError = new A_Error(error as any);\n\n                            this.failed(wrappedError);\n\n                            if (this._definition.throwOnError) {\n                                return resolve();\n                            } else {\n                                return reject(wrappedError);\n                            }\n                        }\n                    });\n            } else {\n                this.completed();\n            }\n        }\n\n    }\n\n\n    // ==========================================\n    // ============ Status methods =============\n    // ==========================================\n\n    protected completed() {\n        this._status = A_TYPES__A_Stage_Status.COMPLETED;\n    }\n\n    protected failed(\n        error: Error | A_Error | any\n    ) {\n        this._error = new A_Error(error);\n\n        this._status = A_TYPES__A_Stage_Status.FAILED;\n    }\n\n\n\n    // ==========================================\n    // ============ Serialization ===============\n    // ==========================================\n    /**\n     * Serializes the stage to JSON\n     * \n     */\n    toJSON(): A_TYPES__Stage_Serialized {\n        return {\n            name: this.name,\n            status: this.status,\n        }\n    }\n\n    /**\n     * Returns a string representation of the stage\n     * \n     * @returns \n     */\n    toString() {\n        return `A-Stage(${this._feature.name}::${this._definition.behavior}@${this._definition.handler})`;\n    }\n}   ","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_StepManagerError extends A_Error {\n\n\n    static readonly CircularDependencyError = 'A-StepManager Circular Dependency Error';\n\n}","import type {\n    A_Feature,\n    A_TYPES__FeatureDefineDecoratorTemplateItem\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Stage,\n    A_TYPES__A_StageStep\n} from \"@adaas/a-concept/a-stage\";\nimport { A_StepManagerError } from \"./A-StepManager.error\";\n\nexport class A_StepsManager {\n\n    public entities: A_TYPES__A_StageStep[];\n    public graph: Map<string, Set<string>>;\n    public visited: Set<string>;\n    public tempMark: Set<string>;\n    public sortedEntities: string[];\n\n\n    private _isBuilt: boolean = false;\n\n    constructor(entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>) {\n        this.entities = this.prepareSteps(entities);\n\n        this.graph = new Map();\n        this.visited = new Set();\n        this.tempMark = new Set();\n        this.sortedEntities = [];\n\n    }\n\n    private prepareSteps(\n        entities: Array<A_TYPES__FeatureDefineDecoratorTemplateItem>\n    ): Array<A_TYPES__A_StageStep> {\n        return entities\n            .map(step => ({\n                ...step,\n\n                behavior: step.behavior || 'sync',\n                before: step.before || '',\n                after: step.after || '',\n                override: step.override || '',\n                throwOnError: false\n            }));\n    }\n\n    private ID(step: A_TYPES__A_StageStep) {\n        return `${step.dependency.name}.${step.handler}`;\n    }\n\n    private buildGraph() {\n        if (this._isBuilt) return;\n        this._isBuilt = true;\n\n        // Filter override\n        this.entities = this.entities\n            .filter((step, i, self) =>\n                !self.some(s => s.override ? new RegExp(s.override).test(this.ID(step)) : false)\n            );\n\n        // Initialize graph nodes\n        this.entities.forEach(entity => this.graph.set(this.ID(entity), new Set()));\n\n        // Add directed edges based on 'before' and 'after'\n        this.entities.forEach(entity => {\n            const entityId = this.ID(entity);\n\n            // Add edges for 'before' dependencies\n            // If entity should execute before targets, then targets depend on entity\n            // So we add edges: target -> entity (target depends on entity)\n            if (entity.before) {\n                const targets = this.matchEntities(entityId, entity.before);\n                targets.forEach(target => {\n                    if (!this.graph.has(target)) this.graph.set(target, new Set());\n                    this.graph.get(target)!.add(entityId); // target depends on entity\n                });\n            }\n\n            // Add edges for 'after' dependencies  \n            // If entity should execute after sources, then entity depends on sources\n            // So we add edges: entity -> source (entity depends on source)\n            if (entity.after) {\n                const sources = this.matchEntities(entityId, entity.after);\n\n                sources.forEach(source => {\n                    if (!this.graph.has(entityId)) this.graph.set(entityId, new Set());\n                    this.graph.get(entityId)!.add(source); // entity depends on source\n                });\n            }\n        });\n    }\n\n    // Match entities by name or regex\n    private matchEntities(entityId: string, pattern: string): string[] {\n        const regex = new RegExp(pattern);\n\n        return this.entities\n            .filter(entity => regex.test(this.ID(entity)) && this.ID(entity) !== entityId)\n            .map(entity => this.ID(entity));\n    }\n\n    // Topological sort with cycle detection\n    private visit(node: string): void {\n        if (this.tempMark.has(node)) {\n            return;\n            // TODO: maybe we have to keep this error but only for partial cases\n            throw new A_StepManagerError(\n                A_StepManagerError.CircularDependencyError,\n                `Circular dependency detected involving step: ${node}. Make sure that your 'before' and 'after' dependencies do not create cycles.`\n            );\n        }\n\n        if (!this.visited.has(node)) {\n            this.tempMark.add(node);\n\n\n            (this.graph.get(node) || []).forEach(neighbor => this.visit(neighbor));\n            this.tempMark.delete(node);\n            this.visited.add(node);\n            this.sortedEntities.push(node);\n\n            // // Visit neighbors in stable order (preserving original order)\n            // const neighbors = Array.from(this.graph.get(node) || []);\n            // // neighbors.sort((a, b) => {\n            // //     const orderA = this.originalOrder.get(a) || 0;\n            // //     const orderB = this.originalOrder.get(b) || 0;\n            // //     return orderA - orderB;\n            // // });\n\n            // neighbors.forEach(neighbor => this.visit(neighbor));\n            // this.tempMark.delete(node);\n            // this.visited.add(node);\n            // this.sortedEntities.push(node);\n        }\n    }\n\n\n    toSortedArray(): Array<string> {\n        this.buildGraph();\n\n        // Start topological sort\n        this.entities.forEach(entity => {\n            if (!this.visited.has(this.ID(entity))) this.visit(this.ID(entity));\n        });\n\n        return this.sortedEntities;\n    }\n\n    // Sort the entities based on dependencies\n    toStages(feature: A_Feature): Array<A_Stage> {\n\n\n        const sortedNames = this.toSortedArray();\n\n\n        // Map sorted names back to entity objects\n        return sortedNames\n            .map(id => {\n                const step = this.entities.find(entity => this.ID(entity) === id)!;\n\n\n                return new A_Stage(feature, step);\n            });\n    }\n}\n\n\n","import {\n    A_TYPES__Feature_Init,\n    A_TYPES__Feature_InitWithComponent,\n    A_TYPES__Feature_InitWithTemplate,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureState,\n} from \"./A-Feature.types\";\nimport { A_Feature_Define } from \"./A-Feature-Define.decorator\";\nimport { A_Feature_Extend } from \"./A-Feature-Extend.decorator\";\nimport {\n    A_Stage,\n    A_StageError\n} from \"@adaas/a-concept/a-stage\";\nimport { A_StepsManager } from \"@adaas/a-concept/a-step-manager\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FeatureError } from \"./A-Feature.error\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Caller } from \"@adaas/a-concept/a-caller\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_Component } from \"@adaas/a-concept/a-component\";\n\n\n/**\n * A_Feature is representing a feature that can be executed across multiple components\n * This class stores the steps of the feature and executes them in order of appearance\n * \n * Using A_Feature.Define and A_Feature.Extend decorators to define and extend the feature methods \n * across the different, distributed components\n * \n */\nexport class A_Feature<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents> {\n\n    // =============================================================================\n    // --------------------------- Static Methods ---------------------------------\n    // =============================================================================\n    /**\n     * Define a new A-Feature\n     */\n    static get Define(): typeof A_Feature_Define {\n        return A_Feature_Define;\n    }\n\n    /**\n     * Extend an existing A-Feature\n     */\n    static get Extend(): typeof A_Feature_Extend {\n        return A_Feature_Extend;\n    }\n    // =============================================================================\n    // --------------------------- Internal Properties ----------------------------\n    // =============================================================================\n    /**\n     * The name of the Feature\n     */\n    protected _name!: string;\n    /**\n     * List of stages that are part of this Feature\n     */\n    protected _stages: Array<A_Stage> = [];\n    /**\n     * The Stage currently being processed\n     */\n    protected _current?: A_Stage;\n    /**\n     * Actual Index of the current Stage being processed\n     */\n    protected _index: number = 0;\n    /**\n     * Steps Manager to organize the steps into stages\n     */\n    protected _SM!: A_StepsManager;\n    /**\n     * The Caller that initiated the Feature call\n     */\n    protected _caller!: A_Caller<T>;\n    /**\n     * The current state of the Feature\n     */\n    protected _state: A_TYPES__FeatureState = A_TYPES__FeatureState.INITIALIZED;\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    protected _error?: A_FeatureError\n\n\n\n    /**\n     * A-Feature is a pipeline distributed by multiple components that can be easily attached or detached from the scope. \n     * Feature itself does not have scope, but attached to the caller who dictates how feature should be processed. \n     * \n     * Comparing to A-Command Feature does not store any state except statuses for better analysis. \n     * \n     * [!] Note: If A-Feature should have result use A-Fragment \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Feature Initialization parameters\n         */\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        this.validateParams(params);\n\n        const initializer = this.getInitializer(params);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, params);\n    }\n\n\n    /**\n     * The name of the Feature\n     */\n    get name(): string { return this._name; }\n    /**\n     * The error that caused the Feature to be interrupted\n     */\n    get error(): A_FeatureError | undefined { return this._error; }\n    /**\n     * The current state of the Feature\n     */\n    get state(): A_TYPES__FeatureState { return this._state; }\n    /**\n     * Sets the current state of the Feature\n     */\n    get index(): number { return this._index; }\n    /**\n     * Returns the current A-Feature Stage\n     */\n    get stage(): A_Stage | undefined { return this._current; }\n    /**\n     * The Caller that initiated the Feature call\n     */\n    get caller(): A_Caller<T> { return this._caller; }\n    /**\n     * The Scope allocated for the Feature Execution\n     */\n    get scope(): A_Scope { return A_Context.scope(this); }\n    /**\n     * The number of stages in the feature\n     */\n    get size(): number {\n        return this._stages.length;\n    }\n\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.stage\n            || this._index >= this._stages.length;\n    }\n    /**\n     * Indicates whether the feature has been processed (completed, failed, or interrupted)\n     */\n    get isProcessed(): boolean {\n        return this.state === A_TYPES__FeatureState.COMPLETED\n            || this.state === A_TYPES__FeatureState.FAILED\n            || this.state === A_TYPES__FeatureState.INTERRUPTED;\n    }\n    /**\n     * Iterator to iterate over the steps of the feature\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<A_Stage, any> {\n        return {\n            next: (): IteratorResult<A_Stage, any> => {\n                if (!this.isDone) {\n                    this._current = this._stages[this._index];\n                    this._index++;\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    // ============================================================================\n    // ------------------------ Initialization Methods ----------------------------\n    // ============================================================================\n    /**\n     * Validates the provided parameters for A-Feature initialization\n     * \n     * @param params \n     */\n    protected validateParams(\n        params: A_TYPES__Feature_Init<T>\n    ) {\n        if (!params || typeof params !== 'object') {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n            );\n        }\n    }\n    /**\n     * Returns the appropriate initializer method based on the provided parameters\n     * \n     * @param params \n     * @returns \n     */\n    protected getInitializer(\n        params: A_TYPES__Feature_Init<T>\n    ): (param1: any) => void | (() => void) {\n\n        switch (true) {\n            case !('template' in params):\n                return this.fromComponent;\n\n            case 'template' in params:\n                return this.fromTemplate;\n            default:\n                throw new A_FeatureError(\n                    A_FeatureError.FeatureInitializationError,\n                    `Invalid A-Feature initialization parameters of type: ${typeof params} with value: ${JSON.stringify(params).slice(0, 100)}...`\n                );\n        }\n    }\n    /**\n     * Initializes the A-Feature from the provided template\n     * \n     * @param params \n     */\n    protected fromTemplate(\n        params: A_TYPES__Feature_InitWithTemplate<T>\n    ) {\n        if (!params.template || !Array.isArray(params.template)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature template provided of type: ${typeof params.template} with value: ${JSON.stringify(params.template).slice(0, 100)}...`\n            );\n        }\n\n        if (!params.component && (!params.scope || !(params.scope instanceof A_Scope))) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature scope provided of type: ${typeof params.scope} with value: ${JSON.stringify(params.scope).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            if (params.component)\n                componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        //   - Just to prevent issues with undefined caller in features without component\n        //   - TODO: maybe would be better to allow passing caller in params?\n        this._caller = new A_Caller<T>(params.component || new A_Component() as T);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(params.template);\n\n        // 7) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 8) set the first stage as current\n        this._current = this._stages[0];\n    }\n    /**\n     * Initializes the A-Feature from the provided component\n     * \n     * @param params \n     */\n    protected fromComponent(\n        params: A_TYPES__Feature_InitWithComponent<T>\n    ) {\n        if (!params.component || !A_TypeGuards.isAllowedForFeatureDefinition(params.component)) {\n            throw new A_FeatureError(\n                A_FeatureError.FeatureInitializationError,\n                `Invalid A-Feature component provided of type: ${typeof params.component} with value: ${JSON.stringify(params.component).slice(0, 100)}...`\n            );\n        }\n\n        // 1) save feature name\n        this._name = params.name;\n\n        // 2) get scope from where feature is called\n        let componentScope: A_Scope | undefined;\n        //  uses to extend a component scope if component is not registered in the context\n        let externalScope: A_Scope | undefined = params.scope;\n\n        try {\n            componentScope = A_Context.scope(params.component);\n        } catch (error) {\n            if (!externalScope)\n                throw error;\n        }\n\n        if (componentScope && externalScope && !externalScope.isInheritedFrom(componentScope)) {\n            externalScope.inherit(componentScope);\n        }\n\n        // 3) create caller wrapper for the simple injection of the caller component\n        this._caller = new A_Caller<T>(params.component);\n\n        // 4) allocate new scope for the feature\n        const scope = A_Context.allocate(this);\n\n        // 5) ensure that the scope of the caller component is inherited by the feature scope\n        scope.inherit(componentScope || externalScope!);\n\n        // 6) retrieve the template from the context\n        const template = A_Context.featureTemplate(this._name, this._caller.component, scope);\n\n        // 7) create steps manager to organize steps into stages\n        this._SM = new A_StepsManager(template);\n\n        // 8) create stages from the steps\n        this._stages = this._SM.toStages(this);\n\n        // 9) set the first stage as current\n        this._current = this._stages[0];\n    }\n\n\n    // ============================================================================\n    // ----------------------- Main Processing Methods ----------------------------\n    // ============================================================================\n    /**\n     * This method processes the feature by executing all the stages\n     * \n     */\n    process(\n        /**\n         * Optional scope to be used to resolve the steps dependencies\n         * If not provided, the scope of the caller component will be used\n         */\n        scope?: A_Scope,\n    ): Promise<void> | void {\n        try {\n            // It seems like this is a bad idea to enforce scope inheritance here\n            // ---------------------------------------------------------------\n            // if (scope && !scope.isInheritedFrom(A_Context.scope(this)))\n            //     scope.inherit(A_Context.scope(this));\n\n            if (this.isProcessed)\n                return;\n\n            this._state = A_TYPES__FeatureState.PROCESSING;\n\n            // Convert iterator to array to get all stages\n            const stages = Array.from(this);\n\n            return this.processStagesSequentially(stages, scope, 0);\n\n        } catch (error) {\n            throw this.failed(new A_FeatureError({\n                title: A_FeatureError.FeatureProcessingError,\n                description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${this.stage?.name || 'N/A'}.`,\n                stage: this.stage,\n                originalError: error\n            }));\n        }\n    }\n\n    /**\n     * Process stages one by one, ensuring each stage completes before starting the next\n     */\n    private processStagesSequentially(\n        stages: A_Stage[],\n        scope: A_Scope | undefined,\n        index: number\n    ): Promise<void> | void {\n        try {\n            // Check if feature has been interrupted before processing next stage\n            if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n                return;\n            }\n\n            // If we've processed all stages, complete the feature\n            if (index >= stages.length) {\n                this.completed();\n                return;\n            }\n\n            const stage = stages[index];\n            const result = stage.process(scope);\n\n            if (A_TypeGuards.isPromiseInstance(result)) {\n                // Async stage - return promise that processes remaining stages\n                return result\n                    .then(() => {\n                        // Check for interruption after async stage completes\n                        if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n                            return;\n                        }\n                        return this.processStagesSequentially(stages, scope, index + 1);\n                    })\n                    .catch(error => {\n                        throw this.failed(new A_FeatureError({\n                            title: A_FeatureError.FeatureProcessingError,\n                            description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${stage.name}.`,\n                            stage: stage,\n                            originalError: error\n                        }));\n                    });\n            } else {\n                // Sync stage - continue to next stage immediately\n                return this.processStagesSequentially(stages, scope, index + 1);\n            }\n        } catch (error) {\n            throw this.failed(new A_FeatureError({\n                title: A_FeatureError.FeatureProcessingError,\n                description: `An error occurred while processing the A-Feature: ${this.name}. Failed at stage: ${this.stage?.name || 'N/A'}.`,\n                stage: this.stage,\n                originalError: error\n            }));\n        }\n    }\n    /**\n     * This method moves the feature to the next stage\n     * \n     * @param stage \n     */\n    next(stage) {\n        const stageIndex = this._stages.indexOf(stage);\n\n        this._index = stageIndex + 1;\n\n        if (this._index >= this._stages.length) {\n            this.completed();\n        }\n    }\n    /**\n     * This method marks the feature as completed and returns the result\n     * Uses to interrupt or end the feature processing\n     * \n     * @param result \n     * @returns \n     */\n    completed(): void {\n        if (this.isProcessed) return;\n\n        // Don't complete if interrupted\n        if (this.state === A_TYPES__FeatureState.INTERRUPTED) {\n            return;\n        }\n\n        this._state = A_TYPES__FeatureState.COMPLETED;\n\n        this.scope.destroy();\n    }\n    /**\n     * This method marks the feature as failed and returns the error\n     * Uses to mark the feature as failed\n     * \n     * @param error \n     * @returns The error that caused the failure\n     */\n    failed(error: A_FeatureError): A_FeatureError {\n        if (this.isProcessed) return this._error!;\n\n        this._state = A_TYPES__FeatureState.FAILED;\n\n        this._error = error;\n\n        this.scope.destroy();\n\n        return this._error;\n    }\n    /**\n     * This method marks the feature as interrupted and throws an error\n     * Uses to interrupt or end the feature processing\n     * \n     * @param error \n     */\n    interrupt(\n        /**\n         * The reason of feature interruption\n         */\n        reason?: string | A_StageError | Error\n    ): A_FeatureError {\n        if (this.isProcessed) return this._error!;\n\n        this._state = A_TYPES__FeatureState.INTERRUPTED;\n\n        switch (true) {\n            case A_TypeGuards.isString(reason):\n                this._error = new A_FeatureError(A_FeatureError.Interruption, reason as string);\n                break;\n\n            case A_TypeGuards.isErrorInstance(reason):\n                this._error = new A_FeatureError({\n                    code: A_FeatureError.Interruption,\n                    title: (reason as any).title || 'Feature Interrupted',\n                    description: (reason as any).description || (reason as Error).message,\n                    stage: this.stage,\n                    originalError: reason\n                });\n                break;\n\n            default:\n                this._error = new A_FeatureError(A_FeatureError.Interruption, 'Feature was interrupted');\n                break;\n        }\n\n        this.scope.destroy();\n\n        return this._error;\n    }\n\n\n    /**\n     * Allows to chain the feature to another feature. \n     * In this case the parent feature scope (if new not provided), stages, caller will be used.\n     * \n     * [!] Note: Chained feature will use the same caller as the parent feature.\n     * \n     * @param feature \n     */\n    chain(\n        /**\n         * A Feature to be chained\n         */\n        feature: A_Feature,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        /**\n         * Component whose feature should be chained\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * A Feature Name to be chained\n         */\n        feature: string,\n        /**\n         * Optional scope to be used for the chained feature.\n         */\n        scope?: A_Scope\n    )\n    chain<T extends A_TYPES__FeatureAvailableComponents = A_TYPES__FeatureAvailableComponents>(\n        param1: A_TYPES__FeatureAvailableComponents | A_Feature,\n        param2?: string | A_Scope,\n        param3?: A_Scope\n    ) {\n        let feature: A_Feature;\n        let scope: A_Scope | undefined;\n\n        if (param1 instanceof A_Feature) {\n            feature = param1;\n            scope = param2 instanceof A_Scope ? param2 : undefined;\n        } else {\n            feature = new A_Feature({\n                name: param2 as string,\n                component: param1 as T\n            });\n            scope = param3 instanceof A_Scope ? param3 : undefined;\n        }\n\n        const featureScope = scope || this.scope;\n\n        // create new caller for the chained feature\n        feature._caller = this._caller;\n\n        const result = feature.process(featureScope);\n\n        // If the chained feature processing returns a promise, ensure errors are propagated\n        if (A_TypeGuards.isPromiseInstance(result)) {\n            return result.catch(error => {\n                // Re-throw to ensure chained feature errors propagate to caller\n                throw error;\n            });\n        }\n\n        return result;\n    }\n\n\n\n\n    toString(): string {\n        return `A-Feature(${this.caller.component?.constructor?.name || 'Unknown'}::${this.name})`;\n    }\n}","import { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\n\n\n\n/**\n * A-Component is a primary \"extendable\" object in the system\n * A unique combination of Components creates completely new functionality\n * \n * The most important thing is that A-Component is STATELESS, it means that it doesn't store any state in itself\n * \n * \n * [!] Every A-Component is a singleton, so if you need to create multiple instances of the same logic - use A-Container\n * [!] So one scope can have only one instance of the same A-Component\n * [!] Every A-Component can be extended by features and extensions\n * [!] ONLY A-Component can have A-Feature extensions\n *\n */\nexport class A_Component {\n\n\n    /**\n     * Calls the feature with the given name in the given scope\n     * \n     * [!] Note: This method creates a new instance of the feature every time it is called\n     * \n     * @param feature - the name of the feature to call\n     * @param scope  - the scope in which to call the feature\n     * @returns  - void\n     */\n    call(\n        /**\n         * Name of the feature to call\n         */\n        feature: string,\n        /**\n         * Scope in which the feature will be executed\n         */\n        scope?: A_Scope\n    ): Promise<any> | void {\n        const newFeature = new A_Feature({\n            name: feature,\n            component: this\n        });\n\n        return newFeature.process(scope);\n    }\n}\n\n\n\n","\n\n\nexport enum A_TYPES__ComponentMetaKey {\n    EXTENSIONS = 'a-component-extensions',\n    FEATURES = 'a-component-features',\n    INJECTIONS = 'a-component-injections',\n    ABSTRACTIONS = 'a-component-abstractions',\n}","import { A_TYPES__A_InjectDecorator_Meta } from \"@adaas/a-concept/a-inject\";\nimport { A_TYPES__ConceptAbstractionMeta } from \"@adaas/a-concept/a-concept\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_TYPES__ComponentMeta, A_TYPES__ComponentMetaExtension } from \"./A-Component.types\";\nimport { A_TYPES__ComponentMetaKey } from \"./A-Component.constants\";\nimport { A_TYPES__FeatureDefineDecoratorMeta } from \"@adaas/a-concept/a-feature\";\n\n\nexport class A_ComponentMeta<T extends A_TYPES__ComponentMeta = A_TYPES__ComponentMeta> extends A_Meta<T> {\n\n    /**\n     * Allows to get all the injections for a given handler\n     * \n     * @param handler \n     * @returns \n     */\n    injections(\n        handler: string\n    ): A_TYPES__A_InjectDecorator_Meta {\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        const args = injections?.get(handler) || [];\n\n        return args;\n    }\n\n    /**\n     * Allows to get all the extensions for a given feature\n     * \n     * @param feature \n     * @returns \n     */\n    extensions(\n        feature: string\n    ): A_TYPES__ComponentMetaExtension[] {\n        const steps: A_TYPES__ComponentMetaExtension[] = [];\n\n        const extensions = this.get(A_TYPES__ComponentMetaKey.EXTENSIONS);\n\n        extensions\n            // returns all extensions that match the feature\n            ?.find(feature)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    steps.push({\n                        // component: constructor,\n                        name: extension.name,\n                        handler: extension.handler,\n                        behavior: extension.behavior,\n                        before: extension.before || '',\n                        after: extension.after || '',\n                        throwOnError: extension.throwOnError || true,\n                        override: ''\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n\n    /**\n     * Returns all features defined in the Component\n     * \n     * @returns \n     */\n    features(): Array<A_TYPES__FeatureDefineDecoratorMeta> {\n\n        const features = this.get(A_TYPES__ComponentMetaKey.FEATURES);\n\n        return features?.toArray()\n            // returns all extensions that match the feature\n            .map(([, feature]) => feature) || [];\n    }\n\n    /**\n     * Returns a set of instructions to run proper methods in Component during A-Concept Stage\n     * \n     * @param stage \n     * @returns \n     */\n    abstractions(\n        abstraction: any\n    ): A_TYPES__ConceptAbstractionMeta[] {\n        const steps: A_TYPES__ConceptAbstractionMeta[] = [];\n\n        const abstractions = this.get(A_TYPES__ComponentMetaKey.ABSTRACTIONS);\n        const injections = this.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n        abstractions\n            // returns all extensions that match the feature\n            ?.find(`CONCEPT_ABSTRACTION::${abstraction}`)\n            .forEach(([handler, extensions]) => {\n                extensions.forEach(extension => {\n                    const args = injections?.get(extension.handler) || [];\n\n                    steps.push({\n                        ...extension,\n                        // component: constructor,\n                        args,\n                    });\n\n                });\n            });\n\n\n        return steps;\n    }\n}","import {\n    A_TYPES__ScopeConfig,\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES__Scope_Constructor,\n    A_TYPES__ScopeLinkedConstructors\n} from './A-Scope.types'\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport {\n    A_Component,\n    A_TYPES__Component_Constructor,\n    A_TYPES__ComponentMetaKey\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Entity,\n    A_TYPES__Entity_Constructor\n} from \"@adaas/a-concept/a-entity\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FormatterHelper} from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport {\n    A_Error,\n    A_TYPES__Error_Constructor\n} from \"@adaas/a-concept/a-error\";\nimport { A_ScopeError } from '@adaas/a-concept/a-scope';\nimport { A_Meta } from '@adaas/a-concept/a-meta';\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable\n} from '@adaas/a-concept/a-dependency';\nimport { A_TYPES__Ctor } from '@adaas/a-concept/types';\nimport { ASEID } from '@adaas/a-concept/aseid';\n\n\n\n\nexport class A_Scope<\n    _MetaItems extends Record<string, any> = any,\n    _ComponentType extends A_TYPES__Component_Constructor[] = A_TYPES__Component_Constructor[],\n    _ErrorType extends A_TYPES__Error_Constructor[] = A_TYPES__Error_Constructor[],\n    _EntityType extends A_TYPES__Entity_Constructor[] = A_TYPES__Entity_Constructor[],\n    _FragmentType extends A_Fragment[] = A_Fragment[],\n> {\n\n    /**\n     * Scope Name uses for identification and logging purposes\n     */\n    protected _name!: string;\n    /**\n     * Parent scope reference, used for inheritance of components, fragments, entities and commands\n     */\n    protected _parent?: A_Scope;\n    /**\n     * Internal meta storage using A_Meta for type-safe key-value operations.\n     * This stores all the scope's runtime data that can be accessed and modified\n     * throughout the execution pipeline or within running containers.\n     */\n    protected _meta: A_Meta<_MetaItems> = new A_Meta<_MetaItems>();\n\n    // ===========================================================================\n    // --------------------ALLowed Constructors--------------------------------\n    // ===========================================================================\n    /**\n     * A set of allowed components, A set of constructors that are allowed in the scope\n     *      \n     */\n    protected _allowedComponents = new Set<_ComponentType[number]>();\n    /**\n     * A set of allowed errors, A set of constructors that are allowed in the scope\n     */\n    protected _allowedErrors = new Set<_ErrorType[number]>();\n    /**\n     * A set of allowed entities, A set of constructors that are allowed in the scope\n     */\n    protected _allowedEntities = new Set<_EntityType[number]>();\n    /**\n     * A set of allowed fragments, A set of constructors that are allowed in the scope\n     */\n    protected _allowedFragments = new Set<A_TYPES__Fragment_Constructor<_FragmentType[number]>>();\n\n\n\n    // ===========================================================================\n    // --------------------Internal Storage--------------------------------\n    // ===========================================================================\n    /**\n     * Storage for the components, should be strong as components are unique per scope\n     */\n    protected _components: Map<_ComponentType[number], InstanceType<_ComponentType[number]>> = new Map();\n    /**\n     * Storage for the errors, should be strong as errors are unique per code\n     */\n    protected _errors: Map<string, InstanceType<_ErrorType[number]>> = new Map();\n    /**\n     * Storage for the entities, should be strong as entities are unique per aseid\n     */\n    protected _entities: Map<string, InstanceType<_EntityType[number]>> = new Map();\n    /**\n     * Storage for the fragments, should be weak as fragments are singletons per scope\n     */\n    protected _fragments: Map<A_TYPES__Fragment_Constructor<_FragmentType[number]>, _FragmentType[number]> = new Map();\n    /**\n     * Storage for imported scopes \n     */\n    protected _imports: Set<A_Scope> = new Set();\n\n\n\n    // ===========================================================================\n    // --------------------Readonly Allowed Properties----------------------------\n    // ===========================================================================\n    /**\n     * Returns the name of the scope\n     */\n    get name() { return this._name }\n    /**\n     * Returns the meta object of the scope\n     */\n    get meta() { return this._meta }\n    /**\n     * Returns a list of Constructors for A-Components that are available in the scope\n     */\n    get allowedComponents() { return this._allowedComponents }\n    /**\n     * Returns a list of Constructors for A-Entities that are available in the scope\n     */\n    get allowedEntities() { return this._allowedEntities }\n    /**\n     * Returns a list of Constructors for A-Fragments that are available in the scope\n     */\n    get allowedFragments() { return this._allowedFragments }\n    /**\n     * Returns a list of Constructors for A-Errors that are available in the scope\n     */\n    get allowedErrors() { return this._allowedErrors }\n    // ===========================================================================\n    // --------------------Readonly Registered Properties--------------------------\n    // ===========================================================================\n    /**\n     * Returns an Array of entities registered in the scope\n     * \n     * [!] One entity per aseid\n     */\n    get entities(): Array<InstanceType<_EntityType[number]>> { return Array.from(this._entities.values()) }\n    /**\n     * Returns an Array of fragments registered in the scope\n     * \n     * [!] One fragment per scope\n     */\n    get fragments(): Array<_FragmentType[number]> { return Array.from(this._fragments.values()) }\n    /**\n     * Returns an Array of components registered in the scope\n     * \n     * [!] One component instance per scope\n     */\n    get components(): Array<InstanceType<_ComponentType[number]>> { return Array.from(this._components.values()) }\n    /**\n     * Returns an Array of errors registered in the scope\n     * \n     * [!] One error per code\n     */\n    get errors(): Array<InstanceType<_ErrorType[number]>> { return Array.from(this._errors.values()) }\n    /**\n     * Returns an Array of imported scopes\n     * [!] Imported scopes are scopes that have been imported into the current scope using the import() method\n     */\n    get imports(): Array<A_Scope> { return Array.from(this._imports.values()) }\n\n    /**\n     * Returns the parent scope of the current scope\n     * \n     * @param setValue \n     * @returns \n     */\n    get parent(): A_Scope | undefined {\n        return this._parent;\n    }\n    /**\n     * A_Scope refers to the visibility and accessibility of :\n     * - variables, \n     * - Components, \n     * - Context Fragments \n     * - Entities\n     * - and objects in different parts of your code. \n     * Scope determines where a particular piece of data (like a variable or function) \n     * can be accessed, modified, or referenced, and it plays a crucial role in avoiding naming collisions and ensuring data integrity. \n     * \n     * [!] The scope behavior is similar to tree structure where each scope can have a parent scope and inherit its components, fragments, entities and errors\n     * \n     * @param params \n     * @param config \n     */\n    constructor()\n    constructor(\n        /**\n         * A set of constructors that are allowed in the scope\n         */\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        /**\n         * Configuration options for the scope\n         */\n        config?: Partial<A_TYPES__ScopeConfig>\n    )\n    constructor(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ) {\n        const initializer = this.getInitializer(param1);\n        // the returned initializer is already bound to `this` (we used .bind(this)),\n        // so calling it will run the appropriate logic on this instance:\n        initializer.call(this, param1, param2);\n    }\n\n    /**\n     * Generator to iterate through all parent scopes\n     */\n    *parents(): Generator<A_Scope> {\n        let currentParent = this._parent;\n        while (currentParent) {\n            yield currentParent;\n            currentParent = currentParent._parent;\n        }\n    }\n\n    /**\n     * This method is used to retrieve a parent scope at a specific level\n     * \n     * [!] Note that if the level is out of bounds, undefined is returned\n     * [!!] Uses negative values for levels (e.g. -1 for immediate parent, -2 for grandparent, etc.)\n     * \n     * @param level \n     * @returns \n     */\n    parentOffset<T extends A_Scope>(\n        /**\n         * Level of the parent scope to retrieve\n         * \n         * Examples:\n         * - level 0 - this scope\n         * - level -1 - parent\n         * - level -2 - grandparent\n         */\n        layerOffset: number\n    ): T | undefined {\n        let parentScope: A_Scope | undefined = this;\n\n        while (layerOffset <= -1 && parentScope) {\n            parentScope = parentScope.parent;\n            layerOffset++;\n        }\n\n        return parentScope as T\n    }\n\n\n    /**\n     * Determines which initializer method to use based on the type of the first parameter.\n     * \n     * @param param1 \n     * @returns\n     */\n    protected getInitializer(\n        param1?: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>>,\n        param2?: Partial<A_TYPES__ScopeConfig>\n    ): (param1: any, param2: any) => void | (() => void) {\n        switch (true) {\n            case !param1 && !param2: ;\n                return this.defaultInitialized;\n\n            case !!param1:\n                return this.defaultInitialized;\n            default:\n                throw new A_ScopeError(A_ScopeError.ConstructorError, 'Invalid parameters provided to A_Scope constructor');\n        }\n    }\n\n\n\n    protected defaultInitialized(\n        params: Partial<A_TYPES__Scope_Init<_MetaItems, _ComponentType, _ErrorType, _EntityType, _FragmentType>> = {},\n        config: Partial<A_TYPES__ScopeConfig> = {}\n    ) {\n        this._name = params.name || this.constructor.name\n\n        this.initComponents(params.components);\n        this.initErrors(params.errors);\n        this.initFragments(params.fragments);\n        this.initEntities(params.entities);\n        this.initMeta(params.meta);\n\n        if (config.parent) {\n            this._parent = config.parent;\n        }\n    }\n\n\n    //==========================================================================\n    // --------------------Scope Initialization Methods---------------------------\n    //==========================================================================\n\n    /**\n     * This method is used to initialize the components in the scope\n     * To save memory components are initialized only when they are requested\n     * \n     * This method only registers the component in the scope in case they are not registered yet\n     * \n     * @param _components \n     */\n    protected initComponents(_components?: _ComponentType) { _components?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the errors in the scope\n     * \n     * This method only registers the errors in the scope in case they are not registered yet\n     * \n     * @param _errors \n     */\n    protected initErrors(_errors?: _ErrorType) { _errors?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the entities in the scope\n     * \n     * This method only registers the entities in the scope in case they are not registered yet\n     * \n     * @param _entities \n     */\n    protected initEntities(_entities?: [\n        ..._EntityType,\n        ...InstanceType<_EntityType[number]>[]\n    ]) { _entities?.forEach(ent => this.register(ent as any)); }\n    /**\n     * This method is used to initialize the fragments in the scope\n     * \n     * This method only registers the fragments in the scope in case they are not registered yet\n     * \n     * @param _fragments \n     */\n    protected initFragments(_fragments?: _FragmentType) { _fragments?.forEach(this.register.bind(this)); }\n    /**\n     * This method is used to initialize the meta in the scope\n     * \n     * This method only sets the meta values in the scope in case they are not set yet\n     * \n     * @param _meta \n     */\n    protected initMeta(_meta?: Partial<_MetaItems>) {\n        if (_meta) {\n            Object.entries(_meta).forEach(([key, value]) => {\n                this._meta.set(key as keyof _MetaItems, value as _MetaItems[keyof _MetaItems]);\n            });\n        }\n    }\n\n\n    // ==========================================================================\n    // --------------------Scope Public Methods-----------------------------------\n    // ==========================================================================\n    /**\n     * This method is used to destroy the scope and all its registered components, fragments and entities\n     * \n     * [!] This method deregisters all components, fragments and entities from the A-Context\n     * [!] This method also clears all internal registries and collections\n     */\n    destroy() {\n        this._components.forEach(component => A_Context.deregister(component));\n        this._fragments.forEach(fragment => A_Context.deregister(fragment));\n        this._entities.forEach(entity => A_Context.deregister(entity));\n\n        this._components.clear();\n        this._errors.clear();\n        this._fragments.clear();\n        this._entities.clear();\n        this._imports.clear();\n\n        if (this.issuer()) {\n            A_Context.deallocate(this);\n        }\n    }\n\n\n    /**\n     * Retrieves a value from the scope's meta.\n     * \n     * @param param - The key to retrieve\n     * @returns The value associated with the key, or undefined if not found\n     * \n     * @example\n     * ```typescript\n     * const userId = scope.get('userId');\n     * if (userId) {\n     *   console.log(`Current user: ${userId}`);\n     * }\n     * ```\n     */\n    get<K extends keyof _MetaItems>(param: K): _MetaItems[K] | undefined {\n        return this._meta.get(param);\n    }\n\n    /**\n     * Stores a value in the scope's meta.\n     * \n     * @param param - The key to store the value under\n     * @param value - The value to store\n     * \n     * @example\n     * ```typescript\n     * scope.set('userId', '12345');\n     * scope.set('role', 'admin');\n     * ```\n     */\n    set<K extends keyof _MetaItems>(param: K, value: _MetaItems[K]): void {\n        this._meta.set(param, value);\n    }\n\n\n    /**\n     * Returns the issuer of the scope, useful for debugging and tracking purposes\n     * \n     * Issuer can be:\n     * - A Container that allocated the scope\n     * - A Feature that allocated the scope\n     * \n     * [!] Note that the issuer is the direct allocator of the scope, so if a Container allocated a Feature that allocated the scope, the issuer will be the Feature\n     * \n     * @returns \n     */\n    issuer<T extends A_TYPES__ScopeLinkedComponents>(): T | undefined {\n        return A_Context.issuer(this) as T;\n    }\n\n\n\n    /**\n     * This method is used to inherit from a parent scope\n     * \n     * [!] This method checks for circular inheritance and throws an error if detected\n     * \n     * @param parent \n     * @returns \n     */\n    inherit(parent: A_Scope): A_Scope {\n        if (!parent)\n            throw new A_ScopeError(\n                A_ScopeError.InitializationError,\n                `Invalid parent scope provided`\n            );\n\n        if (parent === this)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Unable to inherit scope ${this.name} from itself`\n            );\n\n        if (parent === this._parent)\n            return this;\n\n        // Prevent circular inheritance\n        const circularCheck = this.checkCircularInheritance(parent);\n\n        if (circularCheck)\n            throw new A_ScopeError(\n                A_ScopeError.CircularInheritanceError,\n                `Circular inheritance detected: ${[...circularCheck, parent.name].join(' -> ')}`\n            );\n\n\n        this._parent = parent;\n        return this;\n    }\n\n\n    /**\n     * This method allows to import other scopes, to make their dependencies available in the current scope\n     * \n     * [!] Import doesn't create a parent-child relationship between scopes, it just copies the dependencies from the imported scopes\n     * [!] It doesn't change the entities ownership, so entities remain unique to their original scopes\n     * \n     * @param scopes \n     * @returns \n     */\n    import(...scopes: A_Scope[]): A_Scope {\n\n        scopes.forEach(scope => {\n            if (scope === this)\n                throw new A_ScopeError(\n                    A_ScopeError.CircularImportError,\n                    `Unable to import scope ${this.name} into itself`\n                );\n\n            if (this._imports.has(scope))\n                return;\n\n            this._imports.add(scope);\n        });\n\n        return this;\n    }\n\n    /**\n     * This method allows to deimport other scopes, to remove their dependencies from the current scope\n     * \n     * \n     * @param scopes \n     * @returns \n     */\n    deimport(...scopes: A_Scope[]): A_Scope {\n\n        scopes.forEach(scope => {\n            if (this._imports.has(scope))\n                this._imports.delete(scope);\n        });\n        return this;\n    }\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component in the current scope and all parent scopes\n     * \n     * @param component \n     * @returns \n     */\n    has<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    has<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    has<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    has<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    has(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    has<T extends A_TYPES__A_DependencyInjectable>(\n        ctor: A_TYPES__Ctor<T> | string\n    ): boolean\n    has<T extends A_TYPES__A_DependencyInjectable>(\n        ctor: A_TYPES__Ctor<T> | string\n    ): boolean {\n\n        let found = this.hasFlat(ctor as any);\n\n        if (!found && !!this._parent)\n            try {\n                return this._parent.has(ctor as any);\n            } catch (error) {\n                return false;\n            }\n\n        return found;\n    }\n\n\n    /**\n     * This method is used to check if the component is available in the scope\n     * \n     * [!] Note that this method checks for the component ONLY in the current scope\n     * \n     * @param component \n     * @returns \n     */\n    hasFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to check if it's available in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to check if it's available in the scope\n         * \n         * [!] Note that entities are unique per aseid, so this method checks if there's at least one entity of the provided type in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to check if it's available in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): boolean\n    hasFlat<T extends A_Error>(\n        /**\n         * Provide an error constructor to check if it's available in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): boolean\n    hasFlat(\n        /**\n         * Provide a string to check if a component, entity or fragment with the provided name is available in the scope\n         */\n        constructor: string\n    ): boolean\n    hasFlat(\n        ctor: unknown\n    ): boolean {\n\n        let found = false;\n\n        switch (true) {\n            // 1) Check if it's a Scope. It's always true since it returns itself\n            case A_TypeGuards.isScopeConstructor(ctor):\n                return true;\n\n            // 2) Check by string name.  \n            case A_TypeGuards.isString(ctor): {\n\n                // 2.1 Check if it's a component name\n                const possibleComponent = Array.from(this.allowedComponents).find(c => c.name === ctor);\n                if (possibleComponent) found = true;\n\n                // 2.2 Check if it's a fragment name\n                const possibleFragment = Array.from(this.allowedFragments).find(f => f.name === ctor);\n                if (possibleFragment) found = true;\n\n                // 2.3 Check if it's an entity name or entity static entity property\n                const possibleEntity = Array.from(this.allowedEntities).find(e => e.name === ctor);\n                if (possibleEntity) found = true;\n\n                // 2.4 Check if it's an error name\n                const possibleError = Array.from(this.allowedErrors).find(e => e.name === ctor);\n                if (possibleError) found = true;\n\n                break;\n            }\n            // 3) Check if it's a Component\n            case A_TypeGuards.isComponentConstructor(ctor): {\n                found = this.isAllowedComponent(ctor)\n                    || !![...this.allowedComponents]\n                        .find(c => A_CommonHelper.isInheritedFrom(c, ctor));\n\n                break;\n            }\n            // 4) Check if it's an Entity\n            case A_TypeGuards.isEntityConstructor(ctor): {\n                found = this.isAllowedEntity(ctor)\n                    || !![...this.allowedEntities]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n            // 5) Check if it's a Fragment\n            case A_TypeGuards.isFragmentConstructor(ctor): {\n                found = this.isAllowedFragment(ctor)\n                    || !![...this.allowedFragments]\n                        .find(f => A_CommonHelper.isInheritedFrom(f, ctor));\n\n                break;\n            }\n\n            // 6) Check if it's an Error\n            case A_TypeGuards.isErrorConstructor(ctor): {\n                found = this.isAllowedError(ctor)\n                    || !![...this.allowedErrors]\n                        .find(e => A_CommonHelper.isInheritedFrom(e, ctor));\n\n                break;\n            }\n\n            // 7) Check scope issuer\n            case this.issuer()\n                && (this.issuer()!.constructor === ctor\n                    || A_CommonHelper.isInheritedFrom(this.issuer()!.constructor, ctor\n                    )\n                ): {\n                    found = true;\n                    break;\n                }\n        }\n\n        return found;\n    }\n\n\n    /**\n     * Allows to resolve a specific dependency \n     * \n     * @param dependency \n     * @returns \n     */\n    resolveDependency<T extends A_TYPES__A_DependencyInjectable>(\n        dependency: A_Dependency<T>\n    ): T | Array<T> | undefined {\n\n        let result: Array<T> = [];\n        let targetScope: A_Scope = this.parentOffset(dependency.parent) || this;\n\n        //  first deal with level conditions and \n        switch (true) {\n            // 1) Flat resolution\n            case dependency.flat && !dependency.all: {\n                const resolved = targetScope.resolveFlatOnce<T>(dependency.target || dependency.name);\n                if (resolved)\n                    result = [resolved];\n                break;\n            }\n            case dependency.flat && dependency.all: {\n                result = targetScope.resolveFlatAll<T>(dependency.target || dependency.name);\n                break;\n            }\n            case !dependency.flat && !dependency.all: {\n                const resolved = targetScope.resolveOnce<T>(dependency.target || dependency.name);\n                if (resolved)\n                    result = [resolved];\n                break;\n            }\n            case !dependency.flat && dependency.all: {\n                result = targetScope.resolveAll<T>(dependency.target || dependency.name);\n                break;\n            }\n\n            default:\n                result = [];\n        }\n\n        //  2) create if not found and allowed\n        if (dependency.create\n            && !result.length\n            && A_TypeGuards.isAllowedForDependencyDefaultCreation(dependency.target)\n        ) {\n\n            const newDependency = new dependency.target(...dependency.args);\n\n            targetScope.register(newDependency);\n\n            result.push(newDependency as T);\n        }\n\n        //  3) handle required dependencies\n        if (dependency.require && !result.length) {\n            throw new A_ScopeError(\n                A_ScopeError.ResolutionError,\n                `Dependency ${dependency.name} is required but could not be resolved in scope ${targetScope.name}`\n            );\n        }\n\n\n        // 4) Apply filters\n        if (dependency.query.aseid)\n            //  in this case we should return only one dependency by aseid\n            result = result.filter(dep => A_TypeGuards.hasASEID(dep) && ASEID.compare(dep.aseid, dependency.query.aseid));\n\n        else if (Object.keys(dependency.query).length > 0)\n            result = result\n                .filter(dep => {\n                    const query = dependency.query;\n                    if (!query) return true;\n\n                    return Object.entries(query).every(([key, value]) => {\n                        return (dep as any)[key] === value;\n                    });\n                });\n\n\n        // 5) apply pagination\n\n        const count = dependency.pagination.count;\n        const from = dependency.pagination.from;  // from start or from end\n\n\n\n        const startSliceIndex = from === 'end'\n            ? (count === -1 ? 0 : Math.max(result.length - count, 0))\n            : 0;\n\n        //  end slice should handle -1 for all items\n        const endSliceIndex = from === 'end'\n            ? result.length\n            : (count === -1 ? result.length : Math.min(count, result.length));\n\n        const slice = result.slice(startSliceIndex, endSliceIndex);\n\n        /**\n         * Default behavior is to return single instance if count is 1\n         * \n         * If Directive All (-1) is provided or count > 1, an array is returned\n         * \n         * If no instances found, undefined is returned\n         */\n        return slice.length === 1\n            && count !== -1\n            ? slice[0]\n            : slice.length\n                ? slice\n                : undefined;\n    }\n\n\n    /**\n     * Allows to retrieve the constructor of the component or entity by its name\n     * \n     * [!] Notes:\n     * - In case of search for A-Entity please ensure that provided string corresponds to the static entity property of the class. [!] By default it's the kebab-case of the class name\n     * - In case of search for A_Component please ensure that provided string corresponds to the class name in PascalCase\n     * \n     * @param name \n     * @returns \n     */\n    resolveConstructor<T extends A_Entity>(\n        /**\n         * Provide the entity name or static entity property to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Entity_Constructor<T>\n    resolveConstructor<T extends A_Component>(\n        /**\n         * Provide the component name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Component_Constructor<T>\n    resolveConstructor<T extends A_Fragment>(\n        /**\n         * Provide the fragment name in PascalCase to retrieve its constructor\n         */\n        name: string\n    ): A_TYPES__Fragment_Constructor<T>\n    resolveConstructor<T extends A_TYPES__A_DependencyInjectable>(name: string): A_TYPES__Entity_Constructor<T> | A_TYPES__Component_Constructor<T> | A_TYPES__Fragment_Constructor<T> | undefined\n    resolveConstructor<T extends A_TYPES__A_DependencyInjectable>(name: string): A_TYPES__Entity_Constructor<T> | A_TYPES__Component_Constructor<T> | A_TYPES__Fragment_Constructor<T> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n\n        if (component) return component as A_TYPES__Component_Constructor<T>;\n        else\n        // 1.2) Check components prototypes\n        {\n            const protoComponent = Array.from(this.allowedComponents).find(\n\n                //  it should go rthough prototyopes and check their names to be equal to the provided name\n                c => {\n                    let current = c;\n\n                    while (current) {\n                        if (current.name === name\n                            || current.name === A_FormatterHelper.toPascalCase(name)\n                        ) {\n                            return true;\n                        }\n                        current = Object.getPrototypeOf(current);\n                    }\n\n                    return false;\n\n                }\n            );\n            if (protoComponent) return protoComponent as A_TYPES__Component_Constructor<T>;\n        }\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return entity as A_TYPES__Entity_Constructor<T>;\n        else\n        // 2.2) Check entities prototypes\n        {\n            const protoEntity = Array.from(this.allowedEntities).find(\n                e => A_CommonHelper.isInheritedFrom(e, name as any)\n            );\n            if (protoEntity) return protoEntity as A_TYPES__Entity_Constructor<T>;\n        }\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return fragment as A_TYPES__Fragment_Constructor<T>;\n        else\n        // 3.2) Check fragments prototypes\n        {\n            const protoFragment = Array.from(this.allowedFragments).find(\n                f => A_CommonHelper.isInheritedFrom(f, name as any)\n            );\n            if (protoFragment) return protoFragment as A_TYPES__Fragment_Constructor<T>;\n        }\n\n        // If not found in current scope, check imported scopes\n        for (const importedScope of this._imports) {\n            const importedConstructor = importedScope.resolveConstructor<T>(name);\n            if (importedConstructor) {\n                return importedConstructor;\n            }\n        }\n\n        // Then, finally check parent scope\n        if (!!this._parent) {\n            return this._parent.resolveConstructor(name) as any;\n        }\n\n        return undefined;\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): Array<T>\n    resolveAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): Array<T> {\n\n        const results: Set<T> = new Set();\n\n        // 1) Resolve all in the current scope\n        const currentResults = this.resolveFlatAll<T>(param1 as any);\n        currentResults.forEach(result => results.add(result));\n\n        // 2) resolve all in the imported scopes\n        this._imports.forEach(importedScope => {\n\n            if (importedScope.has(param1 as any)) {\n                const importedResults = importedScope.resolveFlatAll<T>(param1 as any);\n\n\n                importedResults.forEach(result => results.add(result));\n            }\n        });\n\n        // 3) Resolve all in the parent scope\n        let parentScope = this._parent;\n\n        while (parentScope && parentScope.has(param1 as any)) {\n\n            const parentResults = parentScope.resolveAll<T>(param1 as any);\n            parentResults.forEach(result => results.add(result));\n\n            // Move to the next parent scope\n            parentScope = parentScope._parent;\n        }\n\n\n\n        return Array.from(results);\n    }\n\n\n\n\n    /**\n     * This method should resolve all instances of the components, or entities within the scope, by provided parent class\n     * So in case of providing a base class it should return all instances that extends this base class\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlatAll<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): Array<T>\n    resolveFlatAll<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): Array<T> {\n\n        const results: Array<T> = [];\n\n        switch (true) {\n            // 1) if a parameter is a component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                // 1) Check components\n                this.allowedComponents.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolveOnce<T>(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n            // 2) if a parameter is a fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                // 2) Check fragments\n                this.allowedFragments.forEach(ctor => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        const instance = this.resolveOnce<T>(ctor);\n                        if (instance) results.push(instance as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isEntityConstructor(param1): {\n                // 3) Check entities\n                this.entities.forEach(entity => {\n\n                    if (A_CommonHelper.isInheritedFrom(entity.constructor, param1)) {\n                        results.push(entity as T);\n                    }\n                });\n                break;\n            }\n\n            case A_TypeGuards.isString(param1): {\n                // 4) Check by name\n                const ctor = this.resolveConstructor(param1);\n                if (!A_TypeGuards.isComponentConstructor(ctor)\n                    && !A_TypeGuards.isEntityConstructor(ctor)\n                    && !A_TypeGuards.isFragmentConstructor(ctor)\n                )\n                    throw new A_ScopeError(\n                        A_ScopeError.ResolutionError,\n                        `Unable to resolve all instances for name: ${param1} in scope ${this.name} as no matching component, entity or fragment constructor found`);\n\n\n                if (ctor) {\n                    const instances = this.resolveAll<T>(ctor as any);\n                    if (instances)\n                        results.push(...instances);\n                }\n                break;\n            }\n\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Invalid parameter provided to resolveAll method: ${param1} in scope ${this.name}`);\n        }\n\n\n        return results;\n    }\n\n\n\n    /**\n     * This method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * @param component \n     * @returns \n     */\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Ctor<T>\n    ): T | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a target dependency to resolve its instance from the scope\n         * \n         * [!] In this case its possible to provide a custom resolution strategy via A_Dependency options\n         */\n        dependency: A_Dependency<T>\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: string\n    ): T | Array<T> | undefined\n    resolve<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<T> | A_Dependency<T> | string\n    ): T | Array<T> | undefined {\n\n        const dependency = A_TypeGuards.isDependencyInstance(param1) ?\n            param1 as A_Dependency<T> :\n            new A_Dependency<T>(param1)\n\n        return this.resolveDependency<T>(dependency);\n    }\n\n    /**\n     * This method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * @param component \n     * @returns \n     */\n    resolveOnce<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): T | undefined\n    resolveOnce<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string\n    ): T | undefined {\n\n        const value = this.resolveFlatOnce(param1);\n\n        // if not found in the current scope, check imported scopes\n        if (!value) {\n            for (const importedScope of this._imports) {\n                if (importedScope.has(param1 as any)) {\n                    const importedValue = importedScope.resolveFlatOnce<T>(param1 as any);\n                    if (importedValue) {\n                        return importedValue;\n                    }\n                }\n            }\n        }\n\n        //  The idea here that in case when Scope has no exact component we have to resolve it from the _parent\n        //  That means that we should ensure that there's no components that are children of the required component\n        if (!value && !!this.parent) {\n            return this.parent.resolveOnce<T>(param1);\n        }\n\n        return value as T;\n    }\n\n\n    /**\n     * This polymorphic method allows to resolve/inject a component, fragment or entity from the scope\n     * Depending on the provided parameters it can resolve:\n     * - A single component/fragment/entity by its constructor or name\n     * - An array of components/fragments/entities by providing an array of constructors\n     * - An entity or an array of entities by providing the entity constructor and query instructions\n     * \n     * [!] Applicable for the current scope ONLY, no parent scopes are checked\n     * \n     * @param component \n     */\n    resolveFlat<T extends A_Component>(\n        /**\n         * Provide a component constructor to resolve its instance from the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Fragment>(\n        /**\n         * Provide a fragment constructor to resolve its instance from the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to resolve its instance or an array of instances from the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Scope>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        scope: A_TYPES__Scope_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_Error>(\n        /**\n         * Uses only in case of resolving a single entity\n         * \n         * Provide an entity constructor to resolve its instance from the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor to resolve its instance(s) from the scope\n         */\n        constructorName: string\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        ctor: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable>,\n    ): T | undefined\n    resolveFlat<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide a component, fragment or entity constructor or an array of constructors to resolve its instance(s) from the scope\n         */\n        param1: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): T | undefined {\n        return this.resolveFlatOnce(param1) as T;\n    }\n\n\n    /**\n     * Resolves a component, fragment or entity from the scope without checking parent scopes\n     * \n     * @param component \n     * @param instructions \n     */\n    resolveFlatOnce<T extends A_TYPES__A_DependencyInjectable>(\n        component: A_TYPES__Ctor<A_TYPES__A_DependencyInjectable> | string,\n    ): T | undefined {\n\n        let value: T | undefined = undefined;\n\n        const componentName = A_CommonHelper.getComponentName(component);\n\n\n        if (!component || !this.has(component)) {\n            return undefined;\n        }\n\n        switch (true) {\n            case A_TypeGuards.isString(component): {\n                value = this.resolveByName(component) as T;\n                break;\n            }\n            case A_TypeGuards.isConstructorAllowedForScopeAllocation(component): {\n                value = this.resolveIssuer(component) as T;\n                break;\n            }\n            case A_TypeGuards.isScopeConstructor(component): {\n                value = this.resolveScope(component) as T\n                break;\n            }\n            case A_TypeGuards.isEntityConstructor(component): {\n                value = this.resolveEntity(component) as T\n                break;\n            }\n            case A_TypeGuards.isFragmentConstructor(component): {\n                value = this.resolveFragment(component) as T;\n                break;\n            }\n            case A_TypeGuards.isComponentConstructor(component): {\n                value = this.resolveComponent(component) as T;\n                break;\n            }\n            case A_TypeGuards.isErrorConstructor(component): {\n                value = this.resolveError(component) as T;\n                break;\n            }\n            default:\n                throw new A_ScopeError(\n                    A_ScopeError.ResolutionError,\n                    `Injected Component ${componentName} not found in the scope`\n                );\n        }\n\n        return value\n    }\n\n\n\n    // ==================================================================================================\n    // --------------------------------------------------------------------------------------------------\n    // -------------------------------------INTERNAL RESOLVERS-------------------------------------------\n    // --------------------------------------------------------------------------------------------------\n    // ==================================================================================================\n    /**\n     * This method is used internally to resolve a component, fragment or entity by its constructor name\n     * \n     * [!] Note that this method checks for the component, fragment or entity in the current scope and all parent scopes\n     * [!!] Note: No parent scopes are checked\n     * \n     * @param name  - name of the component, fragment or entity to resolve (constructor name for components and fragments, static entity property for entities, static code property for commands)\n     * @returns \n     */\n    private resolveByName(\n        /**\n         * Provide the name of the component, fragment or entity to resolve\n         */\n        name: string\n    ): _EntityType[number] | InstanceType<_ComponentType[number]> | _FragmentType[number] |\n        InstanceType<_ErrorType[number]> | undefined {\n        // 1) Check components\n        const component = Array.from(this.allowedComponents).find(\n            c => c.name === name\n                || c.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (component) return this.resolveOnce(component) as InstanceType<_ComponentType[number]>;\n\n        // 2) Check entities\n        const entity = Array.from(this.allowedEntities).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).entity === name\n                || (e as any).entity === A_FormatterHelper.toKebabCase(name)\n        );\n        if (entity) return this.resolveOnce(entity) as InstanceType<_EntityType[number]>;\n\n        // 3) Check fragments\n        const fragment = Array.from(this.allowedFragments).find(f => f.name === name\n            || f.name === A_FormatterHelper.toPascalCase(name)\n        );\n        if (fragment) return this.resolveOnce(fragment) as _FragmentType[number];\n\n        // 4) Check errors\n        const error = Array.from(this.allowedErrors).find(\n            e => e.name === name\n                || e.name === A_FormatterHelper.toPascalCase(name)\n                || (e as any).code === name\n                || (e as any).code === A_FormatterHelper.toKebabCase(name)\n        );\n        if (error) return this.resolveOnce(error) as InstanceType<_ErrorType[number]>;\n\n        return undefined;\n    }\n\n\n    /**\n     * Resolves the issuer of the scope by provided constructor\n     * \n     * [!] Note that this method checks ONLY for the direct issuer of the scope\n     * [!!] No parent scopes are checked\n     * \n     * \n     * @param ctor \n     * @returns \n     */\n    private resolveIssuer(\n        ctor: A_TYPES__ScopeLinkedConstructors\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const issuer = this.issuer();\n\n        if (issuer\n            && (\n                issuer.constructor === ctor\n                || A_CommonHelper.isInheritedFrom(issuer?.constructor, ctor)\n            )) {\n            return issuer!;\n        }\n\n\n        return undefined;\n    }\n\n    /**\n     * This method is used internally to resolve a single entity from the scope based on the provided instructions\n     * \n     * [!] Note that this method can return either a single entity or an array of entities depending on the instructions provided\n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param entity \n     * @param instructions \n     * @returns \n     */\n    private resolveEntity<T extends A_Entity>(\n        entity: A_TYPES__Entity_Constructor<T>\n    ): T | Array<T> | undefined {\n\n        /**\n         * 1) In case when no instructions provided, return the first found entity of the provided type\n         * \n         * [!] Note that it returns ONLY ONE entity\n         * [!!] In case when no entity found in the current scope, it tries to resolve it from the parent scope (if exists)\n         */\n\n        return this.entities.find(e => e instanceof entity) as T | undefined;\n\n    }\n    /**\n     * This method is used internally to resolve a single error from the scope\n     * \n     * [!] Note that errors are singleton instances within the scope\n     * [!!] No parent scopes are checked\n     * \n     * @param error \n     * @returns \n     */\n    private resolveError<T extends A_Error>(error: A_TYPES__Error_Constructor<T>): T | undefined {\n\n        return this.errors.find(e => e instanceof error) as T | undefined;\n    }\n    /**\n     * This method is used internally to resolve a single fragment from the scope\n     * \n     * [!] Note that this method checks for the fragment in the current scope and all parent scopes\n     * \n     * @param fragment \n     * @returns \n     */\n    private resolveFragment<T extends A_Fragment>(fragment: A_TYPES__Fragment_Constructor<T>): _FragmentType[number] | undefined {\n        const fragmentInstancePresented = this._fragments.get(fragment);\n\n        switch (true) {\n            case fragmentInstancePresented && this._fragments.has(fragment):\n                return fragmentInstancePresented;\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !fragmentInstancePresented && Array.from(this._allowedFragments).some(el => A_CommonHelper.isInheritedFrom(el, fragment)): {\n                const found = Array.from(this._allowedFragments).find(el => A_CommonHelper.isInheritedFrom(el, fragment))!;\n\n                return this.resolveFragment(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n    /**\n     *  This method is used internally to resolve a single scope from the current scope\n     * \n     * @param scope \n     * @returns \n     */\n    private resolveScope(scope: A_TYPES__Scope_Constructor): A_Scope {\n        return this;\n    }\n\n    /**\n     * This method is used internally to resolve a single component from the scope\n     * \n     * [!!] Note: No parent scopes are checked  \n     * \n     * @param component \n     * @returns \n     */\n    private resolveComponent<T extends A_Component>(component: A_TYPES__Component_Constructor<T>): InstanceType<_ComponentType[number]> | undefined {\n\n\n        switch (true) {\n            // 1) In case when the component is available and exists in the scope\n            case this.allowedComponents.has(component) && this._components.has(component): {\n                return this._components.get(component)!;\n            }\n\n            // 2) In case the component available but does NOT exist in the scope\n            case this.allowedComponents.has(component) && !this._components.has(component): {\n                const componentMeta = A_Context.meta(component)\n\n                const argsMeta = componentMeta.get(A_TYPES__ComponentMetaKey.INJECTIONS);\n\n                const resolvedArgs = (argsMeta?.get('constructor') || [])\n                    .map(dependency => this.resolve(dependency));\n\n\n                const newComponent = new component(...resolvedArgs)\n\n                this.register(newComponent);\n\n                return this._components.get(component)!;\n            }\n\n            // 3) In case when there's a component that is inherited from the required component\n            case !this.allowedComponents.has(component) && Array.from(this.allowedComponents).some(el => A_CommonHelper.isInheritedFrom(el, component)): {\n                const found = Array.from(this.allowedComponents).find(el => A_CommonHelper.isInheritedFrom(el, component))!;\n\n                return this.resolveComponent(found);\n            }\n\n            default:\n                return undefined;\n        }\n    }\n\n\n    /**\n     * This method is used to register the component in the scope\n     * \n     * @param fragment \n     */\n    register<T extends A_Component>(\n        /**\n         * Provide a component constructor to register it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    register<T extends A_Component>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        component: T\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error constructor to register it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    register<T extends A_Error>(\n        /**\n         * Provide an error instance to register it in the scope\n         */\n        error: T\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a command instance to register it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    register<T extends A_Fragment>(\n        /**\n         * Provide a fragment instance to register it in the scope\n         */\n        fragment: T\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to register it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    register<T extends A_Entity>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        entity: T\n    ): void\n    register<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        entity: T\n    ): void\n    register<T extends A_TYPES__A_DependencyInjectable>(\n        /**\n         * Provide an entity instance to register it in the scope\n         */\n        param1: T\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                if (!this.allowedComponents.has(param1.constructor as _ComponentType[number]))\n                    this.allowedComponents.add(param1.constructor as _ComponentType[number]);\n\n                this._components.set(\n                    param1.constructor as _ComponentType[number],\n                    param1 as InstanceType<_ComponentType[number]>\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1) && !this._entities.has(param1.aseid.toString()): {\n\n                if (!this.allowedEntities.has(param1.constructor as _EntityType[number]))\n                    this.allowedEntities.add(param1.constructor as _EntityType[number]);\n\n                this._entities.set(param1.aseid.toString(), param1 as InstanceType<_EntityType[number]>);\n                A_Context.register(this, param1);\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n\n                if (!this.allowedFragments.has(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>))\n                    this.allowedFragments.add(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n\n                this._fragments.set(\n                    param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>,\n                    param1 as _FragmentType[number]\n                );\n\n                A_Context.register(this, param1);\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n                if (!this.allowedErrors.has(param1.constructor as _ErrorType[number]))\n                    this.allowedErrors.add(param1.constructor as _ErrorType[number]);\n\n                this._errors.set(\n                    (param1 as any).code,\n                    param1 as InstanceType<_ErrorType[number]>\n                );\n\n                A_Context.register(this, (param1 as any));\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                if (!this.allowedComponents.has(param1))\n                    this.allowedComponents.add(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                if (!this.allowedFragments.has(param1))\n                    this.allowedFragments.add(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                if (!this.allowedEntities.has(param1))\n                    this.allowedEntities.add(param1 as _EntityType[number]);\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                if (!this.allowedErrors.has(param1))\n                    this.allowedErrors.add(param1 as _ErrorType[number]);\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                if (param1 instanceof A_Entity)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Entity with ASEID ${param1.aseid.toString()} is already registered in the scope ${this.name}`\n                    );\n                else if (param1 instanceof A_Fragment)\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Fragment ${param1.constructor.name} is already registered in the scope ${this.name}`\n                    );\n                else {\n                    const componentName = A_CommonHelper.getComponentName(param1);\n\n                    throw new A_ScopeError(\n                        A_ScopeError.RegistrationError,\n                        `Cannot register ${componentName} in the scope ${this.name}`\n                    );\n                }\n        }\n    }\n\n\n    /**\n     * This method is used to deregister the component from the scope\n     * \n     * @param fragment \n     */\n    deregister<T extends A_Component>(\n        /**\n         * Provide a component constructor to deregister it in the scope\n         */\n        component: A_TYPES__Component_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        component: A_Component\n    ): void\n    deregister<T extends A_Error>(\n        /**\n         * Provide an error constructor to deregister it in the scope\n         */\n        error: A_TYPES__Error_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an error instance to deregister it in the scope\n         */\n        error: A_Error\n    ): void\n    deregister<T extends A_Fragment>(\n        /**\n         * Provide a command instance to deregister it in the scope\n         */\n        fragment: A_TYPES__Fragment_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide a fragment instance to deregister it in the scope\n         */\n        fragment: A_Fragment\n    ): void\n    deregister<T extends A_Entity>(\n        /**\n         * Provide an entity constructor to deregister it in the scope\n         */\n        entity: A_TYPES__Entity_Constructor<T>\n    ): void\n    deregister(\n        /**\n         * Provide an entity instance to deregister it in the scope\n         */\n        entity: A_Entity\n    ): void\n\n    deregister(\n        param1: unknown\n    ): void {\n        switch (true) {\n            // ------------------------------------------\n            // ------------ Instances ----------------\n            // ------------------------------------------\n            // 1) In case when it's a A-Component instance\n            case param1 instanceof A_Component: {\n\n                this._components.delete(param1.constructor as _ComponentType[number]);\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as _ComponentType[number];\n\n                const hasComponent = this._components.has(ctor);\n                if (!hasComponent) {\n                    this.allowedComponents.delete(ctor);\n                }\n\n                break;\n            }\n            // 3) In case when it's a A-Entity instance\n            case A_TypeGuards.isEntityInstance(param1): {\n\n                this._entities.delete(param1.aseid.toString());\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as _EntityType[number];\n\n                const hasEntity = Array.from(this._entities.values()).some(entity => entity instanceof ctor);\n                if (!hasEntity) {\n                    this.allowedEntities.delete(ctor);\n                }\n\n                break;\n            }\n            // 4) In case when it's a A-Fragment instance\n            case A_TypeGuards.isFragmentInstance(param1): {\n                this._fragments.delete(param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                A_Context.deregister(param1);\n\n                const ctor = param1.constructor as A_TYPES__Fragment_Constructor<_FragmentType[number]>;\n\n                const hasFragment = Array.from(this._fragments.values()).some(fragment => fragment instanceof ctor);\n                if (!hasFragment) {\n                    this.allowedFragments.delete(ctor);\n                }\n\n                break;\n            }\n            // 5) In case when it's a A-Error instance\n            case A_TypeGuards.isErrorInstance(param1): {\n\n                this._errors.delete((param1 as any).code);\n                A_Context.deregister((param1 as any));\n\n                const ctor = (param1 as any).constructor as _ErrorType[number];\n\n                const hasError = Array.from(this._errors.values()).some(error => error instanceof ctor);\n                if (!hasError) {\n                    this.allowedErrors.delete(ctor);\n                }\n\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Constructors ----------------\n            // ------------------------------------------\n            // 6) In case when it's a A-Component constructor\n            case A_TypeGuards.isComponentConstructor(param1): {\n                this.allowedComponents.delete(param1 as _ComponentType[number]);\n                break;\n            }\n            // 8) In case when it's a A-Fragment constructor\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                this.allowedFragments.delete(param1 as A_TYPES__Fragment_Constructor<_FragmentType[number]>);\n                // and then deregister all instances of this fragment\n                Array.from(this._fragments.entries()).forEach(([ctor, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(ctor, param1)) {\n                        this._fragments.delete(ctor);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n            // 9) In case when it's a A-Entity constructor\n            case A_TypeGuards.isEntityConstructor(param1): {\n                this.allowedEntities.delete(param1 as _EntityType[number]);\n                //  and then deregister all instances of this entity\n                Array.from(this._entities.entries()).forEach(([aseid, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(instance.constructor, param1)) {\n                        this._entities.delete(aseid);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n            // 10) In case when it's a A-Error constructor\n            case A_TypeGuards.isErrorConstructor(param1): {\n                this.allowedErrors.delete(param1 as _ErrorType[number]);\n                // and then deregister all instances of this error\n                Array.from(this._errors.entries()).forEach(([code, instance]) => {\n                    if (A_CommonHelper.isInheritedFrom(instance.constructor, param1)) {\n                        this._errors.delete(code);\n                        A_Context.deregister(instance);\n                    }\n                });\n\n                break;\n            }\n\n            // ------------------------------------------\n            // ------------ Invalid Cases ----------------\n            // ------------------------------------------\n\n            default:\n                const componentName = A_CommonHelper.getComponentName(param1);\n\n                throw new A_ScopeError(\n                    A_ScopeError.DeregistrationError,\n                    `Cannot deregister ${componentName} from the scope ${this.name}`\n                );\n        }\n\n    }\n\n    /**\n     * This method is useful when you want to serialize the scope to JSON\n     * \n     * [!] Note this is not a deep serialization, only the fragments are serialized\n     * [!] Fragments are a storage for information which is relevant to the scope\n     * \n     * @returns \n     */\n    toJSON(): Record<string, any> {\n        return this.fragments\n            .reduce((acc, fragment) => {\n\n                const serialized = fragment.toJSON()\n\n                return {\n                    ...acc,\n                    [serialized.name]: serialized\n                }\n            }, {});\n    }\n\n\n\n    //==========================================================================\n    // --------------------Scope Type Check Helpers---------------------------\n    //==========================================================================\n    /**\n     * Type guard to check if the constructor is of type A_Component and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedComponent(ctor: unknown): ctor is _ComponentType[number] {\n        return A_TypeGuards.isComponentConstructor(ctor) && this.allowedComponents.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Entity and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedEntity(ctor: unknown): ctor is A_TYPES__Entity_Constructor<_EntityType[number]> {\n        return A_TypeGuards.isEntityConstructor(ctor) && this.allowedEntities.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Fragment and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedFragment(ctor: unknown): ctor is A_TYPES__Fragment_Constructor<_FragmentType[number]> {\n        return A_TypeGuards.isFragmentConstructor(ctor) && this.allowedFragments.has(ctor);\n    }\n    /**\n     * Type guard to check if the constructor is of type A_Error and is allowed in the scope\n     * \n     * @param ctor \n     * @returns \n     */\n    protected isAllowedError(ctor: unknown): ctor is A_TYPES__Error_Constructor<_ErrorType[number]> {\n        return A_TypeGuards.isErrorConstructor(ctor) && this.allowedErrors.has(ctor);\n    }\n\n\n\n\n    // ==========================================================================\n    // --------------------DEBUG & Helpers Methods--------------------------------\n    // ===========================================================================\n    /**\n     * This method is used to check if the scope is inherited from another scope\n     * \n     * @param scope \n     * @returns \n     */\n    isInheritedFrom(scope: A_Scope): boolean {\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            if (current === scope) {\n                return true;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to check circular inheritance\n     * Should return a full sequence of inheritance for logging purposes\n     * \n     * @param scope \n     * @returns \n     */\n    checkCircularInheritance(scope: A_Scope): Array<string> | false {\n        const inheritanceChain: Array<string> = [];\n        let current: A_Scope | undefined = this._parent;\n\n        while (current) {\n            inheritanceChain.push(current.name);\n            if (current === scope) {\n                return inheritanceChain;\n            }\n            current = current._parent;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper method to print the inheritance chain of the scope\n     */\n    printInheritanceChain(): void {\n        const chain: Array<string> = [];\n        let current: A_Scope | undefined = this;\n\n        while (current) {\n            chain.push(current.name);\n            current = current._parent;\n        }\n\n        console.log(chain.join(' -> '));\n    }\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_ScopeError extends A_Error {\n\n\n    static readonly InitializationError = 'A-Scope Initialization Error';\n\n    static readonly ConstructorError = 'Unable to construct A-Scope instance';\n\n    static readonly ResolutionError = 'A-Scope Resolution Error';\n\n    static readonly RegistrationError = 'A-Scope Registration Error';\n\n    static readonly CircularInheritanceError = 'A-Scope Circular Inheritance Error';\n\n    static readonly CircularImportError = 'A-Scope Circular Import Error';\n\n    static readonly DeregistrationError = 'A-Scope Deregistration Error';\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\n\nexport class A_ContextError extends A_Error {\n\n\n    static NotAllowedForScopeAllocationError = 'Component is not allowed for scope allocation';\n\n    static ComponentAlreadyHasScopeAllocatedError = 'Component already has scope allocated';\n\n    static InvalidMetaParameterError = 'Invalid parameter provided to get meta';\n\n    static InvalidScopeParameterError = 'Invalid parameter provided to get scope';\n\n    static ScopeNotFoundError = 'Scope not found';\n\n    static InvalidFeatureParameterError = 'Invalid parameter provided to get feature';\n\n    static InvalidFeatureDefinitionParameterError = 'Invalid parameter provided to define feature';\n\n    static InvalidFeatureTemplateParameterError = 'Invalid parameter provided to get feature template';\n\n    static InvalidFeatureExtensionParameterError = 'Invalid parameter provided to extend feature';\n\n\n    static InvalidAbstractionParameterError = 'Invalid parameter provided to get abstraction';\n\n    static InvalidAbstractionDefinitionParameterError = 'Invalid parameter provided to define abstraction';\n\n    static InvalidAbstractionTemplateParameterError = 'Invalid parameter provided to get abstraction template';\n\n    static InvalidAbstractionExtensionParameterError = 'Invalid parameter provided to extend abstraction';\n\n    static InvalidInjectionParameterError = 'Invalid parameter provided to get injections';\n\n    static InvalidExtensionParameterError = 'Invalid parameter provided to get extensions';\n\n\n    static InvalidRegisterParameterError = 'Invalid parameter provided to register component';\n\n\n    static InvalidComponentParameterError = 'Invalid component provided';\n\n    static ComponentNotRegisteredError = 'Component not registered in the context';\n\n    static InvalidDeregisterParameterError = 'Invalid parameter provided to deregister component';\n}","\nimport {\n    A_Scope,\n    A_TYPES__Scope_Init,\n    A_TYPES__ScopeConfig,\n    A_TYPES__ScopeLinkedComponents,\n    A_TYPES_ScopeDependentComponents\n} from \"@adaas/a-concept/a-scope\";\nimport {\n    A_Meta,\n    A_TYPES__MetaLinkedComponentConstructors,\n    A_TYPES__MetaLinkedComponents\n} from \"@adaas/a-concept/a-meta\";\nimport type {\n    A_Feature,\n    A_TYPES__FeatureAvailableComponents,\n    A_TYPES__FeatureDefineDecoratorMeta\n} from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_TYPES__Component_Constructor,\n    A_ComponentMeta\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Container,\n    A_TYPES__ContainerMetaKey,\n    A_TYPES__Container_Constructor,\n    A_ContainerMeta\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Entity,\n    A_TYPES__EntityMetaKey,\n    A_TYPES__Entity_Constructor,\n    A_EntityMeta\n} from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__A_StageStep } from \"@adaas/a-concept/a-stage\";\nimport { A_TYPES__ContextEnvironment } from \"./A-Context.types\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_FormatterHelper} from \"@adaas/a-concept/helpers/A_Formatter.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_ContextError } from \"./A-Context.error\";\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport { A_TYPES__ConceptAbstractions } from \"@adaas/a-concept/a-concept\";\nimport { A_Dependency } from \"@adaas/a-concept/a-dependency\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\nimport { A_CONCEPT_ENV } from \"@adaas/a-concept/env\";\n\n\n\nexport class A_Context {\n    // ====================================================================================================\n    // ================================ STATIC PROPERTIES =================================================\n    // ====================================================================================================\n    /**\n     * Default name of the application from environment variable A_CONCEPT_NAME\n     * \n     * [!] If environment variable is not set, it will default to 'a-concept'\n     */\n    static get concept() {\n        return A_CONCEPT_ENV.A_CONCEPT_NAME || 'a-concept';\n    }\n    /**\n     * Root scope of the application from environment variable A_CONCEPT_ROOT_SCOPE\n     * \n     * [!] If environment variable is not set, it will default to 'root'\n     */\n    static get root(): A_Scope {\n        return this.getInstance()._root;\n    }\n    /**\n     * Environment the application is running in.\n     * Can be either 'server' or 'browser'.\n     * [!] Determined by environment variable A_CONCEPT_RUNTIME_ENVIRONMENT that comes from the build tool or is set manually in the environment.\n     */\n    static get environment(): A_TYPES__ContextEnvironment {\n        return A_CONCEPT_ENV.A_CONCEPT_RUNTIME_ENVIRONMENT\n    }\n\n    /**\n     * Singleton instance of the Context\n     */\n    private static _instance: A_Context;\n    // ====================================================================================================\n    // ================================ INTERNAL REGISTRY =================================================\n    // ====================================================================================================\n    /**\n     * Root Scope of the Concept and Environment\n     *\n     * Root scope is the top-level scope that all other scopes inherit from.\n     * It stores global configurations and settings and ALL SHAREABLE RESOURCES.\n     * \n     * [!] Root scope is created automatically when the Context is initialized.\n     * [!] Root scope name can be configured using environment variable A_CONCEPT_ROOT_SCOPE\n     */\n    private _root!: A_Scope\n    /**\n     * A registry that keeps track of scopes for all components (Containers, Features, Commands) \n     * Which can issue a scope allocation.\n     */\n    protected _registry: WeakMap<A_TYPES__ScopeLinkedComponents, A_Scope> = new WeakMap();\n    /**\n     * This is a registry that stores an issuer of each scope allocation.\n     * It helps to track which component (Container, Feature, Command) allocated a specific scope.\n     */\n    protected _scopeIssuers: WeakMap<A_Scope, A_TYPES__ScopeLinkedComponents> = new WeakMap();\n    /**\n     * Stores a context associated with a specific component that depends on a scope.\n     * uses for quick retrieval of the scope for the component.\n     */\n    protected _scopeStorage: WeakMap<A_TYPES_ScopeDependentComponents, A_Scope> = new WeakMap();\n    /**\n     * Stores meta information for different component types by their constructors.\n     * Meta provides to store extra information about the class behavior and configuration.\n     */\n    protected _metaStorage: Map<A_TYPES__MetaLinkedComponentConstructors, A_Meta> = new Map();\n\n\n\n\n    protected _globals = new Map<string, any>();\n\n    /**\n     * Private constructor to enforce singleton pattern.\n     * \n     * [!] This class should not be instantiated directly. Use A_Context.getInstance() instead.\n     */\n    private constructor() {\n        const name = String(A_CONCEPT_ENV.A_CONCEPT_ROOT_SCOPE) || 'root';\n\n        this._root = new A_Scope({ name });\n    }\n\n\n\n    /**\n     * Get the instance of the Namespace Provider.\n     * \n     * If the instance does not exist, it will be created.\n     * \n     * @returns \n     */\n    static getInstance() {\n        if (!A_Context._instance) {\n            A_Context._instance = new A_Context();\n        }\n\n        return A_Context._instance;\n    }\n\n\n\n    /**\n     * Register method allows to register a component with a specific scope in the context.\n     * \n     * @param component - Component to register with a specific scope. Can be either A_Container, A_Feature.\n     * @param scope - Scope to associate the component with.\n     * @returns \n     */\n    static register(\n        /**\n         * Provide the scope that will be associated with the component.\n         */\n        scope: A_Scope,\n        /**\n         * Provide a component that needs to be registered with a specific scope.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Component cannot be null or undefined.`);\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidRegisterParameterError,\n            `Unable to register component. Scope cannot be null or undefined.`);\n\n        if (!this.isAllowedToBeRegistered(component)) throw new A_ContextError(\n            A_ContextError.NotAllowedForScopeAllocationError,\n            `Component ${componentName} is not allowed for scope allocation.`);\n\n        instance._scopeStorage.set(component, scope);\n\n        return scope;\n    }\n\n    /**\n     * Deregister method allows to deregister a component from the context.\n     * \n     * @param component - Component to deregister from the context.\n     */\n    static deregister(\n        /**\n         * Provide a component that needs to be deregistered from the context.\n         */\n        component: A_TYPES_ScopeDependentComponents,\n    ): void {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        const instance = this.getInstance();\n\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidDeregisterParameterError,\n            `Unable to deregister component. Component cannot be null or undefined.`);\n\n        if (!instance._scopeStorage.has(component)) throw new A_ContextError(\n            A_ContextError.ComponentNotRegisteredError,\n            `Unable to deregister component. Component ${componentName} is not registered.`);\n\n        instance._scopeStorage.delete(component);\n    }\n\n    /**\n     * Allocate method instantiates a new scope for the given component and registers it in the context.\n     * It bounds the component (Container, Feature) to a new scope that can be configured and used independently.\n     * \n     * \n     * @param component - Component to allocate the scope for. Can be either A_Container, A_Feature.\n     * @param importing  - Configuration of the scope that will be created for the component.\n     */\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide the scope that will be used as a base for the new scope.\n         */\n        importing: A_Scope\n    ): A_Scope\n    static allocate(\n        /**\n         * Provide a component that needs a scope allocation.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n        /**\n         * Provide configuration for the scope that will be created for the component.\n         */\n        config: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig>\n    ): A_Scope\n    static allocate(\n        component: A_TYPES__ScopeLinkedComponents,\n        importing?: Partial<A_TYPES__Scope_Init & A_TYPES__ScopeConfig> | A_Scope\n    ): A_Scope {\n        // uses only for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // ---------------------------------------------------------------------\n        // ----------------------Input Validation-------------------------------\n        // ---------------------------------------------------------------------\n        // 1) check if component is valid\n        if (!this.isAllowedForScopeAllocation(component))\n            throw new A_ContextError(A_ContextError.NotAllowedForScopeAllocationError, `Component of type ${componentName} is not allowed for scope allocation. Only A_Container, A_Feature are allowed.`);\n        const instance = this.getInstance();\n\n        // 2) check if component already has a scope allocated\n        if (instance._registry.has(component))\n            throw new A_ContextError(A_ContextError.ComponentAlreadyHasScopeAllocatedError, `Component ${componentName} already has a scope allocated.`);\n\n\n        // 3) Create a new scope for the component\n        const newScope = A_TypeGuards.isScopeInstance(importing)\n            ? importing\n            : new A_Scope(importing || {\n                name: componentName + '-scope'\n            }, importing);\n\n        // 4) Make sure that the new scope inherits from the root scope\n        if (!newScope.isInheritedFrom(A_Context.root))\n            newScope.inherit(A_Context.root);\n\n        // 5) Register the component in the appropriate storage\n        instance._registry.set(component, newScope);\n        // Also register the issuer of the scope for faster tracking\n        instance._scopeIssuers.set(newScope, component);\n\n        // 6) Return the newly created scope\n        return newScope;\n    }\n\n    /**\n     * Deallocate method removes the scope allocation for the given component from the context.\n     * \n     * @param component \n     * @returns \n     */\n    static deallocate(\n        /**\n         * A Scope that needs to be deallocated.\n         */\n        scope: A_Scope,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        component: A_TYPES__ScopeLinkedComponents,\n    )\n    static deallocate(\n        /**\n         * Provide a component that needs to have its scope deallocated.\n         */\n        param1: A_TYPES__ScopeLinkedComponents | A_Scope,\n    ) {\n        const instance = this.getInstance();\n\n        const scope = A_TypeGuards.isScopeInstance(param1)\n            ? param1\n            : instance._registry.get(param1);\n\n        if (!scope) return;\n\n        const component = A_TypeGuards.isComponentInstance(param1)\n            ? param1\n            : this.issuer(scope);\n\n        if (component)\n            instance._registry.delete(component);\n        if (scope)\n            instance._scopeIssuers.delete(scope);\n    }\n\n\n\n    /**\n      * Get or Create Meta for the specific class or instance.\n      * This method will return the existing meta if it exists, or create a new one if it doesn't.\n      * \n      * Meta object contains custom metadata based on the class type.\n      * \n      * @param container \n      */\n    static meta<T extends A_ContainerMeta>(\n        /**\n         * Get meta for the specific container class by constructor.\n         */\n        container: A_TYPES__Container_Constructor,\n    ): T\n    static meta<T extends A_ContainerMeta, S extends A_Container>(\n        /**\n         * Get meta for the specific container instance.\n         */\n        container: S,\n    ): T\n    static meta<T extends A_EntityMeta>(\n        /**\n         * Get meta for the specific entity class by constructor.\n         */\n        entity: A_TYPES__Entity_Constructor,\n    ): T\n    static meta<T extends A_EntityMeta>(\n        /**\n         * Get meta for the specific entity instance.\n         */\n        entity: A_Entity,\n    ): T\n    static meta<T extends A_ComponentMeta>(\n        /**\n         * Get meta for the specific component class by constructor.\n         */\n        component: A_TYPES__Component_Constructor,\n    ): T\n    static meta<T extends A_ComponentMeta, S extends A_Component>(\n        /**\n         * Get meta for the specific component instance.\n         */\n        component: S,\n    ): T\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific component class by constructor.\n         */\n        fragment: A_TYPES__Fragment_Constructor,\n    ): T\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific component instance.\n         */\n        fragment: A_Fragment,\n    ): T\n    static meta<T extends A_ComponentMeta>(\n        /**\n         * Get meta for the specific component by its name.\n         */\n        component: string,\n    ): T\n    static meta(\n        /**\n         * Get meta for the specific meta linked component (class or instance).\n         */\n        target: A_TYPES__MetaLinkedComponentConstructors | A_TYPES__MetaLinkedComponents,\n    ): A_ComponentMeta\n    static meta<T extends A_Meta>(\n        /**\n         * Get meta for the specific class or instance\n         */\n        constructor: A_TYPES__Ctor<any>\n    ): T\n    static meta<T extends Record<string, any>>(\n        /**\n         * Get meta for the specific class or instance\n         */\n        constructor: A_TYPES__Ctor<any>\n    ): A_Meta<T>\n\n    static meta<T extends Record<string, any>>(\n        param1: A_TYPES__MetaLinkedComponentConstructors\n            | A_TYPES__MetaLinkedComponents\n            | string\n    ): A_Meta<T> {\n\n        // Get the component name for error messages\n        const componentName = A_CommonHelper.getComponentName(param1);\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for meta storage\n        if (!(\n            this.isAllowedForMeta(param1)\n            || this.isAllowedForMetaConstructor(param1)\n            || A_TypeGuards.isString(param1)\n            || A_TypeGuards.isFunction(param1\n            ))\n        ) throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component of type ${componentName} is not allowed for meta storage. Only A_Container, A_Component and A_Entity are allowed.`);\n\n        let property: A_TYPES__MetaLinkedComponentConstructors;\n        let metaType: typeof A_Meta<T> | typeof A_ContainerMeta | typeof A_ComponentMeta | typeof A_EntityMeta\n\n        switch (true) {\n            // 1) If param1 is instance of A_Container\n            case A_TypeGuards.isContainerInstance(param1): {\n                property = param1.constructor as A_TYPES__Container_Constructor;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 2) If param1 is class of A_Container\n            case A_TypeGuards.isContainerConstructor(param1): {\n                property = param1 as typeof A_Container;\n                metaType = A_ContainerMeta;\n\n                break;\n            }\n            // 3) If param1 is instance of A_Component\n            case A_TypeGuards.isComponentInstance(param1): {\n                property = param1.constructor as A_TYPES__Component_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 4) If param1 is class of A_Component\n            case A_TypeGuards.isComponentConstructor(param1): {\n                property = param1 as typeof A_Component;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 5) If param1 is instance of A_Entity\n            case A_TypeGuards.isEntityInstance(param1): {\n                property = param1.constructor as A_TYPES__Entity_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 6) If param1 is class of A_Entity\n            case A_TypeGuards.isEntityConstructor(param1): {\n                property = param1;\n                metaType = A_EntityMeta;\n\n                break;\n            }\n            // 7) If param1 is instance of A_Fragment\n            case A_TypeGuards.isFragmentInstance(param1): {\n                property = param1.constructor as A_TYPES__Fragment_Constructor;\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 8) If param1 is class of A_Fragment\n            case A_TypeGuards.isFragmentConstructor(param1): {\n                property = param1;\n                metaType = A_EntityMeta;\n\n                break;\n            }\n            // 9) If param1 is string then we need to find the component by its name\n            case typeof param1 === 'string': {\n                const found = Array.from(instance._metaStorage)\n                    .find(([c]) => c.name === param1\n                        || c.name === A_FormatterHelper.toKebabCase(param1)\n                        || c.name === A_FormatterHelper.toPascalCase(param1)\n                    )!;\n                if (!(found && found.length))\n                    throw new A_ContextError(A_ContextError.InvalidMetaParameterError, `Invalid parameter provided to get meta. Component with name ${param1} not found in the meta storage.`);\n\n                property = found[0];\n                metaType = A_ComponentMeta;\n\n                break;\n            }\n            // 10) If param1 is any other class or function\n            default: {\n                property = param1;\n                metaType = A_Meta;\n\n                break;\n            }\n        }\n\n        // Check if the meta already exists for the property, if not create a new one\n        if (!instance._metaStorage.has(property)) {\n\n            let inheritedMeta: A_Meta<any> | undefined = undefined;\n            let currentProperty: any = property;\n\n            // go up to the prototype chain and find if there is any meta to inherit from\n            while (!inheritedMeta) {\n                const parent = Object.getPrototypeOf(currentProperty);\n\n                if (!parent) {\n                    break;\n                }\n                inheritedMeta = instance._metaStorage.get(parent);\n                currentProperty = parent;\n            }\n\n            if (!inheritedMeta)\n                inheritedMeta = new metaType();\n\n            instance._metaStorage.set(property, new metaType().from(inheritedMeta as any));\n        }\n\n        // Return the meta for the property\n        return instance._metaStorage.get(property)!;\n    }\n\n\n\n    /**\n     * Allows to set meta for the specific class or instance.\n     * \n     * @param param1 \n     * @param meta \n     */\n    static setMeta<T extends A_ContainerMeta, S extends A_Container>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_EntityMeta, S extends A_Entity>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_ComponentMeta, S extends A_Component>(\n        param1: S,\n        meta: T\n    )\n    static setMeta<T extends A_Meta>(\n        param1: new (...args: any[]) => any,\n        meta: T\n    )\n    static setMeta<T extends A_Meta>(\n        param1: A_TYPES__MetaLinkedComponentConstructors | A_TYPES__MetaLinkedComponents,\n        meta: T\n    ) {\n        const instance = A_Context.getInstance();\n\n        const existingMeta = A_Context.meta(param1);\n\n        const constructor = typeof param1 === 'function'\n            ? param1\n            : param1.constructor as A_TYPES__MetaLinkedComponentConstructors;\n\n        instance._metaStorage.set(constructor, existingMeta ? meta.from(existingMeta) : meta);\n    }\n\n\n\n\n    /**\n     * \n     * This method allows to get the issuer of a specific scope.\n     * \n     * @param scope - Scope to get the issuer for.\n     * @returns - Component that issued the scope.\n     */\n    static issuer(\n        /**\n         * Provide the scope to get its issuer.\n         */\n        scope: A_Scope\n    ): A_TYPES__ScopeLinkedComponents | undefined {\n\n        const instance = this.getInstance();\n\n        if (!scope) throw new A_ContextError(\n            A_ContextError.InvalidComponentParameterError,\n            `Invalid parameter provided to get scope issuer. Parameter cannot be null or undefined.`\n        );\n\n        // if (!instance._scopeIssuers.has(scope)) throw new A_ContextError(\n        //     A_ContextError.ScopeNotFoundError,\n        //     `Invalid parameter provided to get scope issuer. Provided scope does not have an issuer registered.`\n        // );\n\n        return instance._scopeIssuers.get(scope)!;\n    }\n\n\n\n    /**\n     * Get the scope of the specific class or instance.\n     * \n     * Every execution in Concept has its own scope.\n     * \n     * This method will return the scope of the specific class or instance.\n     * \n     * @param entity \n     */\n    static scope<T extends A_Entity>(\n        /**\n         * Provide an entity to get its scope.\n         */\n        entity: T\n    ): A_Scope\n    static scope<T extends A_Component>(\n        /**\n         * Provide a component to get its scope.\n         */\n        component: T\n    ): A_Scope\n    static scope<T extends A_Container>(\n        /**\n         * Provide a container to get its scope.\n         */\n        container: T\n    ): A_Scope\n    static scope<T extends A_Feature>(\n        /**\n         * Provide a feature to get its scope.\n         */\n        feature: T\n    ): A_Scope\n    static scope<T extends A_Fragment>(\n        /**\n         * Provide a fragment to get its scope.\n         */\n        fragment: T\n    ): A_Scope\n    static scope<T extends A_TYPES__ScopeLinkedComponents | A_TYPES_ScopeDependentComponents>(\n        param1: T\n    ): A_Scope {\n\n        // for error messages\n        const name = (param1 as any)?.constructor?.name || String(param1);\n\n        // Get the instance of the context\n        const instance = this.getInstance();\n\n        // Input validation\n        if (!param1) throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Parameter cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for scope allocation\n        if (!this.isAllowedForScopeAllocation(param1)\n            && !this.isAllowedToBeRegistered(param1)\n        )\n            throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed for scope allocation.`);\n\n        switch (true) {\n            case this.isAllowedForScopeAllocation(param1):\n\n                // Check if the parameter has a scope allocated\n                if (!instance._registry.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope allocated. Make sure to allocate a scope using A_Context.allocate() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed for scope allocation, return the scope\n                return instance._registry.get(param1)!;\n\n            case this.isAllowedToBeRegistered(param1):\n\n                // Check if the parameter has a scope registered\n                if (!instance._scopeStorage.has(param1))\n                    throw new A_ContextError(\n                        A_ContextError.ScopeNotFoundError,\n                        `Invalid parameter provided to get scope. Component of type ${name} does not have a scope registered. Make sure to register the component using A_Context.register() method before trying to get the scope.`\n                    );\n\n                // If the parameter is allowed to be registered, return the scope from the storage\n                return instance._scopeStorage.get(param1)!;\n            default:\n                throw new A_ContextError(A_ContextError.InvalidScopeParameterError, `Invalid parameter provided to get scope. Component of type ${name} is not allowed to be registered.`);\n        }\n    }\n\n\n    // ==========================================================================================================\n    // ================================== FEATURE MANAGEMENT ====================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a template of the feature that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the feature.\n     * \n     * @param name \n     */\n    static featureTemplate(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope = this.scope(component)\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base feature definition from the component\n            ...this.featureDefinition(name, component),\n            // 2) Get all extensions for the feature from other components in the scope\n            ...this.featureExtensions(name, component, scope)\n        ];\n\n        return steps;\n    }\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns all extensions for the specific feature in the specific component within the provided scope.\n     * Scope dictates which components are active and can provide extensions for the feature.\n     * \n     * [!] This method only returns extensions, not the base feature definition.\n     * \n     * @param scope \n     * @returns \n     */\n    static featureExtensions(\n        /**\n         * Provide the name of the feature to get the template for. Regular expressions are also supported to match multiple features.\n         */\n        name: string | RegExp,\n        /**\n         * Provide the component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n        /**\n         * Provide the scope that dictates which components are active and can provide extensions for the feature.\n         */\n        scope: A_Scope\n    ): Array<A_TYPES__A_StageStep> {\n\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n        if (!name) throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForFeatureDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidFeatureExtensionParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n\n        const callNames = A_CommonHelper.getClassInheritanceChain(component)\n            .filter(c => c !== A_Component && c !== A_Container && c !== A_Entity)\n            .map(c => `${c.name}.${name}`);\n\n        // const callNames = [`${A_CommonHelper.getComponentName(component)}.${name}`];\n        // const callNames = [`BaseComponent.testFeature`];\n\n        const steps: Map<string, A_TYPES__A_StageStep> = new Map();\n\n        const allowedComponents: Set<A_TYPES__MetaLinkedComponentConstructors> = new Set();\n\n        for (const callName of callNames) {\n            // We need to get all components that has extensions for the feature in component\n            for (const [cmp, meta] of instance._metaStorage) {\n                // Just try to make sure that component not only Indexed but also presented in scope\n                if (scope.has(cmp) && (\n                    A_TypeGuards.isComponentMetaInstance(meta)\n                    ||\n                    A_TypeGuards.isContainerMetaInstance(meta)\n                )) {\n                    allowedComponents.add(cmp);\n                    // Get all extensions for the feature\n                    meta\n                        .extensions(callName)\n                        .forEach((declaration) => {\n                            const inherited = Array.from(allowedComponents).reverse().find(c => A_CommonHelper.isInheritedFrom(cmp, c) && c !== cmp);\n\n                            if (inherited) {\n                                steps.delete(`${A_CommonHelper.getComponentName(inherited)}.${declaration.handler}`);\n                            }\n\n                            steps.set(`${A_CommonHelper.getComponentName(cmp)}.${declaration.handler}`, {\n                                dependency: new A_Dependency(cmp),\n                                ...declaration\n                            });\n                        });\n                }\n            }\n        }\n\n        return instance.filterToMostDerived(scope, Array.from(steps.values()));\n    }\n\n\n    /**\n     * method helps to filter steps in a way that only the most derived classes are kept.\n     * \n     * @param scope \n     * @param items \n     * @returns \n     */\n    private filterToMostDerived(\n        scope: A_Scope,\n        items: A_TYPES__A_StageStep[]): Array<A_TYPES__A_StageStep> {\n        return items.filter(item => {\n            // const currentClass = scope.resolveConstructor(item.dependency.name)\n            const currentClass = scope.resolveConstructor(item.dependency.name)\n\n            // Check if this class is parent of any other in the list\n            const isParentOfAnother = items.some(other => {\n                if (other === item) return false;\n\n                const otherClass = scope.resolveConstructor(other.dependency.name);\n\n                if (!currentClass || !otherClass) return false;\n\n                return currentClass.prototype.isPrototypeOf(otherClass.prototype);\n            });\n\n            // Keep only classes that are not parent of any other\n            return !isParentOfAnother;\n        });\n    }\n\n\n    /**\n     * This method returns the feature template definition without any extensions.\n     * It can be used to retrieve the base template for a feature before any modifications are applied.\n     * \n     * [!] This method does not consider extensions from other components.\n     * \n     * @param feature \n     * @param component \n     * @returns \n     */\n    static featureDefinition(\n        /**\n         * Name of the feature to get the template for.\n         * Regular expressions are also supported to match multiple features.\n         */\n        feature: string | RegExp,\n        /**\n         * Component to get the feature template from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        let metaKey;\n\n        if (!feature)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Feature name cannot be null or undefined.`);\n        if (!component)\n            throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `Unable to get feature template. Component cannot be null or undefined.`);\n\n\n        switch (true) {\n            case component instanceof A_Entity:\n                metaKey = A_TYPES__EntityMetaKey.FEATURES;\n                break;\n            case component instanceof A_Container:\n                metaKey = A_TYPES__ContainerMetaKey.FEATURES\n                break;\n            case component instanceof A_Component:\n                metaKey = A_TYPES__ComponentMetaKey.FEATURES\n                break;\n\n            default:\n                throw new A_ContextError(A_ContextError.InvalidFeatureTemplateParameterError, `A-Feature cannot be defined on the ${component} level`);\n        }\n\n        const featureDefinition: A_TYPES__FeatureDefineDecoratorMeta | undefined = this.meta(component)\n            ?.get(metaKey)\n            ?.get(feature);\n\n        return [\n            ...(featureDefinition?.template || [])\n        ];\n    }\n\n    // ==========================================================================================================\n    // ================================== ABSTRACTION MANAGEMENT =================================================\n    // ==========================================================================================================\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Primary Methods -------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n    /**\n     * Returns a definition of the abstraction that can be then used to create a new A-Feature Instance\n     * \n     * [!] Note: Steps/Stages included are fully dependent on the scope provided since it dictates which components are active and can provide extensions for the abstraction.\n     * \n     * @param abstraction \n     */\n    static abstractionTemplate(\n        /**\n         * Provide the abstraction stage to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        // name for error messages\n        const componentName = (A_CommonHelper.getComponentName(component));\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`);\n\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionTemplateParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`);\n\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError(A_ContextError.InvalidAbstractionTemplateParameterError, `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`);\n\n        const steps: A_TYPES__A_StageStep[] = [\n            // 1) Get the base abstraction definition from the component\n            // [!] No abstraction Definitions -> They are limited to Concept Abstractions ONLY\n            // ...this.abstractionDefinition(abstraction, component),\n\n            // 2) Get all extensions for the abstraction from other components in the scope\n            ...this.abstractionExtensions(abstraction, component)\n        ];\n\n        return steps;\n    }\n\n    // ----------------------------------------------------------------------------------------------------------\n    // -----------------------------------Helper Methods --------------------------------------------------------\n    // ----------------------------------------------------------------------------------------------------------\n\n    static abstractionExtensions(\n        /**\n         * Provide the abstraction name to get the definition for.\n         */\n        abstraction: A_TYPES__ConceptAbstractions,\n        /**\n         * Provide the component to get the abstraction definition from.\n         */\n        component: A_TYPES__FeatureAvailableComponents,\n    ): Array<A_TYPES__A_StageStep> {\n        const instance = this.getInstance();\n        // name for error messages\n        const componentName = A_CommonHelper.getComponentName(component);\n\n        // Input validation\n        if (!component) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Component cannot be null or undefined.`\n        );\n        if (!abstraction) throw new A_ContextError(\n            A_ContextError.InvalidAbstractionExtensionParameterError,\n            `Unable to get feature template. Abstraction stage cannot be null or undefined.`\n        );\n        // Check if the parameter is allowed for feature definition\n        if (!A_TypeGuards.isAllowedForAbstractionDefinition(component))\n            throw new A_ContextError\n                (A_ContextError.InvalidAbstractionExtensionParameterError,\n                    `Unable to get feature template. Component of type ${componentName} is not allowed for feature definition.`\n                );\n\n        const steps: Map<string, A_TYPES__A_StageStep> = new Map();\n\n        const scope = this.scope(component);\n\n        // We need to get all components that has extensions for the feature in component\n        const allowedComponents: Set<A_TYPES__MetaLinkedComponentConstructors> = new Set();\n\n        for (const [cmp, meta] of instance._metaStorage) {\n            // Just try to make sure that component not only Indexed but also presented in scope\n            if (scope.has(cmp) && (\n                A_TypeGuards.isComponentMetaInstance(meta)\n                || A_TypeGuards.isContainerMetaInstance(meta)\n            )) {\n                allowedComponents.add(cmp);\n                // Get all extensions for the feature\n                meta\n                    .abstractions(abstraction)\n                    .forEach((declaration) => {\n                        const inherited = Array.from(allowedComponents).reverse().find(c => A_CommonHelper.isInheritedFrom(cmp, c) && c !== cmp);\n\n                        if (inherited) {\n                            steps.delete(`${A_CommonHelper.getComponentName(inherited)}.${declaration.handler}`);\n                        }\n\n                        steps.set(`${A_CommonHelper.getComponentName(cmp)}.${declaration.handler}`, {\n                            dependency: new A_Dependency(cmp),\n                            ...declaration\n                        });\n                    });\n            }\n        }\n\n        return instance.filterToMostDerived(scope, Array.from(steps.values()));\n    }\n\n\n    /**\n     * Resets the Context to its initial state.\n     */\n    static reset() {\n        const instance = A_Context.getInstance();\n\n        instance._registry = new WeakMap();\n\n        const name = String(A_CONCEPT_ENV.A_CONCEPT_ROOT_SCOPE) || 'root';\n\n        instance._root = new A_Scope({ name });\n    }\n\n\n\n\n    // ====================================================================================================================\n    // ====================================== HELPERS & GUARDS ============================================================\n    // ====================================================================================================================\n    /**\n     * Type guard to check if the param is allowed for scope allocation.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForScopeAllocation(param: any): param is A_TYPES__ScopeLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isFeatureInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed to be registered in the context.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedToBeRegistered(param: any): param is A_TYPES_ScopeDependentComponents {\n        return A_TypeGuards.isEntityInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isFragmentInstance(param)\n            || A_TypeGuards.isErrorInstance(param);\n    }\n\n    /**\n     * Type guard to check if the param is allowed for meta storage.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMeta(param: any): param is A_TYPES__MetaLinkedComponents {\n        return A_TypeGuards.isContainerInstance(param)\n            || A_TypeGuards.isComponentInstance(param)\n            || A_TypeGuards.isEntityInstance(param);\n    }\n    /**\n     * Type guard to check if the param is allowed for meta storage by constructor.\n     * \n     * @param param \n     * @returns \n     */\n    static isAllowedForMetaConstructor(param: any): param is A_TYPES__MetaLinkedComponentConstructors {\n        return A_TypeGuards.isContainerConstructor(param)\n            || A_TypeGuards.isComponentConstructor(param)\n            || A_TypeGuards.isEntityConstructor(param);\n    }\n\n\n\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\nexport class A_AbstractionError extends A_Error {\n    /**\n     * This error code indicates that there was an issue extending the abstraction execution\n     */\n    static readonly AbstractionExtensionError = 'Unable to extend abstraction execution';\n\n}","import {\n    A_TYPES__AbstractionDecoratorConfig,\n    A_TYPES__AbstractionDecoratorDescriptor\n} from \"./A-Abstraction.types\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport {\n    A_Container,\n    A_ContainerMeta,\n    A_TYPES__ContainerMetaKey\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_ComponentMeta\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_TYPES__ConceptAbstraction,\n    A_TYPES__ConceptAbstractions\n} from \"@adaas/a-concept/a-concept\";\nimport { A_AbstractionError } from \"./A-Abstraction.error\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\n\n/**\n * A-Abstraction Extend decorator allows to extends behavior of each concept abstraction execution. \n * In case some components or containers requires to extend the behavior of the abstraction like 'start', 'build' or 'deploy'\n * for example, this decorator allows to do so.    \n * \n * @param name - abstraction name \n * @param config - configuration of the abstraction extension\n * @returns \n */\nexport function A_Abstraction_Extend(\n    /**\n     * Name of the Concept Abstraction to extend\n     */\n    name: A_TYPES__ConceptAbstractions,\n    /**\n     * Configuration of the Abstraction Extension\n     * \n     */\n    config: Partial<A_TYPES__AbstractionDecoratorConfig> = {}\n) {\n    return function (\n        target: A_Container | A_Component,\n        propertyKey: string,\n        descriptor: A_TYPES__AbstractionDecoratorDescriptor\n    ) {\n        // for error messages\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!name)\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Abstraction name must be provided to extend abstraction for '${componentName}'.`,\n            );\n\n        //  Only Containers and Components can extend Concept Abstractions\n        if (!A_TypeGuards.isConstructorAvailableForAbstraction(target)) {\n            throw new A_AbstractionError(\n                A_AbstractionError.AbstractionExtensionError,\n                `Unable to extend Abstraction '${name}' for '${componentName}'. Only A-Containers and A-Components can extend Abstractions.`,\n            );\n        }\n\n        let metaKey;\n        const meta: A_ContainerMeta | A_ComponentMeta = A_Context.meta(target);\n\n        switch (true) {\n            case A_TypeGuards.isContainerConstructor(target) || A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.ABSTRACTIONS\n                break;\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.ABSTRACTIONS\n                break;\n        }\n        const setName = `CONCEPT_ABSTRACTION::${name}`;\n\n        // Get the existed metadata or create a new one\n        const existedMeta: A_Meta<{\n            [Key: string]: A_TYPES__ConceptAbstraction[];\n        }> = meta.get(metaKey) ?\n                new A_Meta().from(meta.get(metaKey))\n                : new A_Meta();\n\n        // Set the metadata of the method to define a custom Stage with name\n        const existedMetaValue = [\n            ...(existedMeta.get(setName) || [])\n        ];\n\n        const existedIndex = existedMetaValue.findIndex(item => item.handler === propertyKey);\n\n        const abstraction = {\n            name: setName,\n            handler: propertyKey,\n            behavior: config.behavior || 'sync',\n            throwOnError: config.throwOnError !== undefined ? config.throwOnError : true,\n\n            before: A_TypeGuards.isArray(config.before)\n                ? new RegExp(`^${config.before.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.before instanceof RegExp\n                    ? config.before.source\n                    : '',\n            after: A_TypeGuards.isArray(config.after)\n                ? new RegExp(`^${config.after.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n\n            override: A_TypeGuards.isArray(config.override)\n                ? new RegExp(`^${config.override.join('|').replace(/\\./g, '\\\\.')}$`).source\n                : config.after instanceof RegExp\n                    ? config.after.source\n                    : '',\n        }\n\n        if (existedIndex !== -1) {\n            // Update the existing method in the metadata\n            existedMetaValue[existedIndex] = abstraction;\n        } else {\n            // Add the new method to the metadata\n            existedMetaValue.push(abstraction);\n        }\n\n        // Set the metadata of the method to define a custom Feature with name\n        existedMeta.set(setName, existedMetaValue);\n\n        //  Update the metadata of the container with the new Stage definition\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    };\n}\n","import { A_Abstraction_Extend } from \"./A-Abstraction-Extend.decorator\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport { A_TYPES__Abstraction_Init } from \"./A-Abstraction.types\";\nimport { A_Scope } from \"@adaas/a-concept/a-scope\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_TYPES__ConceptAbstractions } from \"@adaas/a-concept/a-concept\";\n\n\n\nexport class A_Abstraction {\n\n    /**\n     * The name of the Abstraction e.g. 'deploy', 'start', 'test', etc.\n     */\n    protected _name: A_TYPES__ConceptAbstractions;\n    /**\n     * List of features that are part of this Abstraction\n     */\n    protected _features: A_Feature[] = [];\n    /**\n     * The Feature currently being processed\n     */\n    protected _current?: A_Feature;\n    /**\n     * Actual Index of the current Feature being processed\n     */\n    protected _index: number = 0;\n\n\n    /**\n     * Allows to extends A-Abstraction with additional methods\n     */\n    static get Extend(): typeof A_Abstraction_Extend {\n        return A_Abstraction_Extend;\n    }\n\n    /**\n     * A-Abstraction is an object that is common for any application. \n     * By providing components and creating abstraction extensions it's possible to create a unique behavior of the whole solution.\n     * \n     * Every application has basic abstractions like 'start', 'stop', 'deploy', 'test', etc. \n     * They can be easily extended with additional logic from both containers and components.\n     * \n     * \n     * @param params \n     */\n    constructor(\n        /**\n         * Parameters to define the A-Abstraction\n         */\n        params: A_TYPES__Abstraction_Init\n    ) {\n        this._name = params.name;\n\n        this._features = params.containers.map(container => {\n            const template = A_Context.abstractionTemplate(\n                this._name,\n                container\n            );\n            return new A_Feature({\n                name: this._name,\n                component: container,\n                template\n            })\n        });\n\n        this._current = this._features[0];\n    }\n\n    /**\n     * Returns the name of the Abstraction\n     */\n    get name(): string { return this._name; }\n    /**\n     * Returns the current Feature being processed\n     */\n    get feature(): A_Feature | undefined {\n        return this._current;\n    }\n    /**\n     * This method checks if the A-Feature is done\n     * \n     * @returns \n     */\n    get isDone(): boolean {\n        return !this.feature\n            || this._index >= this._features.length\n\n    }\n\n\n    [Symbol.iterator](): Iterator<A_Feature, any> {\n        return {\n            // Custom next method\n            next: (): IteratorResult<A_Feature, any> => {\n                if (!this.isDone) {\n\n                    this._current = this._features[this._index];\n\n                    return {\n                        value: this._current,\n                        done: false\n                    };\n                } else {\n\n                    this._current = undefined; // Reset current on end\n\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n            }\n        };\n    }\n\n    /**\n     * This method moves the Abstraction processing to the next Feature in the list\n     * \n     * @param stage \n     */\n    next(stage) {\n        if (this._index >= this._features.length) {\n            return;\n        }\n\n        const stageIndex = this._features.indexOf(stage);\n\n        this._index = stageIndex + 1;\n    }\n\n\n\n    /**\n     * Allows to process all stages of the Abstraction\n     * \n     * @returns \n     */\n    async process(\n        /**\n         * Allows to override the scope in which the Abstraction will be processed\n         * \n         */\n        scope?: A_Scope\n    ) {\n        if (this.isDone)\n            return;\n\n        for (const feature of this._features) {\n\n            await feature.process(scope);\n        }\n    }\n}","import { A_Error } from \"@adaas/a-concept/a-error\";\n\n\nexport class A_InjectError extends A_Error {\n    static readonly InvalidInjectionTarget = 'Invalid target for A-Inject decorator';\n\n    static readonly MissingInjectionTarget = 'Missing target for A-Inject decorator';\n}","import {\n    A_TYPES__A_InjectDecorator_Meta,\n    A_TYPES__A_InjectDecoratorReturn,\n    A_TYPES__InjectableTargets\n} from \"./A-Inject.types\";\nimport {\n    A_Component,\n    A_TYPES__ComponentMetaKey,\n    A_TYPES__Component_Constructor\n} from \"@adaas/a-concept/a-component\";\nimport {\n    A_Fragment,\n    A_TYPES__Fragment_Constructor\n} from \"@adaas/a-concept/a-fragment\";\nimport {\n    A_TYPES__ContainerMetaKey\n\n} from \"@adaas/a-concept/a-container\";\nimport {\n    A_TYPES__Entity_Constructor,\n    A_TYPES__EntityMetaKey\n} from \"@adaas/a-concept/a-entity\";\nimport { A_Context } from \"@adaas/a-concept/a-context\";\nimport { A_Meta } from \"@adaas/a-concept/a-meta\";\nimport { A_Entity } from \"@adaas/a-concept/a-entity\";\nimport { A_TYPES__Feature_Constructor } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Caller,\n    A_TYPES__Caller_Constructor\n} from \"@adaas/a-concept/a-caller\";\nimport { A_TypeGuards} from \"@adaas/a-concept/helpers/A_TypeGuards.helper\";\nimport { A_CommonHelper} from \"@adaas/a-concept/helpers/A_Common.helper\";\nimport { A_InjectError } from \"./A-Inject.error\";\nimport {\n    A_Scope,\n    A_TYPES__Scope_Constructor\n} from \"@adaas/a-concept/a-scope\";\nimport { A_Feature } from \"@adaas/a-concept/a-feature\";\nimport {\n    A_Error,\n    A_TYPES__Error_Constructor\n} from \"@adaas/a-concept/a-error\";\nimport {\n    A_Dependency,\n    A_TYPES__A_DependencyInjectable,\n    A_TYPES__A_DependencyResolutionStrategy\n} from \"@adaas/a-concept/a-dependency\";\nimport { A_TYPES__Ctor } from \"@adaas/a-concept/types\";\n\n\n/**\n * A-Inject decorator\n * \n * This Decorator allows to inject dependencies into the module like \n * - Namespaces \n * - Other Concepts \n * - or maybe Components\n * \n * @param params - see overloads\n * @returns - decorator function\n */\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the Component constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Component from current Scope or from Parent Scopes.\n     */\n    component: A_TYPES__Component_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\n// Allows to inject just one Context Fragment\nexport function A_Inject<T extends A_Fragment>(\n    /**\n     * Provide the Fragment constructor to inject the Fragment instance\n     *\n     * [!] It returns the Fragment instance from current Scope or from Parent Scopes.\n     */\n    fragment: A_TYPES__Fragment_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Entity>(\n    /**\n     * Provide the Entity constructor to inject the Entity instance\n     * \n     * [!] Note: It returns the Entity instance from current Scope or from Parent Scopes.\n     * [!] Note: If instance has more than one Entity of the same type It returns FIRST found Entity\n     * [!] Note: Use 'config' to specify to inject specific one or even Array of Entities\n     */\n    entity: A_TYPES__Entity_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     * \n     * [!] Default Pagination is 1 if it's necessary to get multiple Entities please customize it in the instructions\n     */\n    config?: Partial<A_TYPES__A_DependencyResolutionStrategy<T>>\n): A_TYPES__A_InjectDecoratorReturn<T>\nexport function A_Inject<T extends A_Component>(\n    /**\n     * Provide the name of Component constructor to inject the Component instance\n     * \n     * [!] You can use both customized one or original depending on your overriding strategy\n     */\n    ctor: string\n): A_TYPES__A_InjectDecoratorReturn\n//  Allows to inject just one A_FeatureCaller\nexport function A_Inject<T extends A_Caller>(\n    /**\n     * Provide the A_Caller constructor to inject the Caller instance\n     *\n     * [!] It returns initiator of the call, e.g. Container/Component/Command who called Feature \n     */\n    caller: A_TYPES__Caller_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\n//  Allows to inject just one A_Error instance\nexport function A_Inject<T extends A_Error>(\n    /***\n     * Provide the Error constructor that will be associated with the injection.\n     *\n     * [!] It returns an Instance of the Error what is executed.\n     */\n    error: A_TYPES__Error_Constructor<T>,\n    /**\n     * Provide additional instructions on how to perform the injection\n     *\n     * [!] Default Pagination is 1 if it's necessary to get multiple Fragments please customize it in the instructions\n     */\n    config?: Omit<Partial<A_TYPES__A_DependencyResolutionStrategy<T>>, 'query' | 'pagination'>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_Feature>(\n    /**\n     * Provide the Feature constructor that will be associated with the injection.\n     * \n     * [!] It returns an Instance of the Feature what is executed. \n     */\n    feature: A_TYPES__Feature_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\n// Allows to inject just one Scope instance\nexport function A_Inject<T extends A_Scope>(\n    /***\n     * Provide the Scope constructor that will be associated with the injection.\n     *\n     * [!] It returns an instance of the Scope where the Entity/Component/Container is defined.\n     */\n    scope: A_TYPES__Scope_Constructor<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_TYPES__A_DependencyInjectable>(\n    /***\n     * Provide the Scope constructor that will be associated with the injection.\n     *\n     * [!] It returns an instance of the Scope where the Entity/Component/Container is defined.\n     */\n    dependency: A_Dependency<T>\n): A_TYPES__A_InjectDecoratorReturn\nexport function A_Inject<T extends A_TYPES__A_DependencyInjectable>(\n    param1: string | A_TYPES__Ctor<T> | A_Dependency<T>,\n    param2?: Partial<A_TYPES__A_DependencyResolutionStrategy<T>>\n): A_TYPES__A_InjectDecoratorReturn {\n\n    //  pre call checks\n    if (!param1) {\n        throw new A_InjectError(\n            A_InjectError.MissingInjectionTarget,\n            `A-Inject decorator is missing the target to inject`\n        );\n    }\n\n\n    return function (\n        target: A_TYPES__InjectableTargets,\n        methodName: string | symbol | undefined,\n        parameterIndex: number\n    ) {\n        // for Error handling purposes\n        const componentName = A_CommonHelper.getComponentName(target)\n\n        if (!A_TypeGuards.isTargetAvailableForInjection(target)) {\n            throw new A_InjectError(\n                A_InjectError.InvalidInjectionTarget,\n                `A-Inject cannot be used on the target of type ${typeof target} (${componentName})`\n            );\n        }\n\n        // determine the method name or 'constructor' for constructor injections\n        const method = methodName ? String(methodName) : 'constructor';\n        let metaKey;\n\n        switch (true) {\n            case A_TypeGuards.isComponentConstructor(target) || A_TypeGuards.isComponentInstance(target):\n                metaKey = A_TYPES__ComponentMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isContainerInstance(target):\n                metaKey = A_TYPES__ContainerMetaKey.INJECTIONS;\n                break;\n\n            case A_TypeGuards.isEntityInstance(target):\n                metaKey = A_TYPES__EntityMetaKey.INJECTIONS;\n                break;\n        }\n\n        // get existing meta or create a new one\n        const existedMeta = A_Context.meta(target).get(metaKey) || new A_Meta();\n        // get existing injections for the method or create a new array\n        const paramsArray: A_TYPES__A_InjectDecorator_Meta = existedMeta.get(method) || [];\n\n        // set the parameter injection info\n        paramsArray[parameterIndex] = param1 instanceof A_Dependency ? param1 : new A_Dependency(param1, param2);\n\n        // save back the updated injections array\n        existedMeta.set(method, paramsArray);\n\n        // save back the updated meta info\n        A_Context\n            .meta(target)\n            .set(\n                metaKey,\n                existedMeta\n            );\n    }\n}"]}